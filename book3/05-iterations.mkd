
Επανάληψη
=========

\index{επανάληψη}

Ενημέρωση μεταβλητών
--------------------

\index{ενημέρωση}
\index{μεταβλητή!ενημέρωση}

Ένα συνηθισμένο μοτίβο στις εντολές εκχώρησης είναι μια εντολή εκχώρησης που
ενημερώνει μια μεταβλητή και η νέα τιμή της μεταβλητής εξαρτάται από την παλιά.

~~~~ {.python}
x = x + 1
~~~~

Αυτό σημαίνει "πάρε την τρέχουσα τιμή του `x`, πρόσθεσε 1 και μετά
ενημερώστε το `x` με τη νέα τιμή."

Εάν προσπαθήσετε να ενημερώσετε μια μεταβλητή που δεν υπάρχει, λαμβάνετε ένα
σφάλμα, επειδή η Python αξιολογεί το δεξί μέλος πριν εκχωρήσει μια τιμή στο
`x`:

~~~~ {.python}
>>> x = x + 1
NameError: name 'x' is not defined
~~~~

Πριν μπορέσετε να ενημερώσετε μια μεταβλητή, θα πρέπει να την
*αρχικοποιήσετε*, συνήθως με μια απλή εκχώρηση:

\index{αρχικοποίηση (πριν την ενημέρωση)}

~~~~ {.python}
>>> x = 0
>>> x = x + 1
~~~~

Η ενημέρωση μιας μεταβλητής προσθέτοντας 1 ονομάζεται *αύξηση (increment)*,
ενώ η αφαίρεση του 1 ονομάζεται *μείωση (decrement)*.

\index{increment}
\index{decrement}
\index{αύξηση}
\index{μείωση}

Η εντολή `while`
----------------

\index{εντολή!while}
\index{while βρόχος}
\index{βρόχος!while}
\index{επανάληψη}

Οι υπολογιστές χρησιμοποιούνται συχνά για την αυτοματοποίηση επαναλαμβανόμενων
εργασιών. Η επανάληψη ίδιων ή παρόμοιων εργασιών χωρίς σφάλματα είναι κάτι που
οι υπολογιστές κάνουν καλά και οι άνθρωποι όχι και τόσο καλά. Επειδή η
επανάληψη είναι τόσο συνηθισμένη, η Python παρέχει πολλές γλωσσικές δυνατότητες
για να το διευκολύνει.

Μια μορφή επανάληψης στην Python είναι η εντολή `while`. Εδώ έχουμε ένα απλό
πρόγραμμα που μετρά αντίστροφα από το πέντε και μετά λέει "Blastoff!".

~~~~ {.python}
n = 5
while n > 0:
    print(n)
    n = n - 1
print('Blastoff!')
~~~~

Μπορείτε σχεδόν να διαβάσετε τη δήλωση `while` σαν να ήταν Αγγλικά. Σημαίνει,
"Όσο το `n` είναι μεγαλύτερο από 0, εμφανίστε την τιμή του `n` και στη έπειτα
μειώστε την τιμή του `n` κατά 1. Όταν φτάσει στο 0, βγες από την εντολή `while`
και εμφανίστε τη λέξη `Blastoff` !"

\index{ροή εκτέλεσης}

Πιο επίσημα, αυτή είναι η ροή της εκτέλεσης για μια εντολή `while`:

1.  Αξιολογήστε τη συνθήκη, δίνοντας `True (Αληθής)` ή `False (Ψευδής)`.

2.  Εάν η συνθήκη είναι ψευδής, βγες από την ενολή `while` και συνέχισε
    την εκτέλεση με την επόμενη εντολή.

3.  Εάν η συνθήκη είναι αληθής, εκτέλεσε τις εντολές μέσα στη `while` και στη
    συνέχεια πήγαινε πίσω στο βήμα 1.

Αυτός ο τύπος ροής ονομάζεται *βρόχος (loop)* επειδή το τρίτο βήμα επαναφέρει
την εκτέλεση και πάλι στην αρχή. Καλούμε, κάθε εκτέλεση του σώματος του βρόχου,
*επανάληψη*. Για τον παραπάνω βρόχο, θα λέγαμε, "Πραγματοποιεί πέντε επαναλήψεις",
που σημαίνει ότι το σώμα του βρόχου εκτελέστηκε πέντε φορές.

\index{συνθήκη}
\index{βρόχος}
\index{σώμα}

Στο σώμα του βρόχου θα πρέπει να αλλάξει την τιμή μιας ή περισσότερων
μεταβλητών έτσι ώστε τελικά η συνθήκη να γίνει ψευδής και ο βρόχος να
τερματιστεί. Καλούμε τη μεταβλητή που αλλάζει κάθε φορά που εκτελείται ο
βρόχος και ελέγχει πότε θα τερματίσει ο βρόχος *μεταβλητή επανάληψης*. Εάν
δεν υπάρχει μεταβλητή επανάληψης, ο βρόχος θα επαναλαμβάνεται επ' άπειρον,
με αποτέλεσμα έναν *ατέρμων βρόχο*.

Ατέρμονες βρόχοι
----------------

Μια ατελείωτη πηγή διασκέδασης για τους προγραμματιστές είναι η παρατήρηση ότι
οι οδηγίες στα σαμπουάν, "Σαπουνίστε, ξεπλύνετε, επαναλάβετε", είναι ένας
ατέρμων βρόχος, επειδή δεν υπάρχει *μεταβλητή επανάληψης* που να σας λέει πόσες
φορές να εκτελέσετε τον βρόχο.

index{ατέρμων βρόχος}
\index{βρόχος!ατέρμων}

Στην περίπτωση της `αντίστροφης μέτρησης`, μπορούμε να αποδείξουμε ότι ο βρόχος
τερματίζεται επειδή γνωρίζουμε ότι η τιμή του `n` είναι πεπερασμένη και
μπορούμε να δούμε ότι η τιμή του `n` ελαττώνεται κάθε φορά που εκτελείται ο
βρόχος, οπότε τελικά πρέπει να φτάσει στο 0. Άλλες φορές ένας βρόχος είναι
προφανώς άπειρος επειδή δεν έχει καμία μεταβλητή επανάληψης.

\index{break εντολή}
\index{εντολή!break}

Μερικές φορές δεν γνωρίζεται ότι είναι ώρα να τερματίσετε έναν βρόχο παρά μόνο
όταν έχετε φτάσει στα μισά του σώματος. Σε αυτήν την περίπτωση, μπορείτε να
γράψετε εσκεμμένα έναν ατέρνων βρόχο και στη συνέχεια να χρησιμοποιήσετε την
εντολή `break` για να βγείτε από τον βρόχο.

Αυτός ο βρόχος είναι προφανώς ένας *ατέρνων βρόχος* επειδή η λογική έκφραση
στην `while` είναι απλώς η λογική σταθερά `True`:

~~~~ {.python}
n = 10
while True:
    print(n, end=' ')
    n = n - 1
print('Τέλος!')
~~~~

Εάν κάνετε το λάθος και εκτελέσετε αυτόν τον κώδικα, θα μάθετε γρήγορα πώς να
διακόψετε μια εκτρεπόμενη διαδικασία Python στο σύστημά σας ή θα βρείτε πού
βρίσκεται το κουμπί απενεργοποίησης στον υπολογιστή σας. Αυτό το πρόγραμμα
θα λειτουργεί επ' άπειρον ή τουλάχιστον μέχρι να εξαντληθεί η μπαταρία σας
επειδή η λογική έκφραση στην αρχή του βρόχου είναι πάντα αληθής, λόγω του ότι
η έκφραση είναι η σταθερή τιμή `True`.

Αν και πρόκειται για έναν δυσλειτουργικό ατέρμων βρόχο, μπορούμε να
χρησιμοποιήσουμε αυτό το μοτίβο για να δημιουργήσουμε χρήσιμους βρόχους, αρκεί
να προσθέσουμε προσεκτικά κώδικα στο σώμα του βρόχου για να βγούμε ρητά από τον
βρόχο χρησιμοποιώντας `break` όταν έχουμε φτάσει στην κατάσταση εξόδου.

Για παράδειγμα, ας υποθέσουμε ότι θέλετε να λαμβάνετε είσοδο από τον χρήστη
μέχρι να πληκτρολογήσει `τέλος`. Θα μπορούσατε να γράψετε:

\VerbatimInput{../code3/copytildone1.py}

Η συνθήκη βρόχου είναι `True`, η οποία είναι πάντα αληθής, επομένως ο βρόχος
εκτελείται επανειλημμένα μέχρι να συναντήσει στην εντολή break.

Κάθε φορά που εκτελείται, προτρέπει τον χρήστη με ένα σύμβολο μεγαλύτερου.
Εάν ο χρήστης πληκτρολογήσει `τέλος`, η εντολή `break` διακόπτει
την εκτέλεση του βρόχου. Διαφορετικά, το πρόγραμμα επαναλαμβάνει ό,τι
πληκτρολογεί ο χρήστης και επιστρέφει στην αρχή του βρόχου. Εδώ είναι
ένα δείγμα εκτέλεσης:

~~~~{text}
> hello there
hello there
> finished
finished
> τέλος
Τέλος!
~~~~

Αυτός ο τρόπος γραφής των βρόχων `while` είναι συνηθισμένος επειδή μπορείτε
να ελέγξετε τη συνθήκη οπουδήποτε στον βρόχο (όχι μόνο στην αρχή) και μπορείτε
να εκφράσετε τη συνθήκη διακοπής καταφατικά ("σταμάτα όταν συμβεί αυτό") και
όχι αρνητικά ("συνεχισε μέχρι να συμβεί αυτό.").

Ολοκλήρωση επαναλήψεων με `continue`
------------------------------------

\index{continue εντολή}
\index{εντολή!continue}

Μερικές φορές βρίσκεστε σε μια επανάληψη ενός βρόχου και θέλετε να ολοκληρώσετε
την τρέχουσα εκτέλεσή της και να μεταβείτε άμεσα στην επόμενη εκτέλεση. Σε
αυτήν την περίπτωση, μπορείτε να χρησιμοποιήσετε την εντολή `continue` για να
μεταβείτε στην επόμενη εκτέλεση χωρίς να ολοκληρώσετε το σώμα του βρόχου για
την τρέχουσα εκτέλεση.

Ακολουθεί ένα παράδειγμα βρόχου που αντιγράφει την είσοδό του έως ότου ο
χρήστης πληκτρολογήσει `τέλος`, αλλά αντιμετωπίζει τις γραμμές που ξεκινούν
με τον χαρακτήρα # (Αριθμός - hash), ως γραμμές που δεν πρέπει να εκτυπωθούν
(κάπως σαν σχόλια της Python).

\VerbatimInput{../code3/copytildone2.py}

Ακολουθεί ένα δείγμα εκτέλεσης αυτού του νέου προγράμματος με την προσθήκη του
`continue`.

~~~~{text}
> hello there
hello there
> # don't print this
> print this!
print this!
> τέλος
Τέλος!
~~~~

Όλες οι γραμμές εκτυπώνονται εκτός από αυτή που ξεκινά με το σύμβολο αριθμού,
επειδή όταν εκτελεστεί η `continue`, τερματίζει την τρέχουσα εκτέλεση και
μεταπηδά πίσω στην αρχή της εντολής `while` για να ξεκινήσει η επόμενη
εκτέλεση, παρακάμπτοντας έτσι την εντολή `print`.

Ορισμός βρόχων με χρήση της `for`
---------------------------------

\index{for εντολή}
\index{εντολή!for}

Μερικές φορές θέλουμε να κάνουμε να διατρέξουμε ένα *σύνολο* πραγμάτων, όπως
μια λίστα λέξεων, τις γραμμές ενός αρχείου ή μια λίστα αριθμών. Όταν έχουμε
να διατρέξουμε μια λίστα πραγμάτων, μπορούμε να κατασκευάσουμε έναν βρόχο
*καθορισμένο* χρησιμοποιώντας μια εντολή `for`. Ονομάζουμε την `while`
*αόριστο* βρόχο επειδή απλώς επαναλαμβάνεται μέχρις ότου κάποια συνθήκη γίνει
`Ψευδής - False`, ενώ ο βρόχος `for` διατρέχει ένα γνωστό σύνολο στοιχείων,
επομένως εκτελεί τόσες επαναλήψεις όσα και τα στοιχεία του συνόλου.

Η σύνταξη ενός βρόχου `for` είναι παρόμοια με του βρόχου `while`, καθώς και
στε αυτόν υπάρχει μια δήλωση `for` και ένα σώμα βρόχου:

~~~~ {.python}
φίλοι = ['Δημήτρης', 'Σοφία', 'Άρης']
for φίλος in φίλοι:
    print('Καλή χρονιά:', φίλος)
print('Τέλος!')
~~~~

Στην ορολογία της Python, η μεταβλητή `φίλοι` είναι μια λίστα^[Θα εξετάσουμε
λεπτομερέστερα τις λίστες σε επόμενο κεφάλαιο.] τριών συμβολοσειρών και ο
βρόχος `for` περνάει από τη λίστα και εκτελεί το σώμα μία φορά για καθεμιά από
τις τρεις συμβολοσειρές στη λίστα, καταλήγοντας αυτήν την έξοδο:

~~~~ {.python}
Καλή χρονιά: Δημήτρης
Καλή χρονιά: Σοφία
Καλή χρονιά: Άρης
Done!
~~~~

Η μετάφραση αυτού του βρόχου `for` στα Αγγλικά δεν είναι τόσο άμεση όσο του
`while`, αλλά αν σκεφτείτε τους φίλους ως ένα *σύνολο*, έχει ως εξής:
"Εκτελέστε τις εντολές στο σώμα του βρόχου for μία φορά για κάθε φίλο *που
ανήκει (in)* στο σετ με όνομα φίλοι."

Κοιτάζοντας τον βρόχο `for`, το *for* και το *in* είναι δεσμευμένες λέξεις
της Python και τα `φίλος` και `φίλοι` είναι μεταβλητές.

~~~~ {.python}
for φίλος in φίλοι:
    print('Καλή χρονιά:', φίλος)
~~~~

Συγκεκριμένα, το `φίλος` είναι η *μεταβλητή επανάληψης* για τον βρόχο for.
Η μεταβλητή `φίλος` αλλάζει σε κάθε επανάληψη του βρόχου και ελέγχει την
ολοκλήρωση ο βρόχος `for`. Η *μεταβλητή επανάληψης* πέρνει διαδοχικά τις
τιμές των τριών συμβολοσειρών που είναι αποθηκευμένες στη μεταβλητή `φίλοι`.

Μοτίβα βρόχων
-------------

Συχνά χρησιμοποιούμε έναν βρόχο `for` ή `while` για να διατρέξουμε μια λίστα
αντικειμένων ή τα περιεχόμενα ενός αρχείου και αναζητούμε κάτι όπως τη
μεγαλύτερη ή τη μικρότερη τιμή των δεδομένων που σαρώνουμε.

Αυτοί οι βρόχοι κατασκευάζονται γενικά ως εξής:

- Αρχικοποίηση μιας ή περισσότερων μεταβλητών πριν από την έναρξη του βρόχου

- Εκτέλεση ορισμένων υπολογισμών σε κάθε στοιχείο στο σώμα του βρόχου, πιθανώς
    αλλάζοντας τις μεταβλητές στο σώμα του βρόχου

- Εξέταση των μεταβλητών που προκύπτουν όταν ολοκληρωθεί ο βρόχος

Θα χρησιμοποιήσουμε μια λίστα αριθμών για να δείξουμε τις έννοιες και τον τρόπο
κατασκευή αυτών των μοτίβων βρόχων.

### Βρόχοι μέτρησης και άθροισης

Για παράδειγμα, για να μετρήσουμε τον αριθμό των στοιχείων σε μια λίστα, θα
γράφαμε τον ακόλουθο βρόχο `for`:

~~~~ {.python}
count = 0
for itervar in [3, 41, 12, 9, 74, 15]:
    count = count + 1
print('Count: ', count)
~~~~

Αρχικοποιούμε τη μεταβλητή `count` με το μηδέν πριν ξεκινήσει ο βρόχος,
και, στη συνέχεια, γράφουμε έναν βρόχο `for` για να διατρέξει τη λίστα των
αριθμών. Η μεταβλητή *επανάληψης* ονομάζεται `itervar` και ενώ δεν
χρησιμοποιούμε το `itervar` μέσα στον βρόχο, ελέγχει τον βρόχο και προκαλεί
την εκτέλεση του σώματος του βρόχου μία φορά για καθεμία από τις τιμές στη
λίστα.

Στο σώμα του βρόχου, προσθέτουμε 1 στην τρέχουσα τιμή του `count` για καθεμία
από τις τιμές στη λίστα. Ενώ εκτελείται ο βρόχος, η τιμή του `count` είναι το
πλήθος των τιμών που έχουμε δει «μέχρι στιγμής».

Μόλις ολοκληρωθεί ο βρόχος, η τιμή του `count` είναι ο συνολικός αριθμός των
στοιχείων. Ο συνολικός αριθμός «πέφτει στην αγκαλιά μας» στο τέλος του βρόχου.
Κατασκευάζουμε τον βρόχο έτσι ώστε να έχουμε αυτό που θέλουμε όταν τελειώσει ο
βρόχος.

Άλλος ένας, παρόμοιος βρόχος, που υπολογίζει το άθροισμα ενός συνόλου αριθμών
είναι ο εξής:

~~~~ {.python}
total = 0
for itervar in [3, 41, 12, 9, 74, 15]:
    total = total + itervar
print('Total: ', total)
~~~~

Σε αυτόν τον βρόχο *χρησιμοποιούμε* τη *μεταβλητή επανάληψης*. Αντί απλώς να
προσθέσουμε ένα στο `count` όπως στον προηγούμενο βρόχο, προσθέτουμε τον
πραγματικό αριθμό (3, 41, 12, κ.λπ.) στο τρέχον σύνολο κατά τη διάρκεια κάθε
επανάληψης του βρόχου. Αν σκεφτείτε τη μεταβλητή `total`, περιέχει το «τρέχον
σύνολο των μέχρι στιγμής τιμών». Έτσι, πριν ξεκινήσει ο βρόχος, το `total`
είναι μηδέν, επειδή δεν έχουμε δει ακόμη τιμές, κατά τη διάρκεια του βρόχου το
`total` είναι το τρέχον σύνολο και στο τέλος του βρόχου το `total` είναι το
γενικό σύνολο όλων των τιμών στο λίστα.

Καθώς εκτελείται ο βρόχος, στο `total` συσσωρεύεται το άθροισμα των στοιχείων.
Μια μεταβλητή που χρησιμοποιείται με αυτόν τον τρόπο μερικές φορές ονομάζεται
*αθροιστής - accumulator*.

\index{accumulator!sum}
\index{αθροιστής!sum}

Ούτε ο βρόχος μέτρησης ούτε ο βρόχος άθροισης είναι ιδιαίτερα χρήσιμοι στην
πράξη επειδή υπάρχουν οι ενσωματωμένες συναρτήσεις `len()` και `sum()` που
υπολογίζουν τον αριθμό των στοιχείων σε μια λίστα και το σύνολο των στοιχείων
στη λίστα αντίστοιχα.

### Βρόχοι μέγιστου και ελάχιστου

\index{βρόχος!μέγιστο}
\index{βρόχος!ελάχιστο}
\index{None ειδική τιμή}
\index{ειδική τιμή!None}

Για να βρούμε τη μεγαλύτερη τιμή σε μια λίστα ή ακολουθία, κατασκευάζουμε
τον ακόλουθο βρόχο:

~~~~ {.python}
μέγιστο = None
print('Πριν:', μέγιστο)
for αριθμό in [3, 41, 12, 9, 74, 15]:
    if μέγιστο is None or αριθμό > μέγιστο :
        μέγιστο = αριθμό
    print('Εκτέλεση:', αριθμό, μέγιστο)
print('Μέγιστο:', μέγιστο)
~~~~

Όταν το πρόγραμμα εκτελείται, η έξοδος είναι η εξής:

~~~~{text}
Πριν: None
Εκτέλεση: 3 3
Εκτέλεση: 41 41
Εκτέλεση: 12 41
Εκτέλεση: 9 41
Εκτέλεση: 74 74
Εκτέλεση: 15 74
Μέγιστο: 74
~~~~

Τη μεταβλητή `μέγιστο` είναι καλύτερα να τη σκέφτεστε ως τη «μεγαλύτερη τιμή
που έχουμε δει μέχρι τώρα». Πριν από τον βρόχο, αρχικοποιήσαμε το `μέγιστο` με
τη σταθερά `None`. Το `None` είναι μια ειδική σταθερή τιμή την οποία μπορούμε
να αποθηκεύσουμε σε μια μεταβλητή για να επισημάνουμε τη μεταβλητή ως «κενή».

Πριν ξεκινήσει ο βρόχος, η μεγαλύτερη τιμή που έχουμε δει μέχρι στιγμής είναι
`None`, καθώς δεν έχουμε δει ακόμη τιμές. Ενώ εκτελείται ο βρόχος, εάν το
`μέγιστο` είναι `None`, τότε παίρνουμε την πρώτη τιμή που βλέπουμε ως τη
μεγαλύτερη μέχρι στιγμής. Μπορείτε να δείτε στην πρώτη επανάληψη πότε η τιμή
του `αριθμό` είναι 3, αφού το `μέγιστο` είναι `None`, ορίσαμε αμέσως το
`μέγιστο` σε 3.

Μετά την πρώτη επανάληψη, το `μέγιστο` δεν είναι πλέον `None`, επομένως
ενεργοποιείται το δεύτερο μέρος της σύνθετης λογικής έκφρασης που ελέγχει
το `αριθμό > μέγιστο`, μόνο όταν βλέπουμε μια τιμή μεγαλύτερη από τη
«μεγαλύτερη μέχρι τώρα». Όταν βλέπουμε μια νέα τιμή "ακόμη μεγαλύτερη",
παίρνουμε αυτή τη νέα τιμή για `μέγιστο`. Μπορείτε να δείτε στην έξοδο του
προγράμματος ότι το `μέγιστο` προχωρά από 3 σε 41 σε 74.

Στο τέλος του βρόχου, έχουμε σαρώσει όλες τις τιμές και η μεταβλητή `μέγιστο`
περιέχει τώρα τη μεγαλύτερη τιμή στη λίστα.

Για τον υπολογισμό του μικρότερου αριθμού, ο κώδικας είναι παρόμοιος με μια
μικρή αλλαγή:

~~~~ {.python}
ελάχιστο = None
print('Πριν:', ελάχιστο)
for αριθμό in [3, 41, 12, 9, 74, 15]:
    if ελάχιστο is None or αριθμό < smallest:
        ελάχιστο = αριθμό
    print('Εκτέλεση:', αριθμό, ελάχιστο)
print('Ελάχιστο:', ελάχιστο)
~~~~

Και πάλι, το `ελάχιστο` είναι το "μικρότερο μέχρι στιγμής" πριν, κατά τη
διάρκεια και μετά την εκτέλεση του βρόχου. Όταν ολοκληρωθεί ο βρόχος, το
`ελάχιστο` περιέχει την ελάχιστη τιμή στη λίστα.

Και πάλι, όπως και στην καταμέτρηση και την άθροιση, οι ενσωματωμένες
συναρτήσεις `max()` και `min()` καθιστούν περιττή τη γραφή των παραπάνω βρόχων.

Το ακόλουθο είναι μια απλή έκδοση της ενσωματωμένης συνάρτησης `min()` της
Python:

~~~~ {.python}
def min(values):
    smallest = None
    for value in values:
        if smallest is None or value < smallest:
            smallest = value
    return smallest
~~~~

Στην εκδοχή της συνάρτησης του μικρότερου κώδικα, αφαιρέσαμε όλες τις εντολές
`print` και χρησιμοποιήσαμε τα αντίστοιχα αγγλικά ονόματα μεταβλητών, ώστε να
είναι ισοδύναμη με τη συνάρτηση `min` που είναι ήδη ενσωματωμένη στην Python.

Εκσφαλμάτωση
------------

Καθώς αρχίζετε να γράφετε μεγαλύτερα προγράμματα, μπορεί να χριαστεί να
ξοδέψετε περισσότερος χρόνος εκσφαλμάτωσης. Περισσότερος κώδικας σημαίνει
περισσότερες πιθανότητες να κάνετε λάθος και περισσότερα μέρη που κρύβουν
σφάλματα.

\index{εκσφαλμάτωση!με διχοτόμηση}
\index{διχοτόμηση, εκσφαλμάτωση}

Ένας τρόπος για να μειώσετε το χρόνο εντοπισμού και διόρθωσης σφαλμάτων είναι η
"εκσφαλμάτωση με διχοτόμηση". Για παράδειγμα, εάν υπάρχουν 100 γραμμές στο
πρόγραμμά σας και τις ελέγξετε μία κάθε φορά, θα χρειαστείτε 100 βήματα.

Αντίθετα, προσπαθήστε να σπάσετε το πρόβλημα στο μισό. Κοιτάξτε στη μέση του
προγράμματος ή κοντά σε αυτήν, για μια ενδιάμεση τιμή που μπορείτε να ελέγξετε.
Προσθέστε μια εντολή `print` (ή κάτι άλλο που έχει επαληθεύσιμο αποτέλεσμα) και
εκτελέστε το πρόγραμμα.

Εάν ο έλεγχος στο μέσο σημείο είναι λανθασμένος, το πρόβλημα πρέπει να
βρίσκεται στο πρώτο μισό του προγράμματος. Αν είναι σωστός, το πρόβλημα
βρίσκεται στο δεύτερο μισό.

Κάθε φορά που εκτελείτε έναν έλεγχο όπως αυτόν, μειώνετε στο μισό τον αριθμό
των γραμμών που πρέπει να ελέγξετε. Μετά από έξι βήματα (τα οποία είναι πολύ
λιγότερα από 100), θα καταλήξετε σε μία ή δύο γραμμές κώδικα, τουλάχιστον
θεωρητικά.

Στην πράξη δεν είναι πάντα σαφές ποιο είναι το "μέσο του προγράμματος" και δεν
είναι πάντα δυνατό να το ελέγξουμε. Δεν έχει νόημα να μετράμε γραμμές και να
βρίσκουμε το ακριβές μέσο. Αντίθετα, σκεφτείτε μέρη στο πρόγραμμα όπου μπορεί
να υπάρχουν σφάλματα και μέρη στα οποία είναι εύκολο να βάλετε έναν έλεγχο.
Στη συνέχεια, επιλέξτε ένα σημείο όπου πιστεύετε ότι οι πιθανότητες είναι
περίπου οι ίσες για τις περιπτώσεις το σφάλμα να είναι πριν ή μετά τον έλεγχο.

Γλωσσάριο
---------

αθροιστής
:   Μια μεταβλητή που χρησιμοποιείται σε έναν βρόχο για να υπολογίσει ένα
    άθροισμα
\index{αθροιστής}

αρχικοποίηση
:   Μια εκχώρηση που δίνει μια αρχική τιμή σε μια μεταβλητή που θα ενημερωθεί.
\index{αρχικοποίηση}

ατρέρμων βρόχος
:   Ένας βρόχος στον οποίο η συνθήκη τερματισμού δεν ικανοποιείται ποτέ ή για
    τον οποίο δεν υπάρχει τερματική συνθήκη.
\index{ατρέρμων βρόχος}

αύξηση
:   Μια ενημέρωση που αυξάνει την τιμή μιας μεταβλητής (συχνά κατά ένα).
\index{αύξηση}
\index{increment}

επανάληψη
:   Επαναλαμβανόμενη εκτέλεση ενός συνόλου εντολών χρησιμοποιώντας είτε μια
    συνάρτηση που καλεί τον εαυτό της είτε έναν βρόχο.
\index{επανάληψη}

μείωση
:   Μια ενημέρωση που μειώνει την τιμή μιας μεταβλητής.
\index{μείωση}
\index{decrement}

μετρητής
:   Μια μεταβλητή που χρησιμοποιείται σε έναν βρόχο για να μετρήσει πόσες
    φορές συνέβη κάτι. Αρχικοποιούμε έναν μετρητή με το μηδέν και μετά
    αυξάνουμε τον μετρητή κάθε φορά που θέλουμε να "μετρήσουμε" κάτι.
\index{μετρητής}

Ασκήσεις
--------

**Άσκηση 1: Γράψτε ένα πρόγραμμα, το οποίο διαβάζει επαναληπτικά αριθμούς μέχρι
ο χρήστης να εισάγει `τέλος`. Όταν εισαχθεί `τέλος`, εκτυπώνει το άθροισμα, το
πλήθος και τον μέσο όρο των αριθμών. Εάν ο χρήστης εισάγει οτιδήποτε άλλο εκτός
από αριθμούς, εντοπίζει το λάθος με χρήση των `try` και `except`, εκτυπώνει ένα
μήνυμα λάθους και ζητά τον επόμενο αριθμό.**

~~~~{text}
Εισάγετε έναν αριθμό: 4
Εισάγετε έναν αριθμό: 5
Εισάγετε έναν αριθμό: bad data
Μη έγκυρη είσοδος
Εισάγετε έναν αριθμό: 7
Εισάγετε έναν αριθμό: τέλος
16 3 5.333333333333333
~~~~

**Άσκηση 2: Γράψτε ένα άλλο πρόγραμμα, το οποίο ζητά μια λίστα αριθμών, όπως
και παραπάνω και στο τέλος εκτυπώνει το μέγιστο και το ελάχιστο όλων των
αριθμών αντί για τον μέσο όρο.**
