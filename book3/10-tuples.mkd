
Πλειάδες
========

Οι πλειάδες είναι αμετάβλητες
-----------------------------

\index{πλειάδες}
\index{τύπος!πλειάδες}
\index{ακολουθία}

Μια πλειάδα^[Ενδιαφέρουσα πληροφορία: Η λέξη "tuple (πλειάδα)" προέρχεται από
τα ονόματα που δίνονται σε ακολουθίες αριθμών διαφορετικού μήκους: μονή, διπλή,
τριπλή, τετραπλή, πενταπλή (quintuple), εξάπλη (sextuple), επταπλή (septuple),
κ.λπ.] είναι μια ακολουθία τιμών που μοιάζει πολύ με μια λίστα. Οι τιμές που
είναι αποθηκευμένες σε μια πλειάδα μπορούν να είναι οποιουδήποτε τύπου και
έχουν δείκτες ακέραιους αριθμούς. Η σημαντική διαφορά είναι ότι οι πλειάδες
είναι *αμετάβλητες*. Οι πλειάδες είναι επίσης *συγκρίσιμες* και
*κατακερματισμένες*, ώστε να μπορούμε να ταξινομήσουμε λίστες τους και να
χρησιμοποιήσουμε πλειάδες ως κλειδιά - τιμές σε λεξικά της Python.

\index{μεταβλητότητα}
\index{hashable}
\index{κατακερματιζόμενος}
\index{συγκρίσιμος-η-ο}
\index{αμεταβλητότητα}

Συντακτικά, μια πλειάδα είναι μια λίστα τιμών διαχωρισμένη με κόμματα:

~~~~ {.python}
>>> t = 'a', 'b', 'c', 'd', 'e'
~~~~

Αν και δεν είναι απαραίτητο, είναι σύνηθες να περικλείουμε τις πλειάδες σε
παρενθέσεις, για να βοηθηθούμε στο να αναγνωρίσουμε γρήγορα τις πλειάδες,
όταν κοιτάμε τον κώδικα Python:

\index{παρενθέσεις!πλειάδες σε}

~~~~ {.python}
>>> t = ('a', 'b', 'c', 'd', 'e')
~~~~

Για να δημιουργήσετε μια πλειάδα με ένα μόνο στοιχείο, πρέπει να συμπεριλάβετε
το τελικό κόμμα:

\index{µεµονωµένο}
\index{πλειάδα!µεµονωµένο}

~~~~ {.python .trinket}
>>> t1 = ('a',)
>>> type(t1)
<type 'tuple'>
~~~~

Χωρίς κόμμα, η Python αντιμετωπίζει το `('a')` ως έκφραση με μια συμβολοσειρά
σε παρένθεση, που αποτιμάται σε μια συμβολοσειρά:

~~~~ {.python}
>>> t2 = ('a')
>>> type(t2)
<type 'str'>
~~~~

Ένας άλλος τρόπος κατασκευής πλειάδας είναι η ενσωματωμένη συνάρτηση `tuple`.
Χωρίς όρισμα, δημιουργεί μια κενή πλειάδα:

\index{tuple συνάρτηση}
\index{συνάρτηση!tuple}

~~~~ {.python .trinket}
>>> t = tuple()
>>> print(t)
()
~~~~

Εάν το όρισμα είναι μια ακολουθία (συμβολοσειρά, λίστα ή πλειάδα), το
αποτέλεσμα της κλήσης της `tuple` είναι μια πλειάδα με τα στοιχεία της
ακολουθίας:

~~~~ {.python .trinket}
>>> t = tuple('lupins')
>>> print(t)
('l', 'u', 'p', 'i', 'n', 's')
~~~~

Επειδή το `tuple` είναι το όνομα ενός κατασκευαστή, θα πρέπει να αποφύγετε τη
χρήση του ως όνομα μεταβλητής.

Οι περισσότεροι τελεστές λιστών λειτουργούν και σε πλειάδες. Ο τελεστής αγκύλης
ευρετηριάζει ένα στοιχείο:

\index{αγκύλη τελεστής}
\index{τελεστής!αγκύλη}

~~~~ {.python .trinket}
>>> t = ('a', 'b', 'c', 'd', 'e')
>>> print(t[0])
'a'
~~~~

Και ο τελεστής διαμέρισης επιλέγει μια σειρά στοιχείων.

\index{διαμέριση τελεστής}
\index{τελεστής!διαμέριση}
\index{πλειάδα!διαμέριση}
\index{διαμέριση!πλειάδα}

~~~~ {.python}
>>> print(t[1:3])
('b', 'c')
~~~~

Αλλά αν προσπαθήσετε να τροποποιήσετε ένα από τα στοιχεία της πλειάδας,
λαμβάνετε ένα σφάλμα:

\index{εξαίρεση!TypeError}
\index{TypeError}
\index{στοιχείο εκχώρηση}
\index{εκχώρηση!στοιχείο}

~~~~ {.python}
>>> t[0] = 'A'
TypeError: object doesn't support item assignment
~~~~

Δεν μπορείτε να τροποποιήσετε τα στοιχεία μιας πλειάδας, αλλά μπορείτε να
αντικαταστήσετε μια πλειάδα με μια άλλη:

~~~~ {.python .trinket}
>>> t = ('A',) + t[1:]
>>> print(t)
('A', 'b', 'c', 'd', 'e')
~~~~

Σύγκριση πλειάδων
-----------------

\index{σύγκριση!πλειάδα}
\index{πλειάδα!σύγκριση}
\index{sort μέθοδος}
\index{μέθοδος!sort}

Οι τελεστές σύγκρισης λειτουργούν με πλειάδες και άλλες ακολουθίες. Η Python
ξεκινά συγκρίνοντας το πρώτο στοιχείο από κάθε ακολουθία. Αν είναι ίσα,
πηγαίνει στο επόμενο στοιχείο και ούτω καθεξής, μέχρι να βρει στοιχεία που
διαφέρουν. Τα επόμενα στοιχεία δεν λαμβάνονται υπόψη (ακόμα και αν είναι
πραγματικά μεγάλα).

~~~~ {.python .trinket}
>>> (0, 1, 2) < (0, 3, 4)
True
>>> (0, 1, 2000000) < (0, 3, 4)
True
~~~~

Η συνάρτηση `sort` λειτουργεί με τον ίδιο τρόπο. Ταξινομεί κυρίως κατά το
πρώτο στοιχείο, αλλά στην περίπτωση ισοπαλίας, ταξινομεί κατά το δεύτερο
στοιχείο και ούτω καθεξής.

Αυτό το χαρακτηριστικό προσφέρεται σε ένα μοτίβο που ονομάζεται *DSU* for

Decorate - Διακοσμώ
: μια ακολουθία δημιουργώντας μια λίστα πλειάδων με ένα ή περισσότερα κλειδιά
    ταξινόμησης που προηγούνται των στοιχείων των πλειάδων,

Sort - Ταξινομώ
: τη λίστα των πλειάδων, χρησιμοποιώντας την ενσωματωμένη `sort` της Python και

Undecorate - Αφαιρώ τη διακόσμηση
: εξάγοντας τα ταξινομημένα στοιχεία της ακολουθίας.

\index{DSU πρότυπο}
\index{πρότυπο!DSU}
\index{decorate-sort-undecorate πρότυπο}
\index{πρότυπο!decorate-sort-undecorate}
\index{Romeo and Juliet}
\index{Ρωμαίος και Ιουλιέτα}

Για παράδειγμα, ας υποθέσουμε ότι έχετε μια λίστα λέξεων και θέλετε να τις
ταξινομήσετε από αυτή με το μεγαλύτερο μήκος προς στη συντομότερη:

\VerbatimInput{../code3/soft.py}

Ο πρώτος βρόχος δημιουργεί μια λίστα με πλειάδες, όπου κάθε πλειάδα είναι μια
λέξη με προπορευόμενο το μήκος της.

Η `sort` συγκρίνει τα πρώτα στοιχεία των πλειάδων, το μήκος. Το όρισμα
δεμευμένης λέξης `reverse=True` λέει στην `sort` να λειτουργήσει με φθίνουσα
σειρά.

\index{δεμευμένη λέξη, όρισμα}
\index{όρισμα!δεμευμένη λέξη}
\index{διάσχιση}

Ο δεύτερος βρόχος διασχίζει τη λίστα των πλειάδων και δημιουργεί μια λίστα
λέξεων με φθίνουσα σειρά μήκους. Οι λέξεις των τεσσάρων χαρακτήρων
ταξινομούνται με *αντίστροφη* αλφαβητική σειρά, επομένως το "what" εμφανίζεται
πριν από το "soft" στην παρακάτω λίστα.

Η έξοδος του προγράμματος είναι η εξής:

~~~~{text}
['yonder', 'window', 'breaks', 'light', 'what', 'soft', 'but', 'in']
~~~~

Φυσικά η γραμμή χάνει μεγάλο μέρος του ποιητικού της αντίκτυπου όταν μετατραπεί
σε λίστα Python και ταξινομηθεί σε φθίνουσα σειρά μήκους λέξεων.

Εκχώρηση τιμής σε πλειάδα
-------------------------

\index{πλειάδα!εκχώρηση τιμής}
\index{εκχώρηση τιμής!πλειάδα}
\index{αντιμετάθεση μοτίβο}
\index{μοτίβο!αντιμετάθεση}

Ένα από τα μοναδικά συντακτικά χαρακτηριστικά της γλώσσας Python είναι η
δυνατότητα να υπάρχει πλειάδα στην αριστερή πλευρά μιας δήλωσης ανάθεσης. Αυτό
σας επιτρέπει να εκχωρήσετε τιμή σε περισσότερες από μία μεταβλητές τη φορά
όταν το αριστερό μέλος είναι μια ακολουθία.

Σε αυτό το παράδειγμα έχουμε μια λίστα δύο στοιχείων (η οποία είναι μια
ακολουθία) και εκχωρούμε το πρώτο και το δεύτερο στοιχείο της ακολουθίας στις
μεταβλητές `x` και `y` σε μία μόνο πρόταση.

~~~~ {.python .trinket}
>>> m = [ 'have', 'fun' ]
>>> x, y = m
>>> x
'have'
>>> y
'fun'
>>>
~~~~

    Δεν είναι μαγικό, η Python *χονδρικά* μεταφράζει τη σύνταξη της πολλαπλής
    ανάθεσης ως εξής: ^[Η Python δεν μεταφράζει τη σύνταξη κυριολεκτικά. Για
    παράδειγμα, εάν το δοκιμάσετε με ένα λεξικό, δεν θα λειτουργήσει όπως θα
    περιμένατε.]

~~~~ {.python .trinket}
>>> m = [ 'have', 'fun' ]
>>> x = m[0]
>>> y = m[1]
>>> x
'have'
>>> y
'fun'
>>>
~~~~

Στυλιστικά, όταν χρησιμοποιούμε πλειάδα στο αριστερό μέλος της εντολής
εκχώρησης, παραλείπουμε τις παρενθέσεις, αλλά το ακόλουθο αποτελεί μια εξίσου
έγκυρη σύνταξη:

~~~~ {.python}
>>> m = [ 'have', 'fun' ]
>>> (x, y) = m
>>> x
'have'
>>> y
'fun'
>>>
~~~~

Μια ιδιαίτερα έξυπνη εφαρμογή της εκχώρησης σε πλειάδα μας επιτρέπει να
*αντιμεταθέσουμε* τις τιμές δύο μεταβλητών σε μια μόνο πρόταση:

~~~~ {.python}
>>> a, b = b, a
~~~~

Και στα δύο μέλη αυτής της εντολής έχουμε πλειάδες, αλλά στο αριστερό μέλος
είναι μια πλειάδα μεταβλητών. Στο δεξί μέλος έχουμε μια πλειάδα εκφράσεων. Κάθε
τιμή στο δεξί μέλος εκχωρείται στην αντίστοιχη μεταβλητή του αριστερού μέλους.
Όλες οι εκφράσεις στη δεξιά πλευρά αξιολογούνται πριν από οποιαδήποτε από τις
εκχωρήσεις.

Ο αριθμός των μεταβλητών στα αριστερά και ο αριθμός των τιμών στα δεξιά πρέπει
να είναι ο ίδιος:

\index{exception!ValueError}
\index{ValueError}

~~~~ {.python}
>>> a, b = 1, 2, 3
ValueError: too many values to unpack
~~~~

Γενικότερα, στο δεξί μέλος μπορεί να υπάρχει κάθε είδους ακολουθία
(συμβολοσειρά, λίστα ή πλειάδα). Για παράδειγμα, για να χωρίσετε μια διεύθυνση
email σε όνομα χρήστη και τομέα, θα μπορούσατε να γράψετε:

\index{split μέθοδος}
\index{μέθοδος!split}
\index{email address}
\index{διεύθυνση ηλεκτρονικού ταχυδρομείου}

~~~~ {.python}
>>> addr = 'monty@python.org'
>>> uname, domain = addr.split('@')
~~~~

Η επιστρεφόμενη τιμή από το `split` είναι μια λίστα με δύο στοιχεία. Το πρώτο
στοιχείο εκχωρείται στο `uname`, το δεύτερο στο `domain`.

~~~~ {.python}
>>> print(uname)
monty
>>> print(domain)
python.org
~~~~

Λεξικά και πλειάδες
-------------------

\index{λεξικό}
\index{items μέθοδος}
\index{μέθοδος!items}
\index{ζεύγος κλειδιού-τιμής}

Τα λεξικά έχουν μια μέθοδο που ονομάζεται `items`, που επιστρέφει μια λίστα
πλειάδων, όπου κάθε πλειάδα είναι ένα ζεύγος κλειδιού-τιμής:

~~~~ {.python .trinket}
>>> d = {'a':10, 'b':1, 'c':22}
>>> t = list(d.items())
>>> print(t)
[('b', 1), ('a', 10), ('c', 22)]
~~~~

Όπως θα έπρεπε να περιμένετε από ένα λεξικό, τα στοιχεία δεν είναι σε σειρά.

Ωστόσο, δεδομένου ότι η λίστα των πλειάδων είναι μια λίστα και οι πλειάδες
είναι συγκρίσιμες, μπορούμε τώρα να ταξινομήσουμε τη λίστα των πλειάδων. Η
μετατροπή ενός λεξικού σε λίστα πλειάδων είναι ένας τρόπος για να εξάγουμε τα
περιεχόμενα ενός λεξικού ταξινομημένα κατά κλειδί:

~~~~ {.python}
>>> d = {'a':10, 'b':1, 'c':22}
>>> t = list(d.items())
>>> t
[('b', 1), ('a', 10), ('c', 22)]
>>> t.sort()
>>> t
[('a', 10), ('b', 1), ('c', 22)]
~~~~

Η νέα λίστα ταξινομείται με αύξουσα αλφαβητική σειρά με βάση την τιμή κλειδιού.

Πολλαπλές εκχωρήσεις με λεξικά
------------------------------

\index{διάσχιση!λεξικό}
\index{λεξικό!διάσχιση}

Συνδυάζοντας `items`, εκχώρηση σε πλειάδα και `for`, μπορείτε να δημιουργήσετε
ένα ωραίο μοτίβο κώδικα για τη προσπέλαση των κλειδιών και των τιμών ενός
λεξικού με έναν μόνο βρόχο:

~~~~ {.python}
for κλειδί, τιμή in list(d.items()):
    print(τιμή, κλειδί)
~~~~

Αυτός ο βρόχος έχει δύο *μεταβλητές επανάληψης* επειδή το `items` επιστρέφει
μια λίστα πλειάδων και το `key, val` είναι μια ανάθεση πλειάδας, που
επαναλαμβάνεται διαδοχικά μέσω καθενός από τα ζεύγη κλειδιού-τιμής στο λεξικό.

Για κάθε επανάληψη του βρόχου, τόσο στο `key` όσο και στη `value` ανατίθεται το
επόμενο ζεύγος κλειδιού-τιμής του λεξικό (με τη σειρά κατακερματισμού).

Η έξοδος αυτού του βρόχου είναι:

~~~~{text}
10 a
22 c
1 b
~~~~

Και πάλι, είναι σε σειρά κατακερματισμού κλειδιών (δηλαδή, χωρίς συγκεκριμένη
σειρά).

Εάν συνδυάσουμε αυτές τις δύο τεχνικές, μπορούμε να εκτυπώσουμε τα περιεχόμενα
ενός λεξικού ταξινομημένα με βάση την *τιμή* που είναι αποθηκευμένη σε κάθε
ζεύγος κλειδιού-τιμής.

Για να γίνει αυτό, φτιάχνουμε πρώτα μια λίστα με πλειάδες, όπου κάθε πλειάδα
είναι `(value, key)`. Η μέθοδος `items` θα μας έδινε μια λίστα με πλειάδες
`(key, value)`, αλλά αυτή τη φορά θέλουμε να ταξινομήσουμε κατά τιμή και όχι
κατά κλειδί. Αφού δημιουργήσουμε τη λίστα με τις πλειάδες της τιμής - κλειδιού,
είναι απλό να ταξινομήσουμε τη λίστα με αντίστροφη σειρά και να εκτυπώσουμε τη
νέα, ταξινομημένη λίστα.

~~~~ {.python}
>>> d = {'a':10, 'b':1, 'c':22}
>>> l = list()
>>> for key, val in d.items() :
...     l.append( (val, key) )
...
>>> l
[(10, 'a'), (22, 'c'), (1, 'b')]
>>> l.sort(reverse=True)
>>> l
[(22, 'c'), (10, 'a'), (1, 'b')]
>>>
~~~~

Κατασκευάζοντας προσεκτικά τη λίστα των πλειάδων ώστε να έχει την τιμή ως το
πρώτο στοιχείο κάθε πλειάδας, μπορούμε να ταξινομήσουμε τη λίστα των πλειάδων
και να πάρουμε τα περιεχόμενα του λεξικού μας ταξινομημένα κατά τιμή.

Οι πιο συνηθισμένες λέξεις

The most common words
---------------------

\index{Romeo and Juliet}
\index{Ρωμαίος και Ιουλιέτα}

Επιστρέφοντας στο προηγούμενο παράδειγμα του κειμένου από το *Ρωμαίος και
Ιουλιέτα* Πράξη 2, Σκηνή 2, μπορούμε να επεκτείνουμε το πρόγραμμά μας για να
χρησιμοποιήσουμε αυτήν την τεχνική για να εκτυπώσουμε τις δέκα πιο συνηθισμένες
λέξεις στο κείμενο ως εξής:

\VerbatimInput{../code3/count3.py}
\begin{trinketfiles}
../code3/romeo-full.txt
\end{trinketfiles}

Το πρώτο μέρος του προγράμματος που διαβάζει το αρχείο και δημιουργεί το
λεξικό, που αντιστοιχίζει κάθε λέξη με το πλήθος εμφάνισης των λέξεων στο
έγγραφο, δεν έχει αλλάξει. Αλλά, αντί να εκτυπώνουμε απλώς το `πληθη` και να
τερματίζουμε το πρόγραμμα, κατασκευάζουμε μια λίστα με πλειάδες
`(τιμή, κλειδί)` και στη συνέχεια ταξινομούμε τη λίστα με αντίστροφη σειρά.

Από τη στιγμή που η τιμή είναι πρώτη, θα χρησιμοποιηθεί για τις συγκρίσεις.
Εάν υπάρχουν περισσότερες από μία πλειάδες με την ίδια τιμή, θα κοιτάξει το
δεύτερο στοιχείο (το κλειδί), επομένως οι πλειάδες των οποίων η τιμή είναι ίδια
θα ταξινομηθούν περαιτέρω σε αλφαβητική σειρά του κλειδιού.

Στο τέλος γράφουμε έναν ωραίο βρόχο `for` που κάνει μια επανάληψη πολλαπλής
εκχώρησης και εκτυπώνει τις δέκα πιο συνηθισμένες λέξεις, διατρέχοντας ένα
τμήμα της λίστας (`lst[:10]`).

Έτσι τώρα η έξοδος μοιάζει, τελικά, με αυτό που θέλαμε για την ανάλυση
συχνότητας λέξεων.

~~~~{text}
61 i
42 and
40 romeo
34 to
34 the
32 thou
32 juliet
30 that
29 my
24 thee
~~~~

Το γεγονός ότι αυτή η περίπλοκη ανάλυση δεδομένων μπορεί να γίνει με ένα εύκολο
στην κατανόηση πρόγραμμα Python, 19 γραμμών, είναι ένας λόγος για τον οποίο η
Python είναι μια καλή επιλογή ως γλώσσα για την εξερεύνηση πληροφοριών.

Χρήση πλειάδων ως κλειδιών στα λεξικά
-------------------------------------

\index{πλειάδα!ως κλειδί λεξικού}
\index{hashable}
\index{κατακερματιζόμενος}

Επειδή οι πλειάδες είναι *κατακερματίσιμες* και οι λίστες όχι, αν θέλουμε να
δημιουργήσουμε ένα *σύνθετο* κλειδί για χρήση σε ένα λεξικό, πρέπει να
χρησιμοποιήσουμε ως κλειδί μια πλειάδα.

Θα χρειαζόμασταν ένα σύνθετο κλειδί εάν θέλαμε να δημιουργήσουμε έναν
τηλεφωνικό κατάλογο, που αντιστοιχίζει ζεύγη επωνύμων, ονομάτων σε αριθμούς
τηλεφώνου. Υποθέτοντας ότι έχουμε ορίσει τις μεταβλητές `επώνυμο`, `όνομα` και
`αριθμός`, θα μπορούσαμε να γράψουμε μια εντολή εκχώρησης στο λεξικό ως εξής:

~~~~ {.python}
ευρετήριο[επώνυμο,όνομα] = αριθμός
~~~~

Η έκφραση μέσα στις αγκύλες είναι πλειάδα. Θα μπορούσαμε να χρησιμοποιήσουμε
την ανάθεση πλειάδας σε έναν βρόχο `for`, για να διασχίσουμε αυτό το λεξικό.

\index{πλειάδα!μέσα σε αγκύλες}

~~~~ {.python}
for επώνυμο, όνομα in ευρετήριο:
    print(όνομα, επώνυμο, ευρετήριο[επώνυμο,όνομα])
~~~~

Αυτός ο βρόχος διασχίζει τα κλειδιά στο `ευρετήριο`, τα οποία είναι πλειάδες.
Εκχωρεί τα στοιχεία κάθε πλειάδας στα `επώνυμο` και `όνομα` και στη συνέχεια
εκτυπώνει το όνομα και τον αντίστοιχο αριθμό τηλεφώνου.

Ακολουθίες: συμβολοσειρές, λίστες και πλειάδες (- Oh My!)
-------------------------------------------------------

\index{ακολουθία}

Έχω επικεντρωθεί σε λίστες πλειάδων, αλλά σχεδόν όλα τα παραδείγματα σε αυτό
το κεφάλαιο λειτουργούν επίσης με λίστες λιστών, πλειάδες πλειάδων και
πλειάδες λιστών. Για να αποφευχθεί η απαρίθμηση των πιθανών συνδυασμών, μερικές
φορές είναι πιο εύκολο να μιλάμε για ακολουθίες ακολουθιών.

Σε πολλά περιβάλλοντα, τα διαφορετικά είδη ακολουθιών (συμβολοσειρές, λίστες
και πλειάδες) μπορούν να χρησιμοποιηθούν εναλλακτικά. Λοιπόν, πώς και γιατί
επιλέγετε κάποιο αντί του άλλου ;

\index{συμβολοσειρά}
\index{λίστα}
\index{πλειάδα}
\index{μεταβλητότητα}
\index{αμεταβλητότητα}

Για να ξεκινήσουμε με το προφανές, οι συμβολοσειρές είναι πιο περιορισμένες από
τις άλλες ακολουθίες, επειδή τα στοιχεία πρέπει να είναι χαρακτήρες. Είναι
επίσης αμετάβλητες. Εάν χρειάζεστε τη δυνατότητα να αλλάξετε τους χαρακτήρες
μιας συμβολοσειράς (αντί για τη δημιουργία μιας νέας συμβολοσειράς), ίσως
θελήσετε να χρησιμοποιήσετε μια λίστα χαρακτήρων.

Οι λίστες είναι πιο συχνά σρησιμοποιούμενες από τις πλειάδες, κυρίως επειδή
είναι μεταβλητές. Αλλά υπάρχουν μερικές περιπτώσεις όπου μπορεί να προτιμήσετε
τις πλειάδες:

1. Σε ορισμένες περιπτώσεις, όπως μια δήλωση `return`, είναι συντακτικά πιο
    απλό να δημιουργήσετε μια πλειάδα παρά μια λίστα. Σε άλλες περιπτώσεις,
    μπορεί να προτιμήσετε μια λίστα.

2. Εάν θέλετε να χρησιμοποιήσετε μια ακολουθία ως κλειδί λεξικού, πρέπει να
    χρησιμοποιήσετε έναν αμετάβλητο τύπο όπως πλειάδα ή συμβολοσειρά.

3. Εάν μεταβιβάζετε μια ακολουθία ως όρισμα σε μια συνάρτηση, η χρήση πλειάδων
    μειώνει την πιθανότητα απροσδόκητης συμπεριφοράς λόγω ψευδωνυμίας.

Επειδή οι πλειάδες είναι αμετάβλητες, δεν παρέχουν μεθόδους όπως `sort` και
`reverse`, οι οποίες τροποποιούν τις υπάρχουσες λίστες. Ωστόσο, η Python
παρέχει τις ενσωματωμένες συναρτήσεις `sorted` και `reversed`, οι οποίες
λαμβάνουν οποιαδήποτε ακολουθία ως παράμετρο και επιστρέφουν μια νέα ακολουθία
με τα ίδια στοιχεία με διαφορετική σειρά.

\index{sorted συνάρτηση}
\index{συνάρτηση!sorted}
\index{reversed συνάρτηση}
\index{συνάρτηση!reversed}

List comprehension (Κατανόηση λίστας)
-------------------------------------

Μερικές φορές θέλετε να δημιουργήσετε μια ακολουθία χρησιμοποιώντας δεδομένα
από μια άλλη ακολουθία. Μπορείτε να το πετύχετε γράφοντας έναν βρόχο for και
προσαρτώντας ένα στοιχείο κάθε φορά. Για παράδειγμα, αν θέλατε να μετατρέψετε
μια λίστα συμβολοσειρών -- κάθε συμβολοσειρά αποθηκεύει ψηφία -- σε αριθμούς
που μπορείτε να αθροίσετε, θα γράφατε:

~~~~ {.python}
list_of_ints_in_strings = ['42', '65', '12']
list_of_ints = []
for x in list_of_ints_in_strings:
    list_of_ints.append(int(x))

print(sum(list_of_ints))
~~~~

Με την list comprehension, ο παραπάνω κώδικας μπορεί να γραφτεί με πιο συμπαγή
τρόπο:

~~~~ {.python}
list_of_ints_in_strings = ['42', '65', '12']
list_of_ints = [ int(x) for x in list_of_ints_in_strings ]
print(sum(list_of_ints))
~~~~

\index{list comprehension}

Εκσφαλμάτωση
------------

\index{εκσφαλμάτωση}
\index{δομή δεδομένων}
\index{shape σφάλμα}
\index{σφάλμα!σχήματος}
\index{σχήματος σφάλμα}

Οι λίστες, τα λεξικά και οι πλειάδες είναι γνωστά γενικά ως *δομές δεδομένων*.
Σε αυτό το κεφάλαιο αρχίζουμε να βλέπουμε σύνθετες δομές δεδομένων, όπως
λίστες πλειάδων και λεξικά που περιέχουν πλειάδες ως κλειδιά και λίστες ως
τιμές. Οι σύνθετες δομές δεδομένων είναι χρήσιμες, αλλά είναι επιρρεπείς σε
αυτό που αποκαλώ *σφάλματα σχήματος*. Δηλαδή, σφάλματα που προκαλούνται όταν
μια δομή δεδομένων έχει λάθος τύπο, μέγεθος ή σύνθεση ή ίσως γράψετε κάποιον
κώδικα και ξεχάσετε το σχήμα των δεδομένων σας και προκαλέσετε ένα σφάλμα. Για
παράδειγμα, αν περιμένετε μια λίστα με έναν ακέραιο και σας δώσω έναν απλό
ακέραιο (όχι σε λίστα), δεν θα λειτουργήσει.

Γλωσσάριο
---------

DSU
: Συντομογραφία του "decorate-sort-undecorate", ένα μοτίβο που περιλαμβάνει τη δημιουργία μιας λίστας πλειάδων, την ταξινόμηση 
και την εξαγωγή μέρους του αποτελέσματος.
\index{μοτίβο DSU}

gather
: Η λειτουργία της συναρμολόγησης μιας πλειάδας ορίσματος μεταβλητού μήκους.
\index{gather}

scatter
: Η λειτουργία της αντιμετώπισης μιας ακολουθίας ως λίστας ορισμάτων.
\index{scatter}

singleton - μεμονωμένο
: Μια λίστα (ή άλλη ακολουθία) με ένα μόνο στοιχείο.
\index{singleton}

δομή δεδομένων
: Μια συλλογή σχετικών τιμών, συχνά οργανωμένη σε λίστες, λεξικά, πλειάδες κ.λπ.
\index{δομή δεδομένων}

κατακερματιζόμενος - hashable
: Ένας τύπος που έχει συνάρτηση κατακερματισμού. Οι αμετάβλητοι τύποι όπως
    ακέραιοι, κινητής υποδιαστολής (float) και συμβολοσειρές μπορούν να
    κατακερματιστούν, μεταβλητοί τύποι όπως λίστες και λεξικά όχι.
\index{hashable}
\index{κατακερματιζόμενος}

πλειάδα
: Μια αμετάβλητη ακολουθία στοιχείων.
\index{πλειάδα}

πλειάδα σε ανάθεση
: Μια εκχώρηση με μια ακολουθία στο δεξί μέλος και μια πλειάδα μεταβλητών στο
    αριστερό. Το δεξί μέλος αξιολογείται και στη συνέχεια τα στοιχεία του
    αντιστοιχίζονται στις μεταβλητές στα αριστερά.
\index{πλειάδα σε ανάθεση}
\index{ανάθεση!πλειάδα}

συγκρίσιμος
: Ένας τύπος όπου μια τιμή μπορεί να ελεγχθεί για να διαπιστωθεί εάν είναι
    μεγαλύτερη από, μικρότερη από ή ίση με μια άλλη τιμή του ίδιου τύπου. Οι
    τύποι που είναι συγκρίσιμοι μπορούν να τοποθετηθούν σε μια λίστα και να
    ταξινομηθούν.
\index{συγκρίσιμος}

σχήμα (μιας δομής δεδομένων) - shape
: Σύνοψη του τύπου, του μεγέθους και της σύνθεσης μιας δομής δεδομένων.
\index{σχήμα}
\index{shape}

Ασκήσεις
--------

**Άσκηση 1: Αναθεωρήστε ένα προηγούμενο πρόγραμμα ως εξής: Διαβάστε και
αναλύστε τις γραμμές "From " και ανακτήστε τις διευθύνσεις από την κάθε γραμμή.
Μετρήστε τον αριθμό των μηνυμάτων από κάθε άτομο χρησιμοποιώντας ένα λεξικό.**

** Αφού διαβάσετε όλα τα δεδομένα, δημιουργήστε μια λίστα με πλειάδες
(πλήθος, email) από το λεξικό. Στη συνέχεια, ταξινομήστε τη λίστα με αντίστροφη
σειρά και εκτυπώστε το άτομο με τα περισσότερα μηνύματα.**

~~~~{text}
Δείγμα γραμμής:
From stephen.marquard@uct.ac.za Sat Jan  5 09:14:16 2008

Εισαγάγετε ένα όνομα αρχείου: mbox-short.txt
cwen@iupui.edu 5

Εισαγάγετε ένα όνομα αρχείου: mbox.txt
zqian@umich.edu 195
~~~~

**Άσκηση 2: Αυτό το πρόγραμμα μετράει την κατανομή της ώρας της ημέρας για κάθε
ένα από τα μηνύματα. Μπορείτε να τραβήξετε την ώρα από τη γραμμή "From ",
βρίσκοντας τη συμβολοσειρά χρόνου και, στη συνέχεια, χωρίζοντας τη συμβολοσειρά
σε μέρη, χρησιμοποιώντας τον χαρακτήρα άνω και κάτω τελείας. Αφού υπολογίσετε
τα πλήθη για κάθε ώρα, εκτυπώστε τα, ένα ανά γραμμή, ταξινομημένα ανά ώρα, όπως
φαίνεται παρακάτω.**

~~~~{text}
python timeofday.py
Εισαγάγετε ένα όνομα αρχείου: mbox-short.txt
04 3
06 1
07 1
09 2
10 3
11 6
14 1
15 2
16 4
17 2
18 1
19 1
~~~~

**Άσκηση 3: Γράψτε ένα πρόγραμμα που διαβάζει ένα αρχείο και τυπώνει τα
*γράμματα* με φθίνουσα σειρά συχνότητας. Το πρόγραμμά σας θα πρέπει να
μετατρέψει όλη την είσοδο σε πεζά και να μετράει μόνο τα γράμματα a-z. Το
πρόγραμμά σας δεν πρέπει να μετράει κενά, ψηφία, σημεία στίξης ή οτιδήποτε άλλο
εκτός από τα γράμματα a-z. Βρείτε δείγματα κειμένου από πολλές διαφορετικές
γλώσσες και δείτε πώς η συχνότητα των γραμμάτων ποικίλλει μεταξύ των γλωσσών.
Συγκρίνετε τα αποτελέσματά σας με τους πίνακες στο
<https://wikipedia.org/wiki/Letter_frequencies>.**

\index{γράμματα συχνότητα}
\index{συχνότητα!γράμματα}
