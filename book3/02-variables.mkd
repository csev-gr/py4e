Μεταβλητές, εκφράσεις και εντολές
======================================

Τιμές και τύποι
----------------

\index{τιμή}
\index{τύπος}
\index{string}
\index{συμβολοσειρές}

Μια *τιμή*, όπως ένα γράμμα ή ένας αριθμός, είναι ένα από τα βασικά στοιχεία με τα οποία λειτουργεί ένα πρόγραμμα.
Οι τιμές που έχουμε δει μέχρι τώρα είναι 1, 2 και "Γειά σου κόσμε!"

Αυτές οι τιμές ανήκουν σε διαφορετικούς *τύπους*: το 2 είναι ένας ακέραιος αριθμός και το "Γειά σου κόσμε!" είναι
μια *συμβολοσειρά*, που ονομάζεται επειδή περιέχει μια "σειρά" συμβόλων και γραμμάτων. Μπορείτε (εσείς αλλά και ο
διερμηνέας) να εντοπίσετε συμβολοσειρές επειδή περικλείονται σε εισαγωγικά.

\index{εισαγωγικά}

Η εντολή `print` λειτουργεί και για ακέραιους αριθμούς. Χρησιμοποιούμε την εντολή `python` για να ξεκινήσουμε τον διερμηνέα.

~~~~ {.python}
python
>>> print(4)
4
~~~~

Εάν δεν είστε σίγουροι τι τύπου είναι μια τιμή, ο διερμηνέας μπορεί να σας πει.

~~~~ {.python .trinket height="160"}
>>> type('Hello, World!')
<class 'str'>
>>> type(17)
<class 'int'>
~~~~

Δεν αποτελεί έκπληξη το γεγονός ότι οι συμβολοσειρές ανήκουν στον τύπο `str` και οι ακέραιοι στον τύπο` int`.
Λιγότερο προφανώς, οι αριθμοί με υποδιαστολή ανήκουν σε έναν τύπο που ονομάζεται `float`, επειδή αυτοί οι αριθμοί
αντιπροσωπεύονται από μια μορφή που ονομάζεται *floating point*.

\index{τύπος}
\index{τύπος srt}
\index{class!str}
\index{τύπος int}
\index{class!int}
\index{τύπος float}
\index{class!float}

~~~~ {.python .trinket height="120"}
>>> type(3.2)
<class 'float'>
~~~~

Τι γίνεται με τις τιμές όπως το "17" και το "3.2"; Μοιάζουν με αριθμούς, αλλά περικλείονται με εισαγωγικά σαν συμβολοσειρές.

\index{εισαγωγικά}

~~~~ {.python .trinket  height="160"}
>>> type('17')
<class 'str'>
>>> type('3.2')
<class 'str'>
~~~~

Είναι συμβολοσειρές.

Όταν πληκτρολογείτε έναν μεγάλο ακέραιο, μπορεί να μπείτε στον πειρασμό να χρησιμοποιήσετε διαχωριστικά χιλιάδων, όπως
στο 1.000.000. Αυτός δεν είναι ένας έγκυρος ακέραιος αριθμός στην Python, αποδεκτό είναι το:

~~~~ {.python .trinket height="120"}
>>> print(1,000,000)
1 0 0
~~~~

Ε, αυτό δεν το περιμέναμε καθόλου! Η Python ερμηνεύει το 1,000,000 ως μια ακολουθία ακέραιων διαχωρισμένων με κόμμα,
την οποία εκτυπώνει με κενά μεταξύ τους.

\index{σημασιολογικό σφάλμα}
\index{σφάλμα σημασιολογικό}
\index{μήνυμα λάθους}

Αυτό είναι το πρώτο παράδειγμα που έχουμε δει για ένα σημασιολογικό σφάλμα: ο κώδικας τρέχει χωρίς να παράγει μήνυμα
σφάλματος, αλλά δεν κάνει το "σωστό".

Μεταβλητές
---------

\index{μεταβλητή}
\index{εντολή εκχώρησης}
\index{εκχώρηση εντολή}

Ένα από τα πιο ισχυρά χαρακτηριστικά μιας γλώσσας προγραμματισμού είναι η δυνατότητα χειρισμού *μεταβλητών*.
Μια μεταβλητή είναι ένα όνομα που αναφέρεται σε μια τιμή.

Μια * εντολή εκχώρησης* δημιουργεί νέες μεταβλητές και τους δίνει τιμές:

~~~~ {.python}
>>> message = 'Και τώρα κάτι εντελώς διαφορετικό'
>>> n = 17
>>> pi = 3.1415926535897931
~~~~

Αυτό το παράδειγμα υλοποιεί τρεις αναθέσεις. Η πρώτη αναθέτει μια συμβολοσειρά σε μια νέα μεταβλητή με το όνομα
`message`, η δεύτερη αναθέτει τον ακέραιο 17 στο `n` και η τρίτη αναθέτει την τιμή (κατά προσέγγιση) του *π* στο `pi`.

Για να εμφανίσετε την τιμή μιας μεταβλητής, μπορείτε να χρησιμοποιήσετε μια εντολή print:

~~~~ {.python}
>>> print(n)
17
>>> print(pi)
3.141592653589793
~~~~

Ο τύπος μιας μεταβλητής είναι ο τύπος της τιμής στην οποία αναφέρεται.

~~~~ {.python}
>>> type(message)
<class 'str'>
>>> type(n)
<class 'int'>
>>> type(pi)
<class 'float'>
~~~~

Ονόματα μεταβλητών και δεσμευμένες λέξεις
-----------------------------------------

\index{δεσμευμένες λέξεις}

Οι προγραμματιστές επιλέγουν, γενικά, ονόματα για τις μεταβλητές τους που έχουν νόημα και δηλώνουν τον λόγο για τον
οποίο χρησιμοποιείται η μεταβλητή.

Τα ονόματα των μεταβλητών μπορεί να είναι αυθαίρετα μεγάλα. Μπορούν να περιέχουν γράμματα και αριθμούς, αλλά δεν μπορούν
να ξεκινήσουν με αριθμό. Είναι αποδεκτό να χρησιμοποιείτε κεφαλαία γράμματα, αλλά είναι καλή ιδέα να αρχίζετε τα ονόματα
μεταβλητών με πεζό γράμμα (θα δείτε το γιατί αργότερα).

Σε ένα όνομα μπορεί να χρησιμοποιηθεί και ο χαρακτήρας υπογράμμισης (\_) ή κάτω παύλα. Συχνά χρησιμοποιείται σε ονόματα
με πολλές λέξεις, όπως `my_name` ή `airspeed_of_unladen_swallow`. Τα ονόματα μεταβλητών μπορούν να ξεκινούν με χαρακτήρα
υπογράμμισης, αλλά γενικά αποφεύγουμε να το κάνουμε αυτό, εκτός εάν γράφουμε κώδικα βιβλιοθήκης για χρήση από άλλους.

\index{κάτω παύλα}
\index{χαρακτήρας υπογράμμισης}

Εάν δώσετε σε μια μεταβλητή ένα μη αποδεκτό όνομα, προκύπτει σφάλμα σύνταξης:

~~~~ {.python .trinket height="450"}
>>> 76trombones = 'big parade'
SyntaxError: invalid syntax
>>> more@ = 1000000
SyntaxError: invalid syntax
>>> class = 'Advanced Theoretical Zymurgy'
SyntaxError: invalid syntax
~~~~

Το `76trombones` είναι μη αποδεκτό επειδή αρχίζει με αριθμό. Το `more@` είναι μη αποδεκτό επειδή περιέχει έναν μη αποδεκτό
χαρακτήρα, @. Αλλά ποιο το πρόβλημα με το `class`;

Αποδεικνύεται ότι το `class` είναι μία από τις *δεσμευμένες λέξεις* της Python. Ο διερμηνέας χρησιμοποιεί δεσμευμένες
λέξεις για να αναγνωρίσει τη δομή του προγράμματος και δεν μπορούν να χρησιμοποιηθούν ως ονόματα μεταβλητών.

\index{δεσμευμένες λέξεις}

Η Python διαθέτει 35 δεσμευμένες λέξεις:

~~~~
and       del       from      None      True
as        elif      global    nonlocal  try
assert    else      if        not       while
break     except    import    or        with
class     False     in        pass      yield
continue  finally   is        raise     async
def       for       lambda    return    await
~~~~

Ίσως θα ήταν χρήσιμο να κρατήσετε αυτήν τη λίστα εύκαιρη. Εάν ο διερμηνέας παραπονιέται για ένα από τα ονόματα μεταβλητών
σας και δεν ξέρετε γιατί, ελέγξτε αν βρίσκεται σε αυτήν τη λίστα.

Εντολές
----------

Μια *εντολή* είναι μια μονάδα κώδικα που μπορεί να εκτελέσει ο διερμηνέας της Python. Έχουμε συναντήσει δύο είδη εντωλών:
την εντολή print και την ανάθεση τιμής.

\index{εντολή}
\index{διαδραστική λειτουργία}
\index{λειτουργία σεναρίου}

Όταν πληκτρολογείτε μια δήλωση σε διαδραστική λειτουργία, ο διερμηνέας την εκτελεί και εμφανίζει το αποτέλεσμα, εάν προκύπτει
κάποιο.

Ένα σενάριο/script περιέχει συνήθως μια ακολουθία εντολών. Εάν υπάρχουν περισσότερες από μία εντολές, τα αποτελέσματα εμφανίζονται 
ένα κάθε φορά, καθώς εκτελούνται οι εντολές.

Για παράδειγμα, το script

~~~~ {.python}
print(1)
x = 2
print(x)
~~~~

παράγει την έξοδο

~~~~
1
2
~~~~

Η εντολή εκχώρησης δεν παράγει έξοδο.

Τελεστές και τελεστέοι
----------------------

\index{τελεστής, αριθμητικός}
\index{αριθμητικός τελεστής}
\index{τελεστέος}
\index{έκφραση}

Οι *τελεστές* είναι ειδικά σύμβολα που αναπαριστούν υπολογισμούς, όπως της πρόσθεσης και του πολλαπλασιασμού. Οι τιμές
στις οποίες εφαρμόζεται ο τελεστής καλούνται *τελεστέοι*.

Οι τελεστές `+`, `-`, `*`, `/` και `**` εκτελούν πρόσθεση, αφαίρεση, πολλαπλασιασμό, διαίρεση και ύψωση σε δύναμη, όπως
στα παρακάτω παραδείγματα:

~~~~ {.python}
20+32
hour-1
hour*60+minute
minute/60
5**2
(5+9)*(15-7)
~~~~

Υπήρξε μια αλλαγή στον τελεστή της διαίρεσης, μεταξύ Python 2.x και Python 3.x. Στην Python 3.x, το αποτέλεσμα αυτής της
διαίρεσης είναι float:

~~~~ {.python .trinket height="160"}
>>> minute = 59
>>> minute/60
0.9833333333333333
~~~~

Ο τελεστής διαίρεσης στην Python 2.0, όταν διαιρεί δύο ακέραιους αριθμούς περικόπτει το αποτέλεσμα σε ακέραιο:

~~~~ {.python}
>>> minute = 59
>>> minute/60
0
~~~~

Για να λάβετε την ίδια απάντηση στην Python 3.0, χρησιμοποιήστε τη ευκλείδεια διαίρεση (`//` integer).

~~~~ {.python .trinket  height="160"}
>>> minute = 59
>>> minute//60
0
~~~~

Στην Python 3.0, η ακέραιη διαίρεση λειτουργεί πολύ καλύτερα από ό,τι θα περιμένατε εάν εισαγάγατε την έκφραση
σε μια αριθμομηχανή.

\index{Python 3.0}
\index{Python 2.0}
\index{floating-point division}
\index{division!floating-point}
\index{κινητή υποδιαστολή, διαίρεση}
\index{διαίρεση!κινητής υποδιαστολής}

Εκφράσεις
-----------

Μια *έκφραση* είναι ένας συνδυασμός τιμών, μεταβλητών και τελεστών. Μια τιμή, από μόνη της, θεωρείται ως μία
έκφραση και το ίδιο και μια μεταβλητή. Έτσι, τα παρακάτω είναι αποδεκτές μορφές εκφράσεων (υποθέτοντας ότι
στη μεταβλητή `x` έχει εκχωρηθεί μία τιμή):

\index{έκφραση}
\index{υπολογισμός}

~~~~ {.python}
17
x
x + 17
~~~~

Εάν πληκτρολογήσετε μια έκφραση σε διαδραστική λειτουργία, ο διερμηνέας την *υπολογίζει* και εμφανίζει το αποτέλεσμα:

~~~~ {.python}
>>> 1 + 1
2
~~~~

But in a script, an expression all by itself doesn't do anything! This
is a common source of confusion for beginners.


**Exercise 1: Type the following statements in the Python interpreter to
see what they do:**

~~~~ {.python}
5
x = 5
x + 1
~~~~

Order of operations
-------------------

\index{order of operations}
\index{rules of precedence}
\index{PEMDAS}

When more than one operator appears in an expression, the order of
evaluation depends on the *rules of precedence*. For
mathematical operators, Python follows mathematical convention. The
acronym *PEMDAS* is a useful way to remember the rules:

\index{parentheses!overriding precedence}

-   *P*arentheses have the highest precedence and can be
    used to force an expression to evaluate in the order you want. Since
    expressions in parentheses are evaluated first, `2 *
    (3-1)` is 4, and `(1+1)**(5-2)` is 8. You can
    also use parentheses to make an expression easier to read, as in
    `(minute * 100) / 60`, even if it doesn't change the
    result.

-   *E*xponentiation has the next highest precedence, so
    `2**1+1` is 3, not 4, and `3*1**3` is 3,
    not 27.

-   *M*ultiplication and *D*ivision have
    the same precedence, which is higher than *A*ddition
    and *S*ubtraction, which also have the same
    precedence. So `2*3-1` is 5, not 4, and
    `6+4/2` is 8, not 5.

-   Operators with the same precedence are evaluated from left to right.
    So the expression `5-3-1` is 1, not 3, because the
    `5-3` happens first and then `1` is subtracted
    from 2.

When in doubt, always put parentheses in your expressions to make sure
the computations are performed in the order you intend.

Modulus operator
----------------

\index{modulus operator}
\index{operator!modulus}

The *modulus operator* works on integers and yields the
remainder when the first operand is divided by the second. In Python,
the modulus operator is a percent sign (`%`). The syntax is the same as
for other operators:

~~~~ {.python .trinket height="240"}
>>> quotient = 7 // 3
>>> print(quotient)
2
>>> remainder = 7 % 3
>>> print(remainder)
1
~~~~

So 7 divided by 3 is 2 with 1 left over.

The modulus operator turns out to be surprisingly useful. For example,
you can check whether one number is divisible by another: if `x %
y` is zero, then `x` is divisible by `y`.

\index{divisibility}

You can also extract the right-most digit or digits from a number. For
example, `x % 10` yields the right-most digit of
`x` (in base 10). Similarly, `x % 100` yields the
last two digits.

String operations
-----------------

\index{string!operation}
\index{operator!string}

The `+` operator works with strings, but it is not addition
in the mathematical sense. Instead it performs
*concatenation*, which means joining the strings by
linking them end to end. For example:

\index{concatenation}

~~~~ {.python}
>>> first = 10
>>> second = 15
>>> print(first+second)
25
>>> first = '100'
>>> second = '150'
>>> print(first + second)
100150
~~~~

The `*` operator also works with strings by multiplying the content
of a string by an integer. For example:

~~~~ {.python}
>>> first = 'Test '
>>> second = 3
>>> print(first * second)
Test Test Test
~~~~

Asking the user for input
-------------------------

\index{keyboard input}

Sometimes we would like to take the value for a variable from the user
via their keyboard. Python provides a built-in function called
`input` that gets input from the keyboard^[In Python 2.0, this function was named `raw_input`.]. 
When this function is
called, the program stops and waits for the user to type something. When
the user presses `Return` or `Enter`, the program
resumes and `input` returns what the user typed as a string.

\index{Python 2.0}

~~~~ {.python}
>>> inp = input()
Some silly stuff
>>> print(inp)
Some silly stuff
~~~~

Before getting input from the user, it is a good idea to print a prompt
telling the user what to input. You can pass a string to `input` to
be displayed to the user before pausing for input:

\index{prompt}

~~~~ {.python}
>>> name = input('What is your name?\n')
What is your name?
Chuck
>>> print(name)
Chuck
~~~~

The sequence `\n` at the end of the prompt represents a
*newline*, which is a special character that causes a
line break. That's why the user's input appears below the prompt.

\index{newline}

If you expect the user to type an integer, you can try to convert the
return value to `int` using the `int()` function:

~~~~ {.python}
>>> prompt = 'What...is the airspeed velocity of an unladen swallow?\n'
>>> speed = input(prompt)
What...is the airspeed velocity of an unladen swallow?
17
>>> int(speed)
17
>>> int(speed) + 5
22
~~~~

But if the user types something other than a string of digits, you get
an error:

~~~~ {.python}
>>> speed = input(prompt)
What...is the airspeed velocity of an unladen swallow?
What do you mean, an African or a European swallow?
>>> int(speed)
ValueError: invalid literal for int() with base 10:
~~~~

We will see how to handle this kind of error later.

\index{ValueError}
\index{exception!ValueError}

Comments
--------

\index{comment}

As programs get bigger and more complicated, they get more difficult to
read. Formal languages are dense, and it is often difficult to look at a
piece of code and figure out what it is doing, or why.

For this reason, it is a good idea to add notes to your programs to
explain in natural language what the program is doing. These notes are
called *comments*, and in Python they start with the `#`
symbol:

~~~~ {.python}
# compute the percentage of the hour that has elapsed
percentage = (minute * 100) / 60
~~~~

In this case, the comment appears on a line by itself. You can also put
comments at the end of a line:

~~~~ {.python}
percentage = (minute * 100) / 60     # percentage of an hour
~~~~

Everything from the `#` to the end of the line is ignored; it
has no effect on the program.

Comments are most useful when they document non-obvious features of the
code. It is reasonable to assume that the reader can figure out *what*
the code does; it is much more useful to explain *why*.

This comment is redundant with the code and useless:

~~~~ {.python}
v = 5     # assign 5 to v
~~~~

This comment contains useful information that is not in the code:

~~~~ {.python}
v = 5     # velocity in meters/second.
~~~~

Good variable names can reduce the need for comments, but long names can
make complex expressions hard to read, so there is a trade-off.

Choosing mnemonic variable names
--------------------------------

\index{mnemonic}

As long as you follow the simple rules of variable naming, and avoid
reserved words, you have a lot of choice when you name your variables.
In the beginning, this choice can be confusing both when you read a
program and when you write your own programs. For example, the following
three programs are identical in terms of what they accomplish, but very
different when you read them and try to understand them.

~~~~ {.python}
a = 35.0
b = 12.50
c = a * b
print(c)
~~~~

~~~~ {.python}
hours = 35.0
rate = 12.50
pay = hours * rate
print(pay)
~~~~

~~~~ {.python}
x1q3z9ahd = 35.0
x1q3z9afd = 12.50
x1q3p9afd = x1q3z9ahd * x1q3z9afd
print(x1q3p9afd)
~~~~

The Python interpreter sees all three of these programs as *exactly the
same* but humans see and understand these programs quite differently.
Humans will most quickly understand the *intent* of the
second program because the programmer has chosen variable names that
reflect their intent regarding what data will be stored in each
variable.

We call these wisely chosen variable names "mnemonic variable names".
The word *mnemonic*^[See <https://en.wikipedia.org/wiki/Mnemonic> for an extended
description of the word "mnemonic".] means "memory aid". We choose mnemonic variable
names to help us remember why we created the variable in the first
place.

While this all sounds great, and it is a very good idea to use mnemonic
variable names, mnemonic variable names can get in the way of a
beginning programmer's ability to parse and understand code. This is
because beginning programmers have not yet memorized the reserved words
(there are only 33 of them) and sometimes variables with names that are
too descriptive start to look like part of the language and not just
well-chosen variable names.

Take a quick look at the following Python sample code which loops
through some data. We will cover loops soon, but for now try to just
puzzle through what this means:

~~~~ {.python}
for word in words:
    print(word)
~~~~

What is happening here? Which of the tokens (for, word, in, etc.) are
reserved words and which are just variable names? Does Python understand
at a fundamental level the notion of words? Beginning programmers have
trouble separating what parts of the code *must* be the same as this
example and what parts of the code are simply choices made by the
programmer.

The following code is equivalent to the above code:

~~~~ {.python}
for slice in pizza:
    print(slice)
~~~~

It is easier for the beginning programmer to look at this code and know
which parts are reserved words defined by Python and which parts are
simply variable names chosen by the programmer. It is pretty clear that
Python has no fundamental understanding of pizza and slices and the fact
that a pizza consists of a set of one or more slices.

But if our program is truly about reading data and looking for words in
the data, `pizza` and `slice` are very un-mnemonic
variable names. Choosing them as variable names distracts from the
meaning of the program.

After a pretty short period of time, you will know the most common
reserved words and you will start to see the reserved words jumping out
at you:

<pre>
<b>for</b> word <b>in</b> words<b>:</b>
    <b>print</b>(word)
</pre>

The parts of the code that are defined by Python (`for`,
`in`, `print`, and `:`) are in bold and
the programmer-chosen variables (`word` and
`words`) are not in bold. Many text editors are aware of
Python syntax and will color reserved words differently to give you
clues to keep your variables and reserved words separate. After a while
you will begin to read Python and quickly determine what is a variable
and what is a reserved word.

Debugging
---------

\index{debugging}

At this point, the syntax error you are most likely to make is an
illegal variable name, like `class` and `yield`,
which are keywords, or `odd~job` and `US$`, which contain illegal
characters.

\index{syntax error}
\index{error!syntax}

If you put a space in a variable name, Python thinks it is two operands
without an operator:

~~~~ {.python}
>>> bad name = 5
SyntaxError: invalid syntax
~~~~

~~~~ {.python}
>>> month = 09
  File "<stdin>", line 1
    month = 09
             ^
SyntaxError: invalid token
~~~~

For syntax errors, the error messages don't help much. The most common
messages are `SyntaxError: invalid syntax` and
`SyntaxError: invalid token`, neither of which is very
informative.

\index{error message}
\index{use before def}
\index{exception}
\index{runtime error}
\index{error!runtime}

The runtime error you are most likely to make is a "use before def;"
that is, trying to use a variable before you have assigned a value. This
can happen if you spell a variable name wrong:

~~~~ {.python}
>>> principal = 327.68
>>> interest = principle * rate
NameError: name 'principle' is not defined
~~~~

Variables names are case sensitive, so `LaTeX` is not the
same as `latex`.

\index{case-sensitivity, variable names}
\index{semantic error}
\index{error!semantic}

At this point, the most likely cause of a semantic error is the order of
operations. For example, to evaluate $1/2\pi$, you might be
tempted to write

~~~~ {.python}
>>> 1.0 / 2.0 * pi
~~~~

But the division happens first, so you would get $\pi / 2$, which is not
the same thing! There is no way for Python to know what you meant to
write, so in this case you don't get an error message; you just get the
wrong answer.

\index{order of operations}

Glossary
--------

assignment
:   A statement that assigns a value to a variable.
\index{assignment}

concatenate
:   To join two operands end to end.
\index{concatenation}

comment
:   Information in a program that is meant for other programmers (or
    anyone reading the source code) and has no effect on the execution
    of the program.
\index{comment}

evaluate
:   To simplify an expression by performing the operations in order to
    yield a single value.

expression
:   A combination of variables, operators, and values that represents a
    single result value.
\index{expression}

floating point
:   A type that represents numbers with fractional parts.
\index{floating-point}

integer
:   A type that represents whole numbers.
\index{integer}

keyword
:   A reserved word that is used by the compiler to parse a program; you
    cannot use keywords like `if`, `def`, and
    `while` as variable names.
\index{keyword}

mnemonic
:   A memory aid. We often give variables mnemonic names to help us
    remember what is stored in the variable.
\index{mnemonic}

modulus operator
:   An operator, denoted with a percent sign (`%`), that
    works on integers and yields the remainder when one number is
    divided by another.
\index{modulus operator}
\index{operator!modulus}

operand
:   One of the values on which an operator operates.
\index{operand}

operator
:   A special symbol that represents a simple computation like addition,
    multiplication, or string concatenation.
\index{operator}

rules of precedence
:   The set of rules governing the order in which expressions involving
    multiple operators and operands are evaluated.
\index{rules of precedence}
\index{precedence}

statement
:   A section of code that represents a command or action. So far, the
    statements we have seen are assignments and print expression statement.
\index{statement}

string
:   A type that represents sequences of characters.
\index{string}

type
:   A category of values. The types we have seen so far are integers
    (type `int`), floating-point numbers (type
    `float`), and strings (type `str`).
\index{type}

value
:   One of the basic units of data, like a number or string, that a
    program manipulates.
\index{value}

variable
:   A name that refers to a value.
\index{variable}

Exercises
---------

**Exercise 2: Write a program that uses `input` to prompt a user for
their name and then welcomes them.**

~~~~
Enter your name: Chuck
Hello Chuck
~~~~

**Exercise 3: Write a program to prompt the user for hours and rate per
hour to compute gross pay.**

~~~~
Enter Hours: 35
Enter Rate: 2.75
Pay: 96.25
~~~~

We won't worry about making sure our pay has exactly two digits after
the decimal place for now. If you want, you can play with the built-in
Python `round` function to properly round the resulting pay
to two decimal places.

**Exercise 4: Assume that we execute the following assignment statements:**

~~~~
width = 17
height = 12.0
~~~~

For each of the following expressions, write the value of the expression
and the type (of the value of the expression).

1.  `width//2`

2.  `width/2.0`

3.  `height/3`

4.  `1 + 2 * 5`

Use the Python interpreter to check your answers.

**Exercise 5: Write a program which prompts the user for a Celsius
temperature, convert the temperature to Fahrenheit, and print out the
converted temperature.**

