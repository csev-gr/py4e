Συμβολοσειρές
=============

Μία συμβολοσειρά είναι μία ακολουθία
------------------------------------

\index{ακολουθία}
\index{χαρακτήρας}
\index{αγκύλη τελεστής}
\index{τελεστής!αγκύλη}

Μια συμβολοσειρά είναι μια *ακολουθία* χαρακτήρων. Μπορείτε να προσπελάσετε
τους χαρακτήρες, έναν κάθε φορά, με τον τελεστή αγκύλης:

~~~~ {.python}
>>> φρούτο = 'banana'
>>> γράμμα = φρούτο[1]
~~~~

\index{δείκτης}
\index{index}

Η δεύτερη πρόταση εξάγει τον χαρακτήρα στη θέση 1 από τη μεταβλητή `φρούτο`
και τον εκχωρεί στη μεταβλητή `γράμμα`.

Η έκφραση σε αγκύλες ονομάζεται *δείκτης (index)*. Ο δείκτης υποδεικνύει ποιον
χαρακτήρα της ακολουθίας θέλετε (εξ ου και το όνομα).

Αλλά μπορεί να μην πάρετε αυτό που περιμένετε:

~~~~ {.python}
>>> print(γράμμα)
a
~~~~

Για τους περισσότερους ανθρώπους, το πρώτο γράμμα του "banana" είναι «b», όχι
«a». Αλλά στην Python, ο δείκτης λειτουργεί κάπως διαφορετικά. Για την αρχή της
συμβολοσειράς, για το πρώτο γράμμα είναι μηδέν.

~~~~ {.python}
>>> γράμμα = φρούτο[0]
>>> print(γράμμα)
b
~~~~

Έτσι το "b" είναι το 0ό γράμμα ("μηδεκικ-ό") του "banana", το "a" είναι το 1ο
γράμμα ("πρώτ-ο"), και το "n" είναι το 2ο ("δεύτερ-ο") γράμμα.

![String Indexes](height=0.75in@../images/string)

\index{δείκτης!έναρξη από μηδέν}
\index{μηδέν, έναρξη δεικτών}

Μπορείτε να χρησιμοποιήσετε οποιαδήποτε έκφραση, συμπεριλαμβανομένων μεταβλητών
και τελεστών, σαν ένα δείκτη, αλλά η τιμή του δείκτη πρέπει να είναι ακέραιος
αριθμός. Αλλιώς θα πάρετε:

\index{δείκτης}
\index{index}
\index{exception!TypeError}
\index{TypeError}

~~~~ {.python}
>>> γράμμα = φρούτο[1.5]
TypeError: string indices must be integers
~~~~

Λήψη του μήκους μιας συμβολοσειράς χρησιμοποιώντας το `len`.
------------------------------------------------------------

\index{len συνάρτηση}
\index{συνάρτηση!len}

Η `len` είναι μια ενσωματωμένη συνάρτηση που επιστρέφει τον αριθμό των
χαρακτήρων σε μια συμβολοσειρά:

~~~~ {.python}
>>> φρούτο = 'banana'
>>> len(φρούτο)
6
~~~~

Για να εξάγετε το τελευταίο γράμμα μιας συμβολοσειράς, μπορεί να μπείτε στον
πειρασμό να δοκιμάσετε κάτι σαν αυτό:

\index{exception!IndexError}
\index{IndexError}

~~~~ {.python}
>>> μήκος = len(φρούτο)
>>> τελευταίο = φρούτο[μήκος]
IndexError: string index out of range
~~~~

Ο λόγος για το `IndexError` είναι ότι δεν υπάρχει γράμμα στο "banana" με δείκτη
6. Εφόσον αρχίσαμε να μετράμε από το μηδέν, τα έξι γράμματα αριθμούνται από το
0 έως το 5. Για να πάρετε τον τελευταίο χαρακτήρα, πρέπει να αφαιρέσετε
1 από `μήκος`:

~~~~ {.python}
>>> τελευταίο = φρούτο[μήκος-1]
>>> print(τελευταίο)
a
~~~~

Εναλλακτικά, μπορείτε να χρησιμοποιήσετε αρνητικούς δείκτες, οι οποίοι μετρούν
αντίστροφα από το τέλος της συμβολοσειράς. Η έκφραση `φρούτο[-1]` δίνει το
τελευταίο γράμμα, το `φρούτο[-2]` δίνει το δεύτερο από το τέλος και ούτω
καθεξής.

\index{δείκτης!αρνητικός}
\index{αρνητικός δείκτης}

Διάσχιση συμβολοσειράς με βρόχο
-------------------------------

\index{διάσχιση}
\index{βρόχος!διάσχιση}
\index{for βρόχος}
\index{βρόχος!for}
\index{εντολή!for}
\index{traversal}

Πολλοί υπολογισμοί εμπλέκουν την επεξεργασία μιας συμβολοσειράς, έναν χαρακτήρα
τη φορά. Συχνά ξεκινούν από την αρχή, επιλέγουν κάθε χαρακτήρα με τη σειρά,
κάνουν κάτι σε αυτόν και συνεχίζουν μέχρι το τέλος. Αυτό το μοτίβο επεξεργασίας
ονομάζεται *διάσχιση*. Ένας τρόπος για να γράψετε μια διάσχιση είναι με έναν
βρόχο `while`:

~~~~ {.python}
δείκτης = 0
while δείκτης < len(φρούτο):
    γράμμα = φρούτο[δείκτης]
    print(γράμμα)
    δείκτης = δείκτης + 1
~~~~

Αυτός ο βρόχος διασχίζει τη συμβολοσειρά και εμφανίζει κάθε γράμμα σε μια
γραμμή, από μόνο του. Η συνθήκη βρόχου είναι `δείκτης < len(φρούτο)`,
οπότε όταν ο `δείκτης` είναι ίσος με το μήκος της συμβολοσειράς, η συνθήκη
είναι ψευδής και το σώμα του βρόχου δεν εκτελείται. Ο τελευταίος χαρακτήρας
που προσπελαύνεται είναι αυτός με τον δείκτη `len(fruit)-1`, που είναι και ο
τελευταίος χαρακτήρας της συμβολοσειράς.

**Άσκηση 1: Γράψτε έναν βρόχο `while` που ξεκινά από τον τελευταίο χαρακτήρα
της συμβολοσειράς και πηγαίνει προς τα πίσω μέχρι τον πρώτο χαρακτήρα της
συμβολοσειράς, τυπώνοντας κάθε γράμμα σε ξεχωριστή γραμμή, απλά με ανάποδη
σειρά.**

Ένας άλλος τρόπος για να γράψετε μια διάσχιση είναι με έναν βρόχο `for`:

~~~~ {.python}
for char in fruit:
    print(char)
~~~~

Κάθε φορά που επαναλαμβάνεται ο βρόχος, ο επόμενος χαρακτήρας της συμβολοσειράς
εκχωρείται στη μεταβλητή `char`. Ο βρόχος συνεχίζεται μέχρι να προσπελάσουμε
όλους τους χαρακτήρες.

Διαμέριση συμβολοσειρών
-----------------------

\index{διαμέριση τελεστής}
\index{τελεστής!διαμέρισης}
\index{δείκτης!διαμέριση}
\index{συμβολοσειρά!διαμέριση}
\index{διαμέριση!συμβολοσειράς}
\index{συμβολοσειρά!τμήμα}
\index{τμήμα!συμβολοσειράς}

Ένα *τμήμα* μιας συμβολοσειράς ονομάζεται *slice*. Η επιλογή ενός τμήματος 
είναι παρόμοια με την επιλογή ενός χαρακτήρα:

~~~~ {.python}
>>> s = 'Monty Python'
>>> print(s[0:5])
Monty
>>> print(s[6:12])
Python
~~~~

Ο τελεστής `[n:m]` επιστρέφει το τμήμα της συμβολοσειράς από τον "n-ιοστό"
χαρακτήρα μέχρι τον "m-ιοστό" χαρακτήρα, συμπεριλαμβανομένου του πρώτου αλλά
εξαιρώντας τον τελευταίο.

Εάν παραλείψετε τον πρώτο δείκτη (πριν από την άνω και κάτω τελεία), το τμήμα
που λαμβάνετε ξεκινά από την αρχή της συμβολοσειράς. Εάν παραλείψετε τον
δεύτερο δείκτη, το τμήμα φτάνει μέχρι και το τέλος της συμβολοσειράς:

~~~~ {.python}
>>> φρούτο = 'banana'
>>> φρούτο[:3]
'ban'
>>> φρούτο[3:]
'ana'
~~~~

Εάν ο πρώτος δείκτης είναι μεγαλύτερος ή ίσος με τον δεύτερο, το αποτέλεσμα
είναι μια *κενή συμβολοσειρά*, που αντιπροσωπεύεται από δύο εισαγωγικά:

\index{εισαγωγικά}

~~~~ {.python}
>>> φρούτο = 'banana'
>>> φρούτο[3:3]
''
~~~~

Μια κενή συμβολοσειρά δεν περιέχει χαρακτήρες και έχει μήκος 0, αλλά εκτός από
αυτό, είναι ίδια με οποιαδήποτε άλλη συμβολοσειρά.

**Άσκηση 2: Δεδομένου ότι το `φρούτο` είναι μια συμβολοσειρά, τι σημαίνει `φρούτο[:]`;**

\index{αντίγραφο!τμήμα}
\index{τμήμα!αντίγραφο}

Οι συμβολοσειρές είναι αμετάβλητες
----------------------------------

\index{mutability}
\index{μεταβλητότητα}
\index{immutability}
\index{αμεταβλητότητα}
\index{συμβολοσειρά!αμετάβλητη}

Είναι δελεαστικό να χρησιμοποιήσετε τον τελεστή στην αριστερή πλευρά μιας
ανάθεσης, με την πρόθεση να αλλάξετε έναν χαρακτήρα σε μια συμβολοσειρά.
Για παράδειγμα:

\index{TypeError}
\index{exception!TypeError}

~~~~ {.python}
>>> greeting = 'Hello, world!'
>>> greeting[0] = 'J'
TypeError: 'str' object does not support item assignment
~~~~

Το "αντικείμενο - object" σε αυτήν την περίπτωση είναι η συμβολοσειρά και το
"στοιχείο - item" είναι ο χαρακτήρας που προσπαθήσατε να τροποποιήσετε. Προς
το παρόν, ένα *αντικείμενο* είναι το ίδιο πράγμα με μια τιμή, αλλά θα
βελτιώσουμε αυτόν τον ορισμό αργότερα. Ένα *στοιχείο* είναι μία από τις τιμές
σε μια ακολουθία.

\index{object}
\index{αντικείμενο}
\index{item εκχώρηση}
\index{εκχώρηση!item}
\index{στοιχείο εκχώρηση}
\index{εκχώρηση!στοιχείο}
\index{immutability}

Το σφάλμα αυτό προκλήθηκε γιατί οι συμβολοσειρές είναι *αμετάβλητες*, πράγμα
που σημαίνει ότι δεν μπορείτε να τροποποιήσετε μια υπάρχουσα συμβολοσειρά. Το
καλύτερο που μπορείτε να κάνετε είναι να δημιουργήσετε μια νέα συμβολοσειρά
που θα είναι μια παραλλαγή της αρχικής:

~~~ {.python}
>>> greeting = 'Hello, world!'
>>> new_greeting = 'J' + greeting[1:]
>>> print(new_greeting)
Jello, world!
~~~~

Αυτό το παράδειγμα συνενώνει ένα νέο πρώτο γράμμα σε ένα τμήμα του `greeting`.
Δεν έχει καμία επίδραση στην αρχική συμβολοσειρά.

\index{concatenation}
\index{συνένωση}

Βρόχος και μέτρηση
--------------------

\index{counter}
\index{μετρητής}
\index{Καταμέτρηση με βρόχο}
\index{βρόχος και μέτρηση}
\index{βρόχος!με συμβολοσειρές}

Το παρακάτω πρόγραμμα μετράει πόσες φορές εμφανίζεται το γράμμα "a" σε μια
συμβολοσειρά:

~~~~ {.python}
λέξη = 'banana'
πλήθος = 0
for γράμμα in λέξη:
    if γράμμα == 'a':
        πλήθος = πλήθος + 1
print(πλήθος)
~~~~

Αυτό το πρόγραμμα παρουσιάζει ένα άλλο μοτίβο υπολογισμού που ονομάζεται
*μετρητής*. Η μεταβλητή `πλήθος` αρχικοποιείται σε 0 και στη συνέχεια
αυξάνεται κάθε φορά που βρίσκεται ένα "a". Όταν ο βρόχος τερματίζει, το
`πλήθος` περιέχει το αποτέλεσμα: τον συνολικό αριθμό των α.

\index{ενθυλάκωση}

**Άσκηση 3: Ενθυλακώστε αυτόν τον κώδικα σε μια συνάρτηση με όνομα `count`
και γενικεύστε τον έτσι ώστε να δέχεται τη συμβολοσειρά και το γράμμα ως
ορίσματα.**

Ο τελεστής `in`
---------------

\index{in τελεστής}
\index{τελεστής!in}
\index{λογικός τελεστής}
\index{τελεστής!λογικός}

Η λέξη "in" είναι ένας λογικός τελεστής που δέχεται δύο συμβολοσειρές και
επιστρέφει `True` εάν η πρώτη είναι τμήμα της δεύτερης:

~~~~ {.python}
>>> 'a' in 'banana'
True
>>> 'seed' in 'banana'
False
~~~~

Σύγκριση συμβολοσειρών
----------------------

\index{συμβολοσειρά!σύγκριση}
\index{σύγκριση!συμβολοσειρά}

Οι τελεστές σύγκρισης λειτουργούν σε συμβολοσειρές. Για να δείτε αν δύο
συμβολοσειρές είναι ίσες:

~~~~ {.python}
if word == 'banana':
    print('All right, bananas.')
~~~~

Άλλοι τελεστές σύγκρισης που είναι χρήσιμοι για την τοποθέτηση λέξεων σε
αλφαβητική σειρά:

~~~~ {.python}
if word < 'banana':
    print('Η λέξη σου, ' + word + ', προηγείται της banana.')
elif word > 'banana':
    print('Η λέξη σου, ' + word + ', έπεται της banana.')
else:
    print('All right, bananas.')
~~~~

Η Python δεν χειρίζεται τα κεφαλαία και τα πεζά γράμματα με τον ίδιο τρόπο που
το κάνουν οι άνθρωποι. Όλα τα κεφαλαία γράμματα θεωρούνται μικρότερα από όλα τα
πεζά, οπότε:

~~~~{text}
Η λέξη σου, Pineapple, προηγείται της banana.
~~~~

Ένας συνηθισμένος τρόπος αντιμετώπισης αυτού του προβλήματος είναι η μετατροπή
των συμβολοσειρών σε τυπική μορφή, όπως όλα πεζά, πριν από την εκτέλεση της
σύγκρισης. Έχετέ το υπόψη σας, σε περίπτωση που χρειαστεί να υπερασπιστείτε τον
εαυτό σας ενάντια σε έναν άνδρα οπλισμένο με έναν ανανά (Pineapple)
(αμερικάνικη στρατιωτική αργκό όπου ο ανανάς σημαίνει χειροβομβίδα).

Μέθοδοι συμβολοσειρών
---------------------

Οι συμβολοσειρές (str) είναι ένα παράδειγμα *αντικειμένων* Python. Ένα
αντικείμενο περιέχει τόσο δεδομένα (την ίδια τη συμβολοσειρά) όσο και
*μεθόδους*, οι οποίες είναι ουσιαστικά συναρτήσεις που είναι ενσωματωμένες στο
αντικείμενο και είναι διαθέσιμες σε κάθε *στιγμιότυπο - instance* του
αντικειμένου.

Η Python έχει μια συνάρτηση που ονομάζεται `dir`, η οποία παραθέτει τις
διαθέσιμες μεθόδους για κάποιο αντικείμενο. Η συνάρτηση `type` δείχνει τον τύπο
ενός αντικειμένου και η συνάρτηση `dir` δείχνει τις διαθέσιμες μεθόδους.

~~~~ {.python}
>>> stuff = 'Hello world'
>>> type(stuff)
<class 'str'>
>>> dir(stuff)
['capitalize', 'casefold', 'center', 'count', 'encode',
'endswith', 'expandtabs', 'find', 'format', 'format_map',
'index', 'isalnum', 'isalpha', 'isdecimal', 'isdigit',
'isidentifier', 'islower', 'isnumeric', 'isprintable',
'isspace', 'istitle', 'isupper', 'join', 'ljust', 'lower',
'lstrip', 'maketrans', 'partition', 'replace', 'rfind',
'rindex', 'rjust', 'rpartition', 'rsplit', 'rstrip',
'split', 'splitlines', 'startswith', 'strip', 'swapcase',
'title', 'translate', 'upper', 'zfill']
>>> help(str.capitalize)
Help on method_descriptor:

capitalize(...)
    S.capitalize() -> str

    Return a capitalized version of S, i.e. make the first character
    have upper case and the rest lower case.
>>>
~~~~

Ενώ η συνάρτηση `dir` παραθέτει τις μεθόδους και μπορείτε να χρησιμοποιήσετε τη
`help` για να λάβετε κάποια απλή τεκμηρίωση σε μια μέθοδο, μια καλύτερη πηγή
τεκμηρίωσης για τις μεθόδους συμβολοσειράς θα ήταν
<https://docs.python.org/library/stdtypes.html#string-methods>.

Η κλήση μιας *μεθόδου* είναι παρόμοια με την κλήση μιας συνάρτησης (δέχεται
ορίσματα και επιστρέφει μια τιμή), αλλά η σύνταξη είναι διαφορετική. Καλούμε
μια μέθοδο προσθέτοντας το όνομα της μεθόδου στο τέλος του ονόματος της
μεταβλητής, χρησιμοποιώντας την τελεία ως οριοθέτη.

Για παράδειγμα, η μέθοδος `upper` δέχεται μια συμβολοσειρά και επιστρέφει μια
νέα συμβολοσειρά με όλα τα γράμματα κεφαλαία:

\index{μέθοδος}
\index{συμβολοσειρά!μέθοδος}

Αντί για τη σύνταξη των συναρτήσεων `upper(word)`, χρησιμοποιεί τη σύνταξη των
μεθόδων `word.upper()`.

\index{dot notation}
\index{διαχωρισμός με τελεία}

~~~~ {.python}
>>> word = 'banana'
>>> new_word = word.upper()
>>> print(new_word)
BANANA
~~~~

Αυτή η μορφή διαχωρισμού με τελεία καθορίζει το όνομα της μεθόδου, `upper` και
το όνομα της συμβολοσειράς `word`, για την εφαρμογή της μεθόδου. Οι κενές
παρενθέσεις υποδεικνύουν ότι αυτή η μέθοδος δεν δέχεται όρισμα.

\index{παρενθέσεις!κενές}

Μια κλήση μεθόδου ονομάζεται *επίκληση - invocation*. Σε αυτή την περίπτωση,
θα λέγαμε ότι επικαλούμαστε `upper` στη `word`.

\index{invocation}
\index{επίκληση}

Για παράδειγμα, υπάρχει μια μέθοδος συμβολοσειράς με το όνομα `find` που
αναζητά τη θέση μιας συμβολοσειράς μέσα σε μια άλλη:

~~~~ {.python}
>>> word = 'banana'
>>> index = word.find('a')
>>> print(index)
1
~~~~

Σε αυτό το παράδειγμα, επικαλούμαστε την `find` στη `word` και δίνουμε το
γράμμα που αναζητούμε ως παράμετρο.

Η μέθοδος `find` μπορεί να βρει υποσυμβολοσειρές καθώς και χαρακτήρες:

~~~~ {.python}
>>> word.find('na')
2
~~~~

Μπορεί να πάρει ως δεύτερο όρισμα τον δείκτη από όπου πρέπει να ξεκινήσει:

\index{προαιρετικό όρισμα}
\index{όρισμα!προαιρετικό}

~~~~ {.python}
>>> word.find('na', 3)
4
~~~~

Μια συνηθισμένη εργασία είναι να αφαιρέσετε τους λευκούς χαρακτήρες (κενά, tab
ή νέες γραμμές) από την αρχή και το τέλος μιας συμβολοσειράς χρησιμοποιώντας
τη μέθοδο `strip`:

~~~~ {.python}
>>> line = '  Here we go  '
>>> line.strip()
'Here we go'
~~~~

Ορισμένες μέθοδοι όπως το `startswith` επιστρέφουν λογικές τιμές.

~~~~ {.python}
>>> line = 'Have a nice day'
>>> line.startswith('Have')
True
>>> line.startswith('h')
False
~~~~

Θα προσέξατε ότι το `startswith` κάνει διάκριση πεζών-κεφαλαίων, οπότε μερικές
φορές παίρνουμε μια γραμμή και μετατρέπουμε όλα τα γράμματα σε πεζά προτού
κάνουμε οποιονδήποτε έλεγχο χρησιμοποιώντας τη μέθοδο `lower`.

~~~~ {.python}
>>> line = 'Have a nice day'
>>> line.startswith('h')
False
>>> line.lower()
'have a nice day'
>>> line.lower().startswith('h')
True
~~~~

Στο τελευταίο παράδειγμα, καλείται η μέθοδος `lower` και στη συνέχεια
χρησιμοποιούμε τη `startswith` για να δούμε αν η πεζή συμβολοσειρά που
προέκυψε ξεκινά με το γράμμα "h". Εφόσον είμαστε προσεκτικοί με τη σειρά,
μπορούμε να κάνουμε πολλές κλήσεις μεθόδων σε μία μόνο έκφραση.

\index{count μέθοδος}
\index{μέθοδος!count}

**Άσκηση 4: Υπάρχει μια μέθοδος συμβολοσειρών που ονομάζεται `count` που είναι
παρόμοια με τη συνάρτηση που δημιουργήσατε στην προηγούμενη άσκηση. Διαβάστε
την τεκμηρίωση αυτής της μεθόδου στη διεύθυνση:**

<https://docs.python.org/library/stdtypes.html#string-methods> 

**Γράψτε μια κλήση της, που μετράει πόσες φορές εμφανίζεται το γράμμα "a" στο
"banana".**

Ανάλυση συμβολοσειρών
---------------------

Συχνά, θέλουμε να ψάξουμε σε μια συμβολοσειρά και να βρούμε μια υποσυμβολοσειρά
της. Για παράδειγμα, αν μας παρουσιαζόταν μια σειρά γραμμών μορφοποιημένες όλες
ως εξής:

`From stephen.marquard@`*` uct.ac.za`*` Sat Jan  5 09:14:16 2008`

και θέλαμε να εξάγουμε μόνο το δεύτερο μισό της διεύθυνσης (δηλαδή το
`uct.ac.za`) από κάθε γραμμή, θα μπορούσαμε να το κάνουμε χρησιμοποιώντας
τη μέθοδο `find` και την διαμέριση συμβολοσειράς.

Αρχικά, θα βρούμε τη θέση του συμβόλου `at ( @ )` στη συμβολοσειρά. Στη
συνέχεια, θα βρούμε τη θέση του πρώτου διαστήματος *μετά* το σύμβολο `at` και,
στη συνέχεια, θα χρησιμοποιήσουμε τη διαμέριση συμβολοσειράς για να εξαγάγουμε
το τμήμα της συμβολοσειράς που αναζητούμε.

~~~~ {.python}
>>> data = 'From stephen.marquard@uct.ac.za Sat Jan  5 09:14:16 2008'
>>> atpos = data.find('@')
>>> print(atpos)
21
>>> sppos = data.find(' ',atpos)
>>> print(sppos)
31
>>> host = data[atpos+1:sppos]
>>> print(host)
uct.ac.za
>>>
~~~~

Χρησιμοποιούμε μια έκδοση της μεθόδου `find` που μας επιτρέπει να καθορίσουμε
μια θέση στη συμβολοσειρά από όπου θέλουμε να αρχίσει να ψάχνει το `find`. Όταν
τεμαχίζουμε, εξάγουμε τους χαρακτήρες "έναν πέρα από το σύμβολο at έως, *αλλά
χωρίς* αυτόν, τον χαρακτήρα διαστήματος".

Η τεκμηρίωση για τη μέθοδο `find` είναι διαθέσιμη στη διεύθυνση

<https://docs.python.org/library/stdtypes.html#string-methods>.

Τελεστής μορφής
---------------------

\index{format operator}
\index{τελεστής!μορφής}

Ο *τελεστής μορφής*, `%` μας επιτρέπει να κατασκευάσουμε συμβολοσειρές,
αντικαθιστώντας τμήματα των συμβολοσειρών με δεδομένα που είναι αποθηκευμένα
σε μεταβλητές. Όταν εφαρμόζεται σε ακέραιους αριθμούς, το `%` είναι ο τελεστής
ακέραιου υπολοίπου. Αλλά όταν ο πρώτος τελεστής είναι μια συμβολοσειρά, το `%`
είναι ο τελεστής μορφοποίησης.

\index{συμβολοσειρά μορφής}
\index{format string}

Ο πρώτος τελεστέος είναι η *συμβολοσειρά μορφής (format string)*, η οποία
περιέχει μία ή περισσότερες *ακολουθίες μορφής (format sequences)* που
καθορίζουν την μορφή του δεύτερου τελεστέου. Το αποτέλεσμα είναι μια
συμβολοσειρά.

\index{ακολουθία μορφής}
\index{format sequence}

Για παράδειγμα, η ακολουθία μορφής `%d` σημαίνει ότι ο δεύτερος τελεστέος
πρέπει να είναι ακέραιος (το "d" σημαίνει "decimal"):

~~~~ {.python}
>>> camels = 42
>>> '%d' % camels
'42'
~~~~

Το αποτέλεσμα είναι η συμβολοσειρά '42', η οποία δεν πρέπει να συγχέεται με την
ακέραια τιμή 42.

Μια ακολουθία μορφής μπορεί να εμφανιστεί οπουδήποτε μέσα στη συμβολοσειρά,
ώστε να μπορείτε να ενσωματώσετε μια τιμή σε μια πρόταση:

~~~~ {.python}
>>> camels = 42
>>> 'I have spotted %d camels.' % camels
'I have spotted 42 camels.'
~~~~

Εάν υπάρχουν περισσότερες από μία ακολουθίες μορφής στη συμβολοσειρά, το
δεύτερο όρισμα πρέπει να είναι πλειάδα (tuple)^[Η πλειάδα είναι μια ακολουθία
τιμών διαχωρισμένων με κόμμα μέσα σε ένα ζεύγος παρενθέσεων. Θα καλύψουμε τις
πλειάδες στο Κεφάλαιο 10]. Κάθε ακολουθία μορφής αντιστοιχίζεται με ένα
στοιχείο της πλειάδας, με τη σειρά.

Το παρακάτω παράδειγμα χρησιμοποιεί το `%d` για να αναπαραστήσει έναν ακέραιο,
το `%g` για να αναπαραστήσει έναν αριθμό κινητής υποδιαστολής (μην ρωτήσετε
γιατί) και το `%s` για να αναπαραστήσει μια συμβολοσειρά:

~~~~ {.python}
>>> 'In %d years I have spotted %g %s.' % (3, 0.1, 'camels')
'In 3 years I have spotted 0.1 camels.'
~~~~

Ο αριθμός των στοιχείων στην πλειάδα πρέπει να ταιριάζει με τον αριθμό των
ακολουθιών μορφής στη συμβολοσειρά. Οι τύποι των στοιχείων πρέπει επίσης
να ταιριάζουν με τις ακολουθίες μορφής:

\index{exception!TypeError}
\index{TypeError}

~~~~ {.python}
>>> '%d %d %d' % (1, 2)
TypeError: not enough arguments for format string
>>> '%d' % 'dollars'
TypeError: %d format: a number is required, not str
~~~~

Στο πρώτο παράδειγμα, δεν υπάρχουν αρκετά στοιχεία, στο δεύτερο, το στοιχείο
είναι λάθος τύπου.

Ο τελεστής μορφής είναι ισχυρός, αλλά μπορεί να είναι δύσκολος στη χρήση του.
Μπορείτε να διαβάσετε περισσότερα για αυτόν στο

<https://docs.python.org/library/stdtypes.html#printf-style-string-formatting>.

Εκσφαλμάτωση
------------

\index{εκσφαλμάτωση}

Μια δεξιότητα που πρέπει να καλλιεργήσετε καθώς προγραμματίζετε είναι να ρωτάτε
πάντα τον εαυτό σας: "Τι μπορεί να πάει στραβά εδώ;" ή εναλλακτικά, "Τι τρελό
πράγμα μπορεί να κάνει ο χρήστης μας για να καταρρεύσει το (φαινομενικά) τέλειο
πρόγραμμά μας;"

Για παράδειγμα, δείτε το πρόγραμμα που χρησιμοποιήσαμε για να εξηγήσουμε τον
βρόχο `while` στο κεφάλαιο για την επανάληψη:

\VerbatimInput{../code3/copytildone2.py}

Δείτε τι συμβαίνει όταν ο χρήστης εισάγει μια κενή γραμμή στην είσοδο:

~~~~ {.python}
> hello there
hello there
> # don't print this
> print this!
print this!
>
Traceback (most recent call last):
  File "copytildone.py", line 3, in <module>
    if line[0] == '#':
IndexError: string index out of range
~~~~

Ο κώδικας λειτουργεί καλά μέχρι να εμφανιστεί μια κενή γραμμή. Τότε δεν υπάρχει
μηδενικός χαρακτήρας, οπότε παίρνουμε ένα traceback. Υπάρχουν δύο λύσεις για να
γίνει η γραμμή τρία "ασφαλής" ακόμα κι αν η γραμμή είναι άδεια.

Μια δυνατότητα είναι απλώς να χρησιμοποιήσετε τη μέθοδο `startswith` που
επιστρέφει `False` εάν η συμβολοσειρά είναι κενή.

~~~~ {.python}
if line.startswith('#'):
~~~~

\index{guardian pattern}
\index{μοτίβο!φύλακα}

Ένας άλλος τρόπος είναι να γράψετε, για ασφάλεια, την εντολή `if`
χρησιμοποιώντας το μοτίβο *φύλακα* και να βεβαιωθείτε ότι η δεύτερη λογική
έκφραση αξιολογείται μόνο όπου υπάρχει τουλάχιστον ένας χαρακτήρας στη
συμβολοσειρά:

~~~~ {.python}
if len(γραμμή) > 0 and γραμμή[0] == '#':
~~~~

Γλωσσάριο
---------

flag
:   Μια λογική μεταβλητή που χρησιμοποιείται για να δείξει εάν μια συνθήκη
    είναι αληθής ή ψευδής.
\index{flag}

ακολουθία - sequence
:   Ένα διατεταγμένο σύνολο, δηλαδή ένα σύνολο τιμών όπου κάθε τιμή
    προσδιορίζεται από έναν ακέραιο δείκτη.
\index{ακολουθία}

ακολουθία μορφής
:   Μια ακολουθία χαρακτήρων σε μια συμβολοσειρά μορφής, όπως το `%d`, που
    καθορίζει τον τρόπο μορφοποίησης μιας τιμής.
\index{ακολουθία μορφής}

αμετάβλητo
:   Η ιδιότητα μιας ακολουθίας της οποίας τα στοιχεία δεν μπορούν να αλλάξουν.
\index{αμετάβλητο}
\index{αμεταβλητότητα}

αναζήτηση
:   Ένα μοτίβο διέλευσης που σταματά όταν βρει αυτό που ψάχνει.
\index{αναζήτηση μοτίβου}
\index{μοτίβο!αναζήτηση}

αντικείμενο - object
:   Κάτι στο οποίο μπορεί να αναφέρεται μια μεταβλητή. Προς το παρόν, μπορείτε
    να χρησιμοποιήσετε το "αντικείμενο" και το "τιμή" εναλλακτικά.
\index{object}
\index{αντικείμενο}

δείκτης
:   Μια ακέραια τιμή που χρησιμοποιείται για την επιλογή ενός στοιχείου από μια
    ακολουθία, όπως ενός χαρακτήρας από μια συμβολοσειρά.
\index{δείκτης}

διάσχιση
:   Η προσπέλαση των στοιχείων με μια σειρά, εκτελώντας μια παρόμοια λειτουργία
    στο καθένα.
\index{διάσχιση}

κενή συμβολοσειρά
:   Μια συμβολοσειρά χωρίς χαρακτήρες και μήκος 0, που αντιπροσωπεύεται από
    δύο εισαγωγικά.
\index{κενή συμβολοσειρά}

κλήση
:   Μια δήλωση που καλεί κάποια μέθοδο.
\index{κλήση}

μέθοδος
:   Μια συνάρτηση που σχετίζεται με ένα αντικείμενο και καλείται
    χρησιμοποιώντας διαχωρισμός με τελεία.
\index{μέθοδος}

μετρητής
:   Μια μεταβλητή που χρησιμοποιείται για να μετρήσει κάτι, συνήθως
    αρχικοποιείται με το μηδέν και στη συνέχεια αυξάνεται.
\index{μετρητής}

στοιχείο
:   Μία από τις τιμές μιας ακολουθίας.
\index{στοιχείο}

συμβολοσειρά μορφής
:   Μια συμβολοσειρά, που χρησιμοποιείται με τον τελεστή μορφής, που
    περιέχει ακολουθίες μορφής.
\index{συμβολοσειρά μορφής}

τελεστής μορφής
:   Ένας τελεστής,`%` , που παίρνει μια συμβολοσειρά μορφής και μια πλειάδα και
    δημιουργεί μια συμβολοσειρά που περιλαμβάνει τα στοιχεία της πλειάδας
    μορφοποιημένα όπως καθορίζεται από τη συμβολοσειρά μορφής.
\index{format operator}
\index{τελεστής!μορφής}

τμήμα - slice
:   Ένα μέρος μιας συμβολοσειράς που καθορίζεται από μια σειρά δεικτών.
\index{slice}

Ασκήσεις
---------

**Άσκηση 5: Πάρτε τον ακόλουθο κώδικα Python που αποθηκεύει μια συμβολοσειρά:**

`str = 'X-DSPAM-Confidence: `**`0.8475`**`'`

**Χρησιμοποιήστε `find` και διαμέριση συμβολοσειράς για να εξαγάγετε το τμήμα
της συμβολοσειράς μετά τον χαρακτήρα άνω και κάτω τελείας και στη συνέχεια
χρησιμοποιήστε τη συνάρτηση `float` για να μετατρέψετε τη συμβολοσειρά που
εξαγάγατε σε αριθμό κινητής υποδιαστολής.**

\index{συμβολοσειρά μέθοδος}
\index{μέθοδος!συμβολοσειρά}

**Άσκηση 6: Διαβάστε την τεκμηρίωση των μεθόδων συμβολοσειράς στο
<https://docs.python.org/library/stdtypes.html#string-methods>
Ίσως θελήσετε να πειραματιστείτε με μερικά από αυτά για να βεβαιωθείτε ότι
καταλαβαίνετε πώς λειτουργούν. Τα `strip` και `replace` είναι ιδιαίτερα
χρήσιμα.**

**Η τεκμηρίωση χρησιμοποιεί μια σύνταξη που μπορεί να προκαλεί σύγχυση. Για
παράδειγμα, στο `find(sub[, start[, end]])`, οι αγκύλες υποδεικνύουν
προαιρετικά ορίσματα. Επομένως, το `sub` απαιτείται, αλλά το `start` είναι
προαιρετικό και εάν συμπεριλάβετε το `start`, τότε το `end` είναι προαιρετικό.**
