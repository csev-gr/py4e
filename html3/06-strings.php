<?php if ( file_exists("../booktop.php") ) {
  require_once "../booktop.php";
  ob_start();
}?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>-</title>
  <style>
    html {
      line-height: 1.5;
      font-family: Georgia, serif;
      font-size: 20px;
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 1em;
      }
    }
    @media print {
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, 'Lucida Console', Consolas, monospace;
      font-size: 85%;
      margin: 0;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<h1 id="συμβολοσειρές">Συμβολοσειρές</h1>
<h2 id="μία-συμβολοσειρά-είναι-μία-ακολουθία">Μία συμβολοσειρά είναι μία ακολουθία</h2>
<p>   </p>
<p>Μια συμβολοσειρά είναι μια <em>ακολουθία</em> χαρακτήρων. Μπορείτε να προσπελάσετε τους χαρακτήρες, έναν κάθε φορά, με τον τελεστή αγκύλης:</p>
<pre class="python"><code>&gt;&gt;&gt; φρούτο = &#39;banana&#39;
&gt;&gt;&gt; γράμμα = φρούτο[1]</code></pre>
<p> </p>
<p>Η δεύτερη πρόταση εξάγει τον χαρακτήρα στη θέση 1 από τη μεταβλητή <code>φρούτο</code> και τον εκχωρεί στη μεταβλητή <code>γράμμα</code>.</p>
<p>Η έκφραση σε αγκύλες ονομάζεται <em>δείκτης (index)</em>. Ο δείκτης υποδεικνύει ποιον χαρακτήρα της ακολουθίας θέλετε (εξ ου και το όνομα).</p>
<p>Αλλά μπορεί να μην πάρετε αυτό που περιμένετε:</p>
<pre class="python"><code>&gt;&gt;&gt; print(γράμμα)
a</code></pre>
<p>Για τους περισσότερους ανθρώπους, το πρώτο γράμμα του “banana” είναι «b», όχι «a». Αλλά στην Python, ο δείκτης λειτουργεί κάπως διαφορετικά. Για την αρχή της συμβολοσειράς, για το πρώτο γράμμα είναι μηδέν.</p>
<pre class="python"><code>&gt;&gt;&gt; γράμμα = φρούτο[0]
&gt;&gt;&gt; print(γράμμα)
b</code></pre>
<p>Έτσι το “b” είναι το 0ό γράμμα (“μηδεκικ-ό”) του “banana”, το “a” είναι το 1ο γράμμα (“πρώτ-ο”), και το “n” είναι το 2ο (“δεύτερ-ο”) γράμμα.</p>
<figure>
<img src="../images/string.svg" alt="Δείκτες Συμβολοσειρών" style="height: 0.75in;"/>
<figcaption>
Δείκτες Συμβολοσειρών
</figcaption>
</figure>
<p> </p>
<p>Μπορείτε να χρησιμοποιήσετε οποιαδήποτε έκφραση, συμπεριλαμβανομένων μεταβλητών και τελεστών, σαν ένα δείκτη, αλλά η τιμή του δείκτη πρέπει να είναι ακέραιος αριθμός. Αλλιώς θα πάρετε:</p>
<p>   </p>
<pre class="python"><code>&gt;&gt;&gt; γράμμα = φρούτο[1.5]
TypeError: string indices must be integers</code></pre>
<h2 id="λήψη-του-μήκους-μιας-συμβολοσειράς-χρησιμοποιώντας-το-len.">Λήψη του μήκους μιας συμβολοσειράς χρησιμοποιώντας το <code>len</code>.</h2>
<p> </p>
<p>Η <code>len</code> είναι μια ενσωματωμένη συνάρτηση που επιστρέφει τον αριθμό των χαρακτήρων σε μια συμβολοσειρά:</p>
<pre class="python"><code>&gt;&gt;&gt; φρούτο = &#39;banana&#39;
&gt;&gt;&gt; len(φρούτο)
6</code></pre>
<p>Για να εξάγετε το τελευταίο γράμμα μιας συμβολοσειράς, μπορεί να μπείτε στον πειρασμό να δοκιμάσετε κάτι σαν αυτό:</p>
<p> </p>
<pre class="python"><code>&gt;&gt;&gt; μήκος = len(φρούτο)
&gt;&gt;&gt; τελευταίο = φρούτο[μήκος]
IndexError: string index out of range</code></pre>
<p>Ο λόγος για το <code>IndexError</code> είναι ότι δεν υπάρχει γράμμα στο “banana” με δείκτη 6. Εφόσον αρχίσαμε να μετράμε από το μηδέν, τα έξι γράμματα αριθμούνται από το 0 έως το 5. Για να πάρετε τον τελευταίο χαρακτήρα, πρέπει να αφαιρέσετε 1 από το <code>μήκος</code>:</p>
<pre class="python"><code>&gt;&gt;&gt; τελευταίο = φρούτο[μήκος-1]
&gt;&gt;&gt; print(τελευταίο)
a</code></pre>
<p>Εναλλακτικά, μπορείτε να χρησιμοποιήσετε αρνητικούς δείκτες, οι οποίοι μετρούν αντίστροφα από το τέλος της συμβολοσειράς. Η έκφραση <code>φρούτο[-1]</code> δίνει το τελευταίο γράμμα, το <code>φρούτο[-2]</code> δίνει το δεύτερο από το τέλος και ούτω καθεξής.</p>
<p> </p>
<h2 id="διάσχιση-συμβολοσειράς-με-βρόχο">Διάσχιση συμβολοσειράς με βρόχο</h2>
<p>     </p>
<p>Πολλοί υπολογισμοί εμπλέκουν την επεξεργασία μιας συμβολοσειράς, έναν χαρακτήρα τη φορά. Συχνά ξεκινούν από την αρχή, επιλέγουν κάθε χαρακτήρα με τη σειρά, κάνουν κάτι σε αυτόν και συνεχίζουν μέχρι το τέλος. Αυτό το μοτίβο επεξεργασίας ονομάζεται <em>διάσχιση</em>. Ένας τρόπος για να γράψετε μια διάσχιση είναι με έναν βρόχο <code>while</code>:</p>
<pre class="python"><code>δείκτης = 0
while δείκτης &lt; len(φρούτο):
    γράμμα = φρούτο[δείκτης]
    print(γράμμα)
    δείκτης = δείκτης + 1</code></pre>
<p>Αυτός ο βρόχος διασχίζει τη συμβολοσειρά και εμφανίζει κάθε γράμμα σε μια γραμμή, από μόνο του. Η συνθήκη βρόχου είναι <code>δείκτης &lt; len(φρούτο)</code>, οπότε όταν ο <code>δείκτης</code> είναι ίσος με το μήκος της συμβολοσειράς, η συνθήκη είναι ψευδής και το σώμα του βρόχου δεν εκτελείται. Ο τελευταίος χαρακτήρας που προσπελαύνεται είναι αυτός με τον δείκτη <code>len(fruit)-1</code>, που είναι και ο τελευταίος χαρακτήρας της συμβολοσειράς.</p>
<p><strong>Άσκηση 1: Γράψτε έναν βρόχο <code>while</code> που ξεκινά από τον τελευταίο χαρακτήρα της συμβολοσειράς και πηγαίνει προς τα πίσω μέχρι τον πρώτο χαρακτήρα της συμβολοσειράς, τυπώνοντας κάθε γράμμα σε ξεχωριστή γραμμή, απλά με ανάποδη σειρά.</strong></p>
<p>Ένας άλλος τρόπος για να γράψετε μια διάσχιση είναι με έναν βρόχο <code>for</code>:</p>
<pre class="python"><code>for char in fruit:
    print(char)</code></pre>
<p>Κάθε φορά που επαναλαμβάνεται ο βρόχος, ο επόμενος χαρακτήρας της συμβολοσειράς εκχωρείται στη μεταβλητή <code>char</code>. Ο βρόχος συνεχίζεται μέχρι να προσπελάσουμε όλους τους χαρακτήρες.</p>
<h2 id="διαμέριση-συμβολοσειρών">Διαμέριση συμβολοσειρών</h2>
<p>      </p>
<p>Ένα <em>τμήμα</em> μιας συμβολοσειράς ονομάζεται <em>slice</em>. Η επιλογή ενός τμήματος είναι παρόμοια με την επιλογή ενός χαρακτήρα:</p>
<pre class="python"><code>&gt;&gt;&gt; s = &#39;Monty Python&#39;
&gt;&gt;&gt; print(s[0:5])
Monty
&gt;&gt;&gt; print(s[6:12])
Python</code></pre>
<p>Ο τελεστής <code>[n:m]</code> επιστρέφει το τμήμα της συμβολοσειράς από τον “n-ιοστό” χαρακτήρα μέχρι τον “m-ιοστό” χαρακτήρα, συμπεριλαμβανομένου του πρώτου αλλά εξαιρώντας τον τελευταίο.</p>
<p>Εάν παραλείψετε τον πρώτο δείκτη (πριν από την άνω και κάτω τελεία), το τμήμα που λαμβάνετε ξεκινά από την αρχή της συμβολοσειράς. Εάν παραλείψετε τον δεύτερο δείκτη, το τμήμα φτάνει μέχρι και το τέλος της συμβολοσειράς:</p>
<pre class="python"><code>&gt;&gt;&gt; φρούτο = &#39;banana&#39;
&gt;&gt;&gt; φρούτο[:3]
&#39;ban&#39;
&gt;&gt;&gt; φρούτο[3:]
&#39;ana&#39;</code></pre>
<p>Εάν ο πρώτος δείκτης είναι μεγαλύτερος ή ίσος με τον δεύτερο, το αποτέλεσμα είναι μια <em>κενή συμβολοσειρά</em>, που αντιπροσωπεύεται από δύο εισαγωγικά:</p>
<p></p>
<pre class="python"><code>&gt;&gt;&gt; φρούτο = &#39;banana&#39;
&gt;&gt;&gt; φρούτο[3:3]
&#39;&#39;</code></pre>
<p>Μια κενή συμβολοσειρά δεν περιέχει χαρακτήρες και έχει μήκος 0, αλλά εκτός από αυτό, είναι ίδια με οποιαδήποτε άλλη συμβολοσειρά.</p>
<p><strong>Άσκηση 2: Δεδομένου ότι το <code>φρούτο</code> είναι μια συμβολοσειρά, τι σημαίνει <code>φρούτο[:]</code>;</strong></p>
<p> </p>
<h2 id="οι-συμβολοσειρές-είναι-αμετάβλητες">Οι συμβολοσειρές είναι αμετάβλητες</h2>
<p>    </p>
<p>Είναι δελεαστικό να χρησιμοποιήσετε τον τελεστή στην αριστερή πλευρά μιας ανάθεσης, με την πρόθεση να αλλάξετε έναν χαρακτήρα σε μια συμβολοσειρά. Για παράδειγμα:</p>
<p> </p>
<pre class="python"><code>&gt;&gt;&gt; greeting = &#39;Hello, world!&#39;
&gt;&gt;&gt; greeting[0] = &#39;J&#39;
TypeError: &#39;str&#39; object does not support item assignment</code></pre>
<p>Το “αντικείμενο - object” σε αυτήν την περίπτωση είναι η συμβολοσειρά και το “στοιχείο - item” είναι ο χαρακτήρας που προσπαθήσατε να τροποποιήσετε. Προς το παρόν, ένα <em>αντικείμενο</em> είναι το ίδιο πράγμα με μια τιμή, αλλά θα βελτιώσουμε αυτόν τον ορισμό αργότερα. Ένα <em>στοιχείο</em> είναι μία από τις τιμές σε μια ακολουθία.</p>
<p>      </p>
<p>Το σφάλμα αυτό προκλήθηκε γιατί οι συμβολοσειρές είναι <em>αμετάβλητες</em>, πράγμα που σημαίνει ότι δεν μπορείτε να τροποποιήσετε μια υπάρχουσα συμβολοσειρά. Το καλύτερο που μπορείτε να κάνετε είναι να δημιουργήσετε μια νέα συμβολοσειρά που θα είναι μια παραλλαγή της αρχικής:</p>
<pre class="python"><code>&gt;&gt;&gt; greeting = &#39;Hello, world!&#39;
&gt;&gt;&gt; new_greeting = &#39;J&#39; + greeting[1:]
&gt;&gt;&gt; print(new_greeting)
Jello, world!</code></pre>
<p>Αυτό το παράδειγμα συνενώνει ένα νέο πρώτο γράμμα με ένα τμήμα του <code>greeting</code>. Δεν έχει καμία επίδραση στην αρχική συμβολοσειρά.</p>
<p> </p>
<h2 id="βρόχος-και-μέτρηση">Βρόχος και μέτρηση</h2>
<p>    </p>
<p>Το παρακάτω πρόγραμμα μετράει πόσες φορές εμφανίζεται το γράμμα “a” σε μια συμβολοσειρά:</p>
<pre class="python"><code>λέξη = &#39;banana&#39;
πλήθος = 0
for γράμμα in λέξη:
    if γράμμα == &#39;a&#39;:
        πλήθος = πλήθος + 1
print(πλήθος)</code></pre>
<p>Αυτό το πρόγραμμα παρουσιάζει ένα άλλο μοτίβο υπολογισμού που ονομάζεται <em>μετρητής</em>. Η μεταβλητή <code>πλήθος</code> αρχικοποιείται σε 0 και στη συνέχεια αυξάνεται κάθε φορά που βρίσκεται ένα “a”. Όταν ο βρόχος τερματίζει, το <code>πλήθος</code> περιέχει το αποτέλεσμα: το πλήθος των α.</p>
<p></p>
<p><strong>Άσκηση 3: Ενθυλακώστε αυτόν τον κώδικα σε μια συνάρτηση με όνομα <code>count</code> και γενικεύστε τον έτσι ώστε να δέχεται τη συμβολοσειρά και το γράμμα ως ορίσματα.</strong></p>
<h2 id="ο-τελεστής-in">Ο τελεστής <code>in</code></h2>
<p>   </p>
<p>Η λέξη “in” είναι ένας λογικός τελεστής που δέχεται δύο συμβολοσειρές και επιστρέφει <code>True</code> εάν η πρώτη είναι τμήμα της δεύτερης:</p>
<pre class="python"><code>&gt;&gt;&gt; &#39;a&#39; in &#39;banana&#39;
True
&gt;&gt;&gt; &#39;seed&#39; in &#39;banana&#39;
False</code></pre>
<h2 id="σύγκριση-συμβολοσειρών">Σύγκριση συμβολοσειρών</h2>
<p> </p>
<p>Οι τελεστές σύγκρισης λειτουργούν σε συμβολοσειρές. Για να δείτε αν δύο συμβολοσειρές είναι ίσες:</p>
<pre class="python"><code>if λέξη == &#39;banana&#39;:
    print(&#39;Όλα εντάξει, bananas.&#39;)</code></pre>
<p>Άλλοι τελεστές σύγκρισης που είναι χρήσιμοι για την τοποθέτηση λέξεων σε αλφαβητική σειρά:</p>
<pre class="python"><code>if λέξη &lt; &#39;banana&#39;:
    print(&#39;Η λέξη σου, &#39; + λέξη + &#39;, προηγείται της banana.&#39;)
elif λέξη &gt; &#39;banana&#39;:
    print(&#39;Η λέξη σου, &#39; + λέξη + &#39;, έπεται της banana.&#39;)
else:
    print(&#39;Όλα εντάξει, bananas.&#39;)</code></pre>
<p>Η Python δεν χειρίζεται τα κεφαλαία και τα πεζά γράμματα με τον ίδιο τρόπο που το κάνουν οι άνθρωποι. Όλα τα κεφαλαία γράμματα θεωρούνται μικρότερα από όλα τα πεζά, οπότε:</p>
<pre class="{text}"><code>Η λέξη σου, Pineapple, προηγείται της banana.</code></pre>
<p>Ένας συνηθισμένος τρόπος αντιμετώπισης αυτού του προβλήματος είναι η μετατροπή των συμβολοσειρών σε τυπική μορφή, όπως όλα πεζά, πριν από την εκτέλεση της σύγκρισης. Έχετέ το υπόψη σας, σε περίπτωση που χρειαστεί να υπερασπιστείτε τον εαυτό σας ενάντια σε έναν άνδρα οπλισμένο με έναν ανανά (Pineapple) (αμερικάνικη στρατιωτική αργκό όπου ο ανανάς σημαίνει χειροβομβίδα).</p>
<h2 id="μέθοδοι-συμβολοσειρών">Μέθοδοι συμβολοσειρών</h2>
<p>Οι συμβολοσειρές (str) είναι ένα παράδειγμα <em>αντικειμένων</em> Python. Ένα αντικείμενο περιέχει τόσο δεδομένα (την ίδια τη συμβολοσειρά) όσο και <em>μεθόδους</em>, οι οποίες είναι ουσιαστικά συναρτήσεις που είναι ενσωματωμένες στο αντικείμενο και είναι διαθέσιμες σε κάθε <em>στιγμιότυπο - instance</em> του αντικειμένου.</p>
<p>Η Python έχει μια συνάρτηση που ονομάζεται <code>dir</code>, η οποία παραθέτει τις διαθέσιμες μεθόδους για κάποιο αντικείμενο. Η συνάρτηση <code>type</code> δείχνει τον τύπο ενός αντικειμένου και η συνάρτηση <code>dir</code> δείχνει τις διαθέσιμες μεθόδους.</p>
<pre class="python"><code>&gt;&gt;&gt; stuff = &#39;Hello world&#39;
&gt;&gt;&gt; type(stuff)
&lt;class &#39;str&#39;&gt;
&gt;&gt;&gt; dir(stuff)
[&#39;capitalize&#39;, &#39;casefold&#39;, &#39;center&#39;, &#39;count&#39;, &#39;encode&#39;,
&#39;endswith&#39;, &#39;expandtabs&#39;, &#39;find&#39;, &#39;format&#39;, &#39;format_map&#39;,
&#39;index&#39;, &#39;isalnum&#39;, &#39;isalpha&#39;, &#39;isdecimal&#39;, &#39;isdigit&#39;,
&#39;isidentifier&#39;, &#39;islower&#39;, &#39;isnumeric&#39;, &#39;isprintable&#39;,
&#39;isspace&#39;, &#39;istitle&#39;, &#39;isupper&#39;, &#39;join&#39;, &#39;ljust&#39;, &#39;lower&#39;,
&#39;lstrip&#39;, &#39;maketrans&#39;, &#39;partition&#39;, &#39;replace&#39;, &#39;rfind&#39;,
&#39;rindex&#39;, &#39;rjust&#39;, &#39;rpartition&#39;, &#39;rsplit&#39;, &#39;rstrip&#39;,
&#39;split&#39;, &#39;splitlines&#39;, &#39;startswith&#39;, &#39;strip&#39;, &#39;swapcase&#39;,
&#39;title&#39;, &#39;translate&#39;, &#39;upper&#39;, &#39;zfill&#39;]
&gt;&gt;&gt; help(str.capitalize)
Help on method_descriptor:

capitalize(...)
    S.capitalize() -&gt; str

    Return a capitalized version of S, i.e. make the first character
    have upper case and the rest lower case.
&gt;&gt;&gt;</code></pre>
<p>Ενώ η συνάρτηση <code>dir</code> παραθέτει τις μεθόδους και μπορείτε να χρησιμοποιήσετε τη <code>help</code> για να λάβετε κάποια απλή τεκμηρίωση σε μια μέθοδο, μια καλύτερη πηγή τεκμηρίωσης για τις μεθόδους συμβολοσειράς θα ήταν <a href="https://docs.python.org/library/stdtypes.html#string-methods" class="uri">https://docs.python.org/library/stdtypes.html#string-methods</a>.</p>
<p>Η κλήση μιας <em>μεθόδου</em> είναι παρόμοια με την κλήση μιας συνάρτησης (δέχεται ορίσματα και επιστρέφει μια τιμή), αλλά η σύνταξη είναι διαφορετική. Καλούμε μια μέθοδο προσθέτοντας το όνομα της μεθόδου στο τέλος του ονόματος της μεταβλητής, χρησιμοποιώντας την τελεία ως οριοθέτη.</p>
<p>Για παράδειγμα, η μέθοδος <code>upper</code> δέχεται μια συμβολοσειρά και επιστρέφει μια νέα συμβολοσειρά με όλα τα γράμματα κεφαλαία:</p>
<p> </p>
<p>Αντί για τη σύνταξη των συναρτήσεων <code>upper(word)</code>, χρησιμοποιεί τη σύνταξη των μεθόδων <code>λέξη.upper()</code>.</p>
<p> </p>
<pre class="python"><code>&gt;&gt;&gt; λέξη = &#39;banana&#39;
&gt;&gt;&gt; νέα_λέξη = λέξη.upper()
&gt;&gt;&gt; print(νέα_λέξη)
BANANA</code></pre>
<p>Αυτή η μορφή διαχωρισμού με τελεία καθορίζει το όνομα της μεθόδου, <code>upper</code> και το όνομα της συμβολοσειράς <code>λέξη</code>, για την εφαρμογή της μεθόδου. Οι κενές παρενθέσεις υποδεικνύουν ότι αυτή η μέθοδος δεν δέχεται όρισμα.</p>
<p></p>
<p>Μια κλήση μεθόδου ονομάζεται <em>επίκληση - invocation</em>. Σε αυτή την περίπτωση, θα λέγαμε ότι επικαλούμαστε <code>upper</code> στην <code>λέξη</code>.</p>
<p> </p>
<p>Για παράδειγμα, υπάρχει μια μέθοδος συμβολοσειράς με το όνομα <code>find</code> που αναζητά τη θέση μιας συμβολοσειράς μέσα σε μια άλλη:</p>
<pre class="python"><code>&gt;&gt;&gt; λέξη = &#39;banana&#39;
&gt;&gt;&gt; δείκτης = λέξη.find(&#39;a&#39;)
&gt;&gt;&gt; print(δείκτης)
1</code></pre>
<p>Σε αυτό το παράδειγμα, επικαλούμαστε την <code>find</code> στη <code>λέξη</code> και δίνουμε το γράμμα που αναζητούμε ως παράμετρο.</p>
<p>Η μέθοδος <code>find</code> μπορεί να βρει υποσυμβολοσειρές καθώς και χαρακτήρες:</p>
<pre class="python"><code>&gt;&gt;&gt; λέξη.find(&#39;na&#39;)
2</code></pre>
<p>Μπορεί να πάρει ως δεύτερο όρισμα τον δείκτη από όπου πρέπει να ξεκινήσει:</p>
<p> </p>
<pre class="python"><code>&gt;&gt;&gt; λέξη.find(&#39;na&#39;, 3)
4</code></pre>
<p>Μια συνηθισμένη εργασία είναι να αφαιρέσετε τους λευκούς χαρακτήρες (κενά, tab ή νέες γραμμές) από την αρχή και το τέλος μιας συμβολοσειράς χρησιμοποιώντας τη μέθοδο <code>strip</code>:</p>
<pre class="python"><code>&gt;&gt;&gt; γραμμή = &#39;  Πάμε λοιπόν  &#39;
&gt;&gt;&gt; γραμμή.strip()
&#39;Πάμε λοιπόν&#39;</code></pre>
<p>Ορισμένες μέθοδοι όπως το <code>startswith</code> επιστρέφουν λογικές τιμές.</p>
<pre class="python"><code>&gt;&gt;&gt; γραμμή = &#39;Καλή σας μέρα&#39;
&gt;&gt;&gt; γραμμή.startswith(&#39;Καλή&#39;)
True
&gt;&gt;&gt; γραμμή.startswith(&#39;κ&#39;)
False</code></pre>
<p>Θα προσέξατε ότι το <code>startswith</code> κάνει διάκριση πεζών-κεφαλαίων, οπότε μερικές φορές παίρνουμε μια γραμμή και μετατρέπουμε όλα τα γράμματα σε πεζά προτού κάνουμε οποιονδήποτε έλεγχο χρησιμοποιώντας τη μέθοδο <code>lower</code>.</p>
<pre class="python"><code>&gt;&gt;&gt; γραμμή = &#39;Καλή σας μέρα&#39;
&gt;&gt;&gt; γραμμή.startswith(&#39;κ&#39;)
False
&gt;&gt;&gt; γραμμή.lower()
&#39;καλή σας μέρα&#39;
&gt;&gt;&gt; γραμμή.lower().startswith(&#39;κ&#39;)
True</code></pre>
<p>Στο τελευταίο παράδειγμα, καλείται η μέθοδος <code>lower</code> και στη συνέχεια χρησιμοποιούμε τη <code>startswith</code> για να δούμε αν η πεζή συμβολοσειρά που προέκυψε ξεκινά με το γράμμα “κ”. Εφόσον είμαστε προσεκτικοί με τη σειρά, μπορούμε να κάνουμε πολλές κλήσεις μεθόδων σε μία μόνο έκφραση.</p>
<p> </p>
<p><strong>Άσκηση 4: Υπάρχει μια μέθοδος συμβολοσειρών που ονομάζεται <code>count</code> που είναι παρόμοια με τη συνάρτηση που δημιουργήσατε στην προηγούμενη άσκηση. Διαβάστε την τεκμηρίωση αυτής της μεθόδου στη διεύθυνση:</strong></p>
<p><a href="https://docs.python.org/library/stdtypes.html#string-methods" class="uri">https://docs.python.org/library/stdtypes.html#string-methods</a></p>
<p><strong>Γράψτε μια κλήση της, που μετράει πόσες φορές εμφανίζεται το γράμμα “a” στο “banana”.</strong></p>
<h2 id="ανάλυση-συμβολοσειρών">Ανάλυση συμβολοσειρών</h2>
<p>Συχνά, θέλουμε να ψάξουμε σε μια συμβολοσειρά και να βρούμε μια υποσυμβολοσειρά της. Για παράδειγμα, αν μας παρουσιαζόταν μια σειρά γραμμών μορφοποιημένες όλες ως εξής:</p>
<p><code>From stephen.marquard@</code><em><code> uct.ac.za</code></em><code> Sat Jan  5 09:14:16 2008</code></p>
<p>και θέλαμε να εξάγουμε μόνο το δεύτερο μισό της διεύθυνσης (δηλαδή το <code>uct.ac.za</code>) από κάθε γραμμή, θα μπορούσαμε να το κάνουμε χρησιμοποιώντας τη μέθοδο <code>find</code> και την διαμέριση συμβολοσειράς.</p>
<p>Αρχικά, θα βρούμε τη θέση του συμβόλου <code>at ( @ )</code> στη συμβολοσειρά. Στη συνέχεια, θα βρούμε τη θέση του πρώτου διαστήματος <em>μετά</em> το σύμβολο <code>at</code> και, στη συνέχεια, θα χρησιμοποιήσουμε τη διαμέριση συμβολοσειράς για να εξαγάγουμε το τμήμα της συμβολοσειράς που αναζητούμε.</p>
<pre class="python"><code>&gt;&gt;&gt; data = &#39;From stephen.marquard@uct.ac.za Sat Jan  5 09:14:16 2008&#39;
&gt;&gt;&gt; θέσηat = data.find(&#39;@&#39;)
&gt;&gt;&gt; print(θέσηat)
21
&gt;&gt;&gt; θέση_τέλους = data.find(&#39; &#39;,θέσηat)
&gt;&gt;&gt; print(θέση_τέλους)
31
&gt;&gt;&gt; host = data[θέσηat+1:θέση_τέλους]
&gt;&gt;&gt; print(host)
uct.ac.za
&gt;&gt;&gt;</code></pre>
<p>Χρησιμοποιούμε μια έκδοση της μεθόδου <code>find</code> που μας επιτρέπει να καθορίσουμε μια θέση στη συμβολοσειρά από όπου θέλουμε να αρχίσει να ψάχνει το <code>find</code>. Όταν τεμαχίζουμε, εξάγουμε τους χαρακτήρες “έναν πέρα από το σύμβολο at έως, <em>αλλά χωρίς</em> αυτόν, τον χαρακτήρα διαστήματος”.</p>
<p>Η τεκμηρίωση για τη μέθοδο <code>find</code> είναι διαθέσιμη στη διεύθυνση</p>
<p><a href="https://docs.python.org/library/stdtypes.html#string-methods" class="uri">https://docs.python.org/library/stdtypes.html#string-methods</a>.</p>
<h2 id="τελεστής-μορφής">Τελεστής μορφής</h2>
<p> </p>
<p>Ο <em>τελεστής μορφής</em>, <code>%</code> μας επιτρέπει να κατασκευάσουμε συμβολοσειρές, αντικαθιστώντας τμήματα των συμβολοσειρών με δεδομένα που είναι αποθηκευμένα σε μεταβλητές. Όταν εφαρμόζεται σε ακέραιους αριθμούς, το <code>%</code> είναι ο τελεστής ακέραιου υπολοίπου. Αλλά όταν ο πρώτος τελεστής είναι μια συμβολοσειρά, το <code>%</code> είναι ο τελεστής μορφοποίησης.</p>
<p> </p>
<p>Ο πρώτος τελεστέος είναι η <em>συμβολοσειρά μορφής (format string)</em>, η οποία περιέχει μία ή περισσότερες <em>ακολουθίες μορφής (format sequences)</em> που καθορίζουν την μορφή του δεύτερου τελεστέου. Το αποτέλεσμα είναι μια συμβολοσειρά.</p>
<p> </p>
<p>Για παράδειγμα, η ακολουθία μορφής <code>%d</code> σημαίνει ότι ο δεύτερος τελεστέος πρέπει να είναι ακέραιος (το “d” σημαίνει “decimal”):</p>
<pre class="python"><code>&gt;&gt;&gt; καμήλες = 42
&gt;&gt;&gt; &#39;%d&#39; % καμήλες
&#39;42&#39;</code></pre>
<p>Το αποτέλεσμα είναι η συμβολοσειρά ‘42’, η οποία δεν πρέπει να συγχέεται με την ακέραια τιμή 42.</p>
<p>Μια ακολουθία μορφής μπορεί να εμφανιστεί οπουδήποτε μέσα στη συμβολοσειρά, ώστε να μπορείτε να ενσωματώσετε μια τιμή σε μια πρόταση:</p>
<pre class="python"><code>&gt;&gt;&gt; καμήλες = 42
&gt;&gt;&gt; &#39;Έχω εντοπίσει %d καμήλες.&#39; % καμήλες
&#39;Έχω εντοπίσει 42 καμήλες.&#39;</code></pre>
<p>Εάν υπάρχουν περισσότερες από μία ακολουθίες μορφής στη συμβολοσειρά, το δεύτερο όρισμα πρέπει να είναι πλειάδα (tuple)<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>. Κάθε ακολουθία μορφής αντιστοιχίζεται με ένα στοιχείο της πλειάδας, με τη σειρά.</p>
<p>Το παρακάτω παράδειγμα χρησιμοποιεί το <code>%d</code> για να αναπαραστήσει έναν ακέραιο, το <code>%g</code> για να αναπαραστήσει έναν αριθμό κινητής υποδιαστολής (μην ρωτήσετε γιατί) και το <code>%s</code> για να αναπαραστήσει μια συμβολοσειρά:</p>
<pre class="python"><code>&gt;&gt;&gt; &#39;Σε %d χρόνια έχω εντοπίσει %g %s.&#39; % (3, 0.1, &#39;καμήλες&#39;)
&#39;Σε 3 χρόνια έχω εντοπίσει 0.1 καμήλες.&#39;</code></pre>
<p>Ο αριθμός των στοιχείων στην πλειάδα πρέπει να ταιριάζει με τον αριθμό των ακολουθιών μορφής στη συμβολοσειρά. Οι τύποι των στοιχείων πρέπει επίσης να ταιριάζουν με τις ακολουθίες μορφής:</p>
<p> </p>
<pre class="python"><code>&gt;&gt;&gt; &#39;%d %d %d&#39; % (1, 2)
TypeError: not enough arguments for format string
&gt;&gt;&gt; &#39;%d&#39; % &#39;dollars&#39;
TypeError: %d format: a number is required, not str</code></pre>
<p>Στο πρώτο παράδειγμα, δεν υπάρχουν αρκετά στοιχεία, στο δεύτερο, το στοιχείο είναι λάθος τύπου.</p>
<p>Ο τελεστής μορφής είναι ισχυρός, αλλά μπορεί να είναι δύσκολος στη χρήση του. Μπορείτε να διαβάσετε περισσότερα για αυτόν στο</p>
<p><a href="https://docs.python.org/library/stdtypes.html#printf-style-string-formatting" class="uri">https://docs.python.org/library/stdtypes.html#printf-style-string-formatting</a>.</p>
<h2 id="εκσφαλμάτωση">Εκσφαλμάτωση</h2>
<p></p>
<p>Μια δεξιότητα που πρέπει να καλλιεργήσετε καθώς προγραμματίζετε είναι να ρωτάτε πάντα τον εαυτό σας: “Τι μπορεί να πάει στραβά εδώ;” ή εναλλακτικά, “Τι τρελό πράγμα μπορεί να κάνει ο χρήστης μας για να καταρρεύσει το (φαινομενικά) τέλειο πρόγραμμά μας;”</p>
<p>Για παράδειγμα, δείτε το πρόγραμμα που χρησιμοποιήσαμε για να εξηγήσουμε τον βρόχο <code>while</code> στο κεφάλαιο για την επανάληψη:</p>
<pre class="python"><code>while True:
    γραμμή = input(&#39;&gt; &#39;)
    if γραμμή[0] == &#39;#&#39;:
        continue
    if γραμμή == &#39;τέλος&#39;:
        break
    print(γραμμή)
print(&#39;Τέλος!&#39;)

# Code: http://www.gr.py4e.com/code3/copytildone2.py</code></pre>
<p>Δείτε τι συμβαίνει όταν ο χρήστης εισάγει μια κενή γραμμή στην είσοδο:</p>
<pre class="python"><code>&gt; hello there
hello there
&gt; # don&#39;t print this
&gt; print this!
print this!
&gt;
Traceback (most recent call last):
  File &quot;copytildone.py&quot;, line 3, in &lt;module&gt;
    if γραμμή[0] == &#39;#&#39;:
IndexError: string index out of range</code></pre>
<p>Ο κώδικας λειτουργεί καλά μέχρι να εμφανιστεί μια κενή γραμμή. Τότε δεν υπάρχει μηδενικός χαρακτήρας, οπότε παίρνουμε ένα traceback. Υπάρχουν δύο λύσεις για να γίνει η γραμμή τρία “ασφαλής” ακόμα κι αν η γραμμή είναι άδεια.</p>
<p>Μια δυνατότητα είναι απλώς να χρησιμοποιήσετε τη μέθοδο <code>startswith</code> που επιστρέφει <code>False</code> εάν η συμβολοσειρά είναι κενή.</p>
<pre class="python"><code>if γραμμή.startswith(&#39;#&#39;):</code></pre>
<p> </p>
<p>Ένας άλλος τρόπος είναι να γράψετε, για ασφάλεια, την εντολή <code>if</code> χρησιμοποιώντας το μοτίβο <em>φύλακα</em> και να βεβαιωθείτε ότι η δεύτερη λογική έκφραση αξιολογείται μόνο όπου υπάρχει τουλάχιστον ένας χαρακτήρας στη συμβολοσειρά:</p>
<pre class="python"><code>if len(γραμμή) &gt; 0 and γραμμή[0] == &#39;#&#39;:</code></pre>
<h2 id="γλωσσάριο">Γλωσσάριο</h2>
<dl>
<dt>flag</dt>
<dd>Μια λογική μεταβλητή που χρησιμοποιείται για να δείξει εάν μια συνθήκη είναι αληθής ή ψευδής.
</dd>
<dt>ακολουθία - sequence</dt>
<dd>Ένα διατεταγμένο σύνολο, δηλαδή ένα σύνολο τιμών όπου κάθε τιμή προσδιορίζεται από έναν ακέραιο δείκτη.
</dd>
<dt>ακολουθία μορφής</dt>
<dd>Μια ακολουθία χαρακτήρων σε μια συμβολοσειρά μορφής, όπως το <code>%d</code>, που καθορίζει τον τρόπο μορφοποίησης μιας τιμής.
</dd>
<dt>αμετάβλητo</dt>
<dd>Η ιδιότητα μιας ακολουθίας της οποίας τα στοιχεία δεν μπορούν να αλλάξουν.
</dd>
<dt>αναζήτηση</dt>
<dd>Ένα μοτίβο διέλευσης που σταματά όταν βρει αυτό που ψάχνει.
</dd>
<dt>αντικείμενο - object</dt>
<dd>Κάτι στο οποίο μπορεί να αναφέρεται μια μεταβλητή. Προς το παρόν, μπορείτε να χρησιμοποιήσετε το “αντικείμενο” και το “τιμή” εναλλακτικά.
</dd>
<dt>δείκτης</dt>
<dd>Μια ακέραια τιμή που χρησιμοποιείται για την επιλογή ενός στοιχείου από μια ακολουθία, όπως ενός χαρακτήρας από μια συμβολοσειρά.
</dd>
<dt>διάσχιση</dt>
<dd>Η προσπέλαση των στοιχείων με μια σειρά, εκτελώντας μια παρόμοια λειτουργία στο καθένα.
</dd>
<dt>κενή συμβολοσειρά</dt>
<dd>Μια συμβολοσειρά χωρίς χαρακτήρες και μήκος 0, που αντιπροσωπεύεται από δύο εισαγωγικά.
</dd>
<dt>κλήση</dt>
<dd>Μια δήλωση που καλεί κάποια μέθοδο.
</dd>
<dt>μέθοδος</dt>
<dd>Μια συνάρτηση που σχετίζεται με ένα αντικείμενο και καλείται χρησιμοποιώντας διαχωρισμός με τελεία.
</dd>
<dt>μετρητής</dt>
<dd>Μια μεταβλητή που χρησιμοποιείται για να μετρήσει κάτι, συνήθως αρχικοποιείται με το μηδέν και στη συνέχεια αυξάνεται.
</dd>
<dt>στοιχείο</dt>
<dd>Μία από τις τιμές μιας ακολουθίας.
</dd>
<dt>συμβολοσειρά μορφής</dt>
<dd>Μια συμβολοσειρά, που χρησιμοποιείται με τον τελεστή μορφής, που περιέχει ακολουθίες μορφής.
</dd>
<dt>τελεστής μορφής</dt>
<dd>Ένας τελεστής,<code>%</code> , που παίρνει μια συμβολοσειρά μορφής και μια πλειάδα και δημιουργεί μια συμβολοσειρά που περιλαμβάνει τα στοιχεία της πλειάδας μορφοποιημένα όπως καθορίζεται από τη συμβολοσειρά μορφής.
</dd>
<dt>τμήμα - slice</dt>
<dd>Ένα μέρος μιας συμβολοσειράς που καθορίζεται από μια σειρά δεικτών.
</dd>
</dl>
<h2 id="ασκήσεις">Ασκήσεις</h2>
<p><strong>Άσκηση 5: Πάρτε τον ακόλουθο κώδικα Python που αποθηκεύει μια συμβολοσειρά:</strong></p>
<p><code>str = 'X-DSPAM-Confidence:</code><strong><code>0.8475</code></strong><code>'</code></p>
<p><strong>Χρησιμοποιήστε <code>find</code> και διαμέριση συμβολοσειράς για να εξαγάγετε το τμήμα της συμβολοσειράς μετά τον χαρακτήρα άνω και κάτω τελείας και στη συνέχεια χρησιμοποιήστε τη συνάρτηση <code>float</code> για να μετατρέψετε τη συμβολοσειρά που εξαγάγατε σε αριθμό κινητής υποδιαστολής.</strong></p>
<p> </p>
<p><strong>Άσκηση 6: Διαβάστε την τεκμηρίωση των μεθόδων συμβολοσειράς στο <a href="https://docs.python.org/library/stdtypes.html#string-methods" class="uri">https://docs.python.org/library/stdtypes.html#string-methods</a> Ίσως θελήσετε να πειραματιστείτε με μερικά από αυτά για να βεβαιωθείτε ότι καταλαβαίνετε πώς λειτουργούν. Τα <code>strip</code> και <code>replace</code> είναι ιδιαίτερα χρήσιμα.</strong></p>
<p><strong>Η τεκμηρίωση χρησιμοποιεί μια σύνταξη που μπορεί να προκαλεί σύγχυση. Για παράδειγμα, στο <code>find(sub[, start[, end]])</code>, οι αγκύλες υποδεικνύουν προαιρετικά ορίσματα. Επομένως, το <code>sub</code> απαιτείται, αλλά το <code>start</code> είναι προαιρετικό και εάν συμπεριλάβετε το <code>start</code>, τότε το <code>end</code> είναι προαιρετικό.</strong></p>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>Η πλειάδα είναι μια ακολουθία τιμών διαχωρισμένων με κόμμα μέσα σε ένα ζεύγος παρενθέσεων. Θα καλύψουμε τις πλειάδες στο Κεφάλαιο 10<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
</body>
</html>
<?php if ( file_exists("../bookfoot.php") ) {
  $HTML_FILE = basename(__FILE__);
  $HTML = ob_get_contents();
  ob_end_clean();
  require_once "../bookfoot.php";
}?>
