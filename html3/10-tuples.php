<?php if ( file_exists("../booktop.php") ) {
  require_once "../booktop.php";
  ob_start();
}?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Untitled</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
</head>
<body>
<h1 id="πλειάδες">Πλειάδες</h1>
<h2 id="οι-πλειάδες-είναι-αμετάβλητες">Οι πλειάδες είναι αμετάβλητες</h2>
<p>  </p>
<p>Μια πλειάδα<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a> είναι μια ακολουθία τιμών που μοιάζει πολύ με μια λίστα. Οι τιμές που είναι αποθηκευμένες σε μια πλειάδα μπορούν να είναι οποιουδήποτε τύπου και έχουν δείκτες ακέραιους αριθμούς. Η σημαντική διαφορά είναι ότι οι πλειάδες είναι <em>αμετάβλητες</em>. Οι πλειάδες είναι επίσης <em>συγκρίσιμες</em> και <em>κατακερματισμένες</em>, ώστε να μπορούμε να ταξινομήσουμε λίστες τους και να χρησιμοποιήσουμε πλειάδες ως κλειδιά - τιμές σε λεξικά της Python.</p>
<p>    </p>
<p>Συντακτικά, μια πλειάδα είναι μια λίστα τιμών διαχωρισμένη με κόμματα:</p>
<pre class="python"><code>&gt;&gt;&gt; t = &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;</code></pre>
<p>Αν και δεν είναι απαραίτητο, είναι σύνηθες να περικλείουμε τις πλειάδες σε παρενθέσεις, για να βοηθηθούμε στο να αναγνωρίσουμε γρήγορα τις πλειάδες, όταν κοιτάμε τον κώδικα Python:</p>
<p></p>
<pre class="python"><code>&gt;&gt;&gt; t = (&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;)</code></pre>
<p>Για να δημιουργήσετε μια πλειάδα με ένα μόνο στοιχείο, πρέπει να συμπεριλάβετε το τελικό κόμμα:</p>
<p> </p>
<pre class="python trinket"><code>&gt;&gt;&gt; t1 = (&#39;a&#39;,)
&gt;&gt;&gt; type(t1)
&lt;type &#39;tuple&#39;&gt;</code></pre>
<p>Χωρίς κόμμα, η Python αντιμετωπίζει το <code>('a')</code> ως έκφραση με μια συμβολοσειρά σε παρένθεση, που αποτιμάται σε μια συμβολοσειρά:</p>
<pre class="python"><code>&gt;&gt;&gt; t2 = (&#39;a&#39;)
&gt;&gt;&gt; type(t2)
&lt;type &#39;str&#39;&gt;</code></pre>
<p>Ένας άλλος τρόπος κατασκευής πλειάδας είναι η ενσωματωμένη συνάρτηση <code>tuple</code>. Χωρίς όρισμα, δημιουργεί μια κενή πλειάδα:</p>
<p> </p>
<pre class="python trinket"><code>&gt;&gt;&gt; t = tuple()
&gt;&gt;&gt; print(t)
()</code></pre>
<p>Εάν το όρισμα είναι μια ακολουθία (συμβολοσειρά, λίστα ή πλειάδα), το αποτέλεσμα της κλήσης της <code>tuple</code> είναι μια πλειάδα με τα στοιχεία της ακολουθίας:</p>
<pre class="python trinket"><code>&gt;&gt;&gt; t = tuple(&#39;lupins&#39;)
&gt;&gt;&gt; print(t)
(&#39;l&#39;, &#39;u&#39;, &#39;p&#39;, &#39;i&#39;, &#39;n&#39;, &#39;s&#39;)</code></pre>
<p>Επειδή το <code>tuple</code> είναι το όνομα ενός κατασκευαστή, θα πρέπει να αποφύγετε τη χρήση του ως όνομα μεταβλητής.</p>
<p>Οι περισσότεροι τελεστές λιστών λειτουργούν και σε πλειάδες. Ο τελεστής αγκύλης ευρετηριάζει ένα στοιχείο:</p>
<p> </p>
<pre class="python trinket"><code>&gt;&gt;&gt; t = (&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;)
&gt;&gt;&gt; print(t[0])
&#39;a&#39;</code></pre>
<p>Και ο τελεστής διαμέρισης επιλέγει μια σειρά στοιχείων.</p>
<p>   </p>
<pre class="python"><code>&gt;&gt;&gt; print(t[1:3])
(&#39;b&#39;, &#39;c&#39;)</code></pre>
<p>Αλλά αν προσπαθήσετε να τροποποιήσετε ένα από τα στοιχεία της πλειάδας, λαμβάνετε ένα σφάλμα:</p>
<p>   </p>
<pre class="python"><code>&gt;&gt;&gt; t[0] = &#39;A&#39;
TypeError: object doesn&#39;t support item assignment</code></pre>
<p>Δεν μπορείτε να τροποποιήσετε τα στοιχεία μιας πλειάδας, αλλά μπορείτε να αντικαταστήσετε μια πλειάδα με μια άλλη:</p>
<pre class="python trinket"><code>&gt;&gt;&gt; t = (&#39;A&#39;,) + t[1:]
&gt;&gt;&gt; print(t)
(&#39;A&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;)</code></pre>
<h2 id="σύγκριση-πλειάδων">Σύγκριση πλειάδων</h2>
<p>   </p>
<p>Οι τελεστές σύγκρισης λειτουργούν με πλειάδες και άλλες ακολουθίες. Η Python ξεκινά συγκρίνοντας το πρώτο στοιχείο από κάθε ακολουθία. Αν είναι ίσα, πηγαίνει στο επόμενο στοιχείο και ούτω καθεξής, μέχρι να βρει στοιχεία που διαφέρουν. Τα επόμενα στοιχεία δεν λαμβάνονται υπόψη (ακόμα και αν είναι πραγματικά μεγάλα).</p>
<pre class="python trinket"><code>&gt;&gt;&gt; (0, 1, 2) &lt; (0, 3, 4)
True
&gt;&gt;&gt; (0, 1, 2000000) &lt; (0, 3, 4)
True</code></pre>
<p>Η συνάρτηση <code>sort</code> λειτουργεί με τον ίδιο τρόπο. Ταξινομεί κυρίως κατά το πρώτο στοιχείο, αλλά στην περίπτωση ισοπαλίας, ταξινομεί κατά το δεύτερο στοιχείο και ούτω καθεξής.</p>
<p>Αυτό το χαρακτηριστικό προσφέρεται σε ένα μοτίβο που ονομάζεται <em>DSU</em> for</p>
<dl>
<dt>Decorate - Διακοσμώ</dt>
<dd>μια ακολουθία δημιουργώντας μια λίστα πλειάδων με ένα ή περισσότερα κλειδιά ταξινόμησης που προηγούνται των στοιχείων των πλειάδων,
</dd>
<dt>Sort - Ταξινομώ</dt>
<dd>τη λίστα των πλειάδων, χρησιμοποιώντας την ενσωματωμένη <code>sort</code> της Python και
</dd>
<dt>Undecorate - Αφαιρώ τη διακόσμηση</dt>
<dd>εξάγοντας τα ταξινομημένα στοιχεία της ακολουθίας.
</dd>
</dl>
<p>     </p>
<p>Για παράδειγμα, ας υποθέσουμε ότι έχετε μια λίστα λέξεων και θέλετε να τις ταξινομήσετε από αυτή με το μεγαλύτερο μήκος προς στη συντομότερη:</p>
<pre class="python"><code>κείμενο = &#39;but soft what light in yonder window breaks&#39;
λέξεις = κείμενο.split()
t = list()
for λέξη in λέξεις:
    t.append((len(λέξη), λέξη))

t.sort(reverse=True)

res = list()
for μήκος, λέξη in t:
    res.append(λέξη)

print(res)

# Code: http://www.py4e.com/code3/soft.py</code></pre>
<p>Ο πρώτος βρόχος δημιουργεί μια λίστα με πλειάδες, όπου κάθε πλειάδα είναι μια λέξη με προπορευόμενο το μήκος της.</p>
<p>Η <code>sort</code> συγκρίνει τα πρώτα στοιχεία των πλειάδων, το μήκος. Το όρισμα δεμευμένης λέξης <code>reverse=True</code> λέει στην <code>sort</code> να λειτουργήσει με φθίνουσα σειρά.</p>
<p>  </p>
<p>Ο δεύτερος βρόχος διασχίζει τη λίστα των πλειάδων και δημιουργεί μια λίστα λέξεων με φθίνουσα σειρά μήκους. Οι λέξεις των τεσσάρων χαρακτήρων ταξινομούνται με <em>αντίστροφη</em> αλφαβητική σειρά, επομένως το “what” εμφανίζεται πριν από το “soft” στην παρακάτω λίστα.</p>
<p>Η έξοδος του προγράμματος είναι η εξής:</p>
<pre class="{text}"><code>[&#39;yonder&#39;, &#39;window&#39;, &#39;breaks&#39;, &#39;light&#39;, &#39;what&#39;, &#39;soft&#39;, &#39;but&#39;, &#39;in&#39;]</code></pre>
<p>Φυσικά η γραμμή χάνει μεγάλο μέρος του ποιητικού της αντίκτυπου όταν μετατραπεί σε λίστα Python και ταξινομηθεί σε φθίνουσα σειρά μήκους λέξεων.</p>
<h2 id="εκχώρηση-τιμής-σε-πλειάδα">Εκχώρηση τιμής σε πλειάδα</h2>
<p>   </p>
<p>Ένα από τα μοναδικά συντακτικά χαρακτηριστικά της γλώσσας Python είναι η δυνατότητα να υπάρχει πλειάδα στην αριστερή πλευρά μιας δήλωσης ανάθεσης και μια ακολουθία τιμών στη δεξιά πλευρά. Αυτό σας επιτρέπει να αναθέσετε τιμή σε περισσότερες από μία μεταβλητές τη φορά, χρησιμοποιώντας τη δοθήσα ακολουθία.</p>
<p>Σε αυτό το παράδειγμα έχουμε μια λίστα δύο στοιχείων (η οποία είναι μια ακολουθία) και εκχωρούμε το πρώτο και το δεύτερο στοιχείο της ακολουθίας στις μεταβλητές <code>x</code> και <code>y</code> σε μία μόνο πρόταση.</p>
<pre class="python trinket"><code>&gt;&gt;&gt; m = [ &#39;have&#39;, &#39;fun&#39; ]
&gt;&gt;&gt; x, y = m
&gt;&gt;&gt; x
&#39;have&#39;
&gt;&gt;&gt; y
&#39;fun&#39;
&gt;&gt;&gt;</code></pre>
<pre><code>Δεν είναι μαγικό, η Python *χονδρικά* μεταφράζει τη σύνταξη της πολλαπλής
ανάθεσης ως εξής: ^[Η Python δεν μεταφράζει τη σύνταξη κυριολεκτικά. Για
παράδειγμα, εάν το δοκιμάσετε με ένα λεξικό, δεν θα λειτουργήσει όπως θα
περιμένατε.]</code></pre>
<pre class="python trinket"><code>&gt;&gt;&gt; m = [ &#39;have&#39;, &#39;fun&#39; ]
&gt;&gt;&gt; x = m[0]
&gt;&gt;&gt; y = m[1]
&gt;&gt;&gt; x
&#39;have&#39;
&gt;&gt;&gt; y
&#39;fun&#39;
&gt;&gt;&gt;</code></pre>
<p>Στυλιστικά, όταν χρησιμοποιούμε πλειάδα στο αριστερό μέλος της εντολής εκχώρησης, παραλείπουμε τις παρενθέσεις, αλλά το ακόλουθο αποτελεί μια εξίσου έγκυρη σύνταξη:</p>
<pre class="python"><code>&gt;&gt;&gt; m = [ &#39;have&#39;, &#39;fun&#39; ]
&gt;&gt;&gt; (x, y) = m
&gt;&gt;&gt; x
&#39;have&#39;
&gt;&gt;&gt; y
&#39;fun&#39;
&gt;&gt;&gt;</code></pre>
<p>Μια ιδιαίτερα έξυπνη εφαρμογή της εκχώρησης σε πλειάδα μας επιτρέπει να <em>αντιμεταθέσουμε</em> τις τιμές δύο μεταβλητών σε μια μόνο πρόταση:</p>
<pre class="python"><code>&gt;&gt;&gt; a, b = b, a</code></pre>
<p>Και στα δύο μέλη αυτής της εντολής έχουμε πλειάδες, αλλά στο αριστερό μέλος είναι μια πλειάδα μεταβλητών. Στο δεξί μέλος έχουμε μια πλειάδα εκφράσεων. Κάθε τιμή στο δεξί μέλος εκχωρείται στην αντίστοιχη μεταβλητή του αριστερού μέλους. Όλες οι εκφράσεις στη δεξιά πλευρά αξιολογούνται πριν από οποιαδήποτε από τις εκχωρήσεις.</p>
<p>Ο αριθμός των μεταβλητών στα αριστερά και ο αριθμός των τιμών στα δεξιά πρέπει να είναι ο ίδιος:</p>
<p> </p>
<pre class="python"><code>&gt;&gt;&gt; a, b = 1, 2, 3
ValueError: too many values to unpack</code></pre>
<p>Γενικότερα, στο δεξί μέλος μπορεί να υπάρχει κάθε είδους ακολουθία (συμβολοσειρά, λίστα ή πλειάδα). Για παράδειγμα, για να χωρίσετε μια διεύθυνση email σε όνομα χρήστη και τομέα, θα μπορούσατε να γράψετε:</p>
<p>   </p>
<pre class="python"><code>&gt;&gt;&gt; addr = &#39;monty@python.org&#39;
&gt;&gt;&gt; uname, domain = addr.split(&#39;@&#39;)</code></pre>
<p>Η επιστρεφόμενη τιμή από το <code>split</code> είναι μια λίστα με δύο στοιχεία. Το πρώτο στοιχείο εκχωρείται στο <code>uname</code>, το δεύτερο στο <code>domain</code>.</p>
<pre class="python"><code>&gt;&gt;&gt; print(uname)
monty
&gt;&gt;&gt; print(domain)
python.org</code></pre>
<h2 id="λεξικά-και-πλειάδες">Λεξικά και πλειάδες</h2>
<p>   </p>
<p>Τα λεξικά έχουν μια μέθοδο που ονομάζεται <code>items</code>, που επιστρέφει μια λίστα πλειάδων, όπου κάθε πλειάδα είναι ένα ζεύγος κλειδιού-τιμής:</p>
<pre class="python trinket"><code>&gt;&gt;&gt; d = {&#39;a&#39;:10, &#39;b&#39;:1, &#39;c&#39;:22}
&gt;&gt;&gt; t = list(d.items())
&gt;&gt;&gt; print(t)
[(&#39;b&#39;, 1), (&#39;a&#39;, 10), (&#39;c&#39;, 22)]</code></pre>
<p>Όπως θα έπρεπε να περιμένετε από ένα λεξικό, τα στοιχεία δεν είναι σε σειρά.</p>
<p>Ωστόσο, δεδομένου ότι η λίστα των πλειάδων είναι μια λίστα και οι πλειάδες είναι συγκρίσιμες, μπορούμε τώρα να ταξινομήσουμε τη λίστα των πλειάδων. Η μετατροπή ενός λεξικού σε λίστα πλειάδων είναι ένας τρόπος για να εξάγουμε τα περιεχόμενα ενός λεξικού ταξινομημένα κατά κλειδί:</p>
<pre class="python"><code>&gt;&gt;&gt; d = {&#39;a&#39;:10, &#39;b&#39;:1, &#39;c&#39;:22}
&gt;&gt;&gt; t = list(d.items())
&gt;&gt;&gt; t
[(&#39;b&#39;, 1), (&#39;a&#39;, 10), (&#39;c&#39;, 22)]
&gt;&gt;&gt; t.sort()
&gt;&gt;&gt; t
[(&#39;a&#39;, 10), (&#39;b&#39;, 1), (&#39;c&#39;, 22)]</code></pre>
<p>Η νέα λίστα ταξινομείται με αύξουσα αλφαβητική σειρά με βάση την τιμή κλειδιού.</p>
<h2 id="πολλαπλές-εκχωρήσεις-με-λεξικά">Πολλαπλές εκχωρήσεις με λεξικά</h2>
<p> </p>
<p>Συνδυάζοντας <code>items</code>, εκχώρηση σε πλειάδα και <code>for</code>, μπορείτε να δημιουργήσετε ένα ωραίο μοτίβο κώδικα για τη προσπέλαση των κλειδιών και των τιμών ενός λεξικού με έναν μόνο βρόχο:</p>
<pre class="python"><code>for κλειδί, τιμή in list(d.items()):
    print(τιμή, κλειδί)</code></pre>
<p>Αυτός ο βρόχος έχει δύο <em>μεταβλητές επανάληψης</em> επειδή το <code>items</code> επιστρέφει μια λίστα πλειάδων και το <code>key, val</code> είναι μια ανάθεση πλειάδας, που επαναλαμβάνεται διαδοχικά μέσω καθενός από τα ζεύγη κλειδιού-τιμής στο λεξικό.</p>
<p>Για κάθε επανάληψη του βρόχου, τόσο στο <code>key</code> όσο και στη <code>value</code> ανατίθεται το επόμενο ζεύγος κλειδιού-τιμής του λεξικό (με τη σειρά κατακερματισμού).</p>
<p>Η έξοδος αυτού του βρόχου είναι:</p>
<pre class="{text}"><code>10 a
22 c
1 b</code></pre>
<p>Και πάλι, είναι σε σειρά κατακερματισμού κλειδιών (δηλαδή, χωρίς συγκεκριμένη σειρά).</p>
<p>Εάν συνδυάσουμε αυτές τις δύο τεχνικές, μπορούμε να εκτυπώσουμε τα περιεχόμενα ενός λεξικού ταξινομημένα με βάση την <em>τιμή</em> που είναι αποθηκευμένη σε κάθε ζεύγος κλειδιού-τιμής.</p>
<p>Για να γίνει αυτό, φτιάχνουμε πρώτα μια λίστα με πλειάδες, όπου κάθε πλειάδα είναι <code>(value, key)</code>. Η μέθοδος <code>items</code> θα μας έδινε μια λίστα με πλειάδες <code>(key, value)</code>, αλλά αυτή τη φορά θέλουμε να ταξινομήσουμε κατά τιμή και όχι κατά κλειδί. Αφού δημιουργήσουμε τη λίστα με τις πλειάδες της τιμής - κλειδιού, είναι απλό να ταξινομήσουμε τη λίστα με αντίστροφη σειρά και να εκτυπώσουμε τη νέα, ταξινομημένη λίστα.</p>
<pre class="python"><code>&gt;&gt;&gt; d = {&#39;a&#39;:10, &#39;b&#39;:1, &#39;c&#39;:22}
&gt;&gt;&gt; l = list()
&gt;&gt;&gt; for key, val in d.items() :
...     l.append( (val, key) )
...
&gt;&gt;&gt; l
[(10, &#39;a&#39;), (22, &#39;c&#39;), (1, &#39;b&#39;)]
&gt;&gt;&gt; l.sort(reverse=True)
&gt;&gt;&gt; l
[(22, &#39;c&#39;), (10, &#39;a&#39;), (1, &#39;b&#39;)]
&gt;&gt;&gt;</code></pre>
<p>Κατασκευάζοντας προσεκτικά τη λίστα των πλειάδων ώστε να έχει την τιμή ως το πρώτο στοιχείο κάθε πλειάδας, μπορούμε να ταξινομήσουμε τη λίστα των πλειάδων και να πάρουμε τα περιεχόμενα του λεξικού μας ταξινομημένα κατά τιμή.</p>
<p>Οι πιο συνηθισμένες λέξεις</p>
<h2 id="the-most-common-words">The most common words</h2>
<p> </p>
<p>Επιστρέφοντας στο προηγούμενο παράδειγμα του κειμένου από το <em>Ρωμαίος και Ιουλιέτα</em> Πράξη 2, Σκηνή 2, μπορούμε να επεκτείνουμε το πρόγραμμά μας για να χρησιμοποιήσουμε αυτήν την τεχνική για να εκτυπώσουμε τις δέκα πιο συνηθισμένες λέξεις στο κείμενο ως εξής:</p>
<pre class="python"><code>import string
fhand = open(&#39;romeo-full.txt&#39;)
πλήθη = dict()
for γραμμή in fhand:
    γραμμή = γραμμή.translate(str.maketrans(&#39;&#39;, &#39;&#39;, string.punctuation))
    γραμμή = γραμμή.lower()
    λέξεις = γραμμή.split()
    for λέξη in λέξεις:
        if λέξη not in πλήθη:
            πλήθη[λέξη] = 1
        else:
            πλήθη[λέξη] += 1

# Sort the dictionary by value
λίστα = list()
for κλειδί, τιμή in list(πλήθη.items()):
    λίστα.append((τιμή, κλειδί))

λίστα.sort(reverse=True)

for κλειδί, τιμή in λίστα[:10]:
    print(κλειδί, τιμή)

# Code: http://www.py4e.com/code3/count3.py</code></pre>

<p>Το πρώτο μέρος του προγράμματος που διαβάζει το αρχείο και δημιουργεί το λεξικό, που αντιστοιχίζει κάθε λέξη με το πλήθος εμφάνισης των λέξεων στο έγγραφο, δεν έχει αλλάξει. Αλλά, αντί να εκτυπώνουμε απλώς το <code>πληθη</code> και να τερματίζουμε το πρόγραμμα, κατασκευάζουμε μια λίστα με πλειάδες <code>(τιμή, κλειδί)</code> και στη συνέχεια ταξινομούμε τη λίστα με αντίστροφη σειρά.</p>
<p>Από τη στιγμή που η τιμή είναι πρώτη, θα χρησιμοποιηθεί για τις συγκρίσεις. Εάν υπάρχουν περισσότερες από μία πλειάδες με την ίδια τιμή, θα κοιτάξει το δεύτερο στοιχείο (το κλειδί), επομένως οι πλειάδες των οποίων η τιμή είναι ίδια θα ταξινομηθούν περαιτέρω σε αλφαβητική σειρά του κλειδιού.</p>
<p>Στο τέλος γράφουμε έναν ωραίο βρόχο <code>for</code> που κάνει μια επανάληψη πολλαπλής εκχώρησης και εκτυπώνει τις δέκα πιο συνηθισμένες λέξεις, διατρέχοντας ένα τμήμα της λίστας (<code>lst[:10]</code>).</p>
<p>Έτσι τώρα η έξοδος μοιάζει, τελικά, με αυτό που θέλαμε για την ανάλυση συχνότητας λέξεων.</p>
<pre class="{text}"><code>61 i
42 and
40 romeo
34 to
34 the
32 thou
32 juliet
30 that
29 my
24 thee</code></pre>
<p>Το γεγονός ότι αυτή η περίπλοκη ανάλυση δεδομένων μπορεί να γίνει με ένα εύκολο στην κατανόηση πρόγραμμα Python, 19 γραμμών, είναι ένας λόγος για τον οποίο η Python είναι μια καλή επιλογή ως γλώσσα για την εξερεύνηση πληροφοριών.</p>
<h2 id="χρήση-πλειάδων-ως-κλειδιών-στα-λεξικά">Χρήση πλειάδων ως κλειδιών στα λεξικά</h2>
<p>  </p>
<p>Επειδή οι πλειάδες είναι <em>κατακερματίσιμες</em> και οι λίστες όχι, αν θέλουμε να δημιουργήσουμε ένα <em>σύνθετο</em> κλειδί για χρήση σε ένα λεξικό, πρέπει να χρησιμοποιήσουμε ως κλειδί μια πλειάδα.</p>
<p>Θα χρειαζόμασταν ένα σύνθετο κλειδί εάν θέλαμε να δημιουργήσουμε έναν τηλεφωνικό κατάλογο, που αντιστοιχίζει ζεύγη επωνύμων, ονομάτων σε αριθμούς τηλεφώνου. Υποθέτοντας ότι έχουμε ορίσει τις μεταβλητές <code>επώνυμο</code>, <code>όνομα</code> και <code>αριθμός</code>, θα μπορούσαμε να γράψουμε μια εντολή εκχώρησης στο λεξικό ως εξής:</p>
<pre class="python"><code>ευρετήριο[επώνυμο,όνομα] = αριθμός</code></pre>
<p>Η έκφραση μέσα στις αγκύλες είναι πλειάδα. Θα μπορούσαμε να χρησιμοποιήσουμε την ανάθεση πλειάδας σε έναν βρόχο <code>for</code>, για να διασχίσουμε αυτό το λεξικό.</p>
<p></p>
<pre class="python"><code>for επώνυμο, όνομα in ευρετήριο:
    print(όνομα, επώνυμο, ευρετήριο[επώνυμο,όνομα])</code></pre>
<p>Αυτός ο βρόχος διασχίζει τα κλειδιά στο <code>ευρετήριο</code>, τα οποία είναι πλειάδες. Εκχωρεί τα στοιχεία κάθε πλειάδας στα <code>επώνυμο</code> και <code>όνομα</code> και στη συνέχεια εκτυπώνει το όνομα και τον αντίστοιχο αριθμό τηλεφώνου.</p>
<h2 id="ακολουθίες-συμβολοσειρές-λίστες-και-πλειάδες---oh-my">Ακολουθίες: συμβολοσειρές, λίστες και πλειάδες (- Oh My!)</h2>
<p></p>
<p>Έχω επικεντρωθεί σε λίστες πλειάδων, αλλά σχεδόν όλα τα παραδείγματα σε αυτό το κεφάλαιο λειτουργούν επίσης με λίστες λιστών, πλειάδες πλειάδων και πλειάδες λιστών. Για να αποφευχθεί η απαρίθμηση των πιθανών συνδυασμών, μερικές φορές είναι πιο εύκολο να μιλάμε για ακολουθίες ακολουθιών.</p>
<p>Σε πολλά περιβάλλοντα, τα διαφορετικά είδη ακολουθιών (συμβολοσειρές, λίστες και πλειάδες) μπορούν να χρησιμοποιηθούν εναλλακτικά. Λοιπόν, πώς και γιατί επιλέγετε κάποιο αντί του άλλου ;</p>
<p>    </p>
<p>Για να ξεκινήσουμε με το προφανές, οι συμβολοσειρές είναι πιο περιορισμένες από τις άλλες ακολουθίες, επειδή τα στοιχεία πρέπει να είναι χαρακτήρες. Είναι επίσης αμετάβλητες. Εάν χρειάζεστε τη δυνατότητα να αλλάξετε τους χαρακτήρες μιας συμβολοσειράς (αντί για τη δημιουργία μιας νέας συμβολοσειράς), ίσως θελήσετε να χρησιμοποιήσετε μια λίστα χαρακτήρων.</p>
<p>Οι λίστες είναι πιο συχνά σρησιμοποιούμενες από τις πλειάδες, κυρίως επειδή είναι μεταβλητές. Αλλά υπάρχουν μερικές περιπτώσεις όπου μπορεί να προτιμήσετε τις πλειάδες:</p>
<ol type="1">
<li><p>Σε ορισμένες περιπτώσεις, όπως μια δήλωση <code>return</code>, είναι συντακτικά πιο απλό να δημιουργήσετε μια πλειάδα παρά μια λίστα. Σε άλλες περιπτώσεις, μπορεί να προτιμήσετε μια λίστα.</p></li>
<li><p>Εάν θέλετε να χρησιμοποιήσετε μια ακολουθία ως κλειδί λεξικού, πρέπει να χρησιμοποιήσετε έναν αμετάβλητο τύπο όπως πλειάδα ή συμβολοσειρά.</p></li>
<li><p>Εάν μεταβιβάζετε μια ακολουθία ως όρισμα σε μια συνάρτηση, η χρήση πλειάδων μειώνει την πιθανότητα απροσδόκητης συμπεριφοράς λόγω ψευδωνυμίας.</p></li>
</ol>
<p>Επειδή οι πλειάδες είναι αμετάβλητες, δεν παρέχουν μεθόδους όπως <code>sort</code> και <code>reverse</code>, οι οποίες τροποποιούν τις υπάρχουσες λίστες. Ωστόσο, η Python παρέχει τις ενσωματωμένες συναρτήσεις <code>sorted</code> και <code>reversed</code>, οι οποίες λαμβάνουν οποιαδήποτε ακολουθία ως παράμετρο και επιστρέφουν μια νέα ακολουθία με τα ίδια στοιχεία με διαφορετική σειρά.</p>
<p>   </p>
<h2 id="list-comprehension-κατανόηση-λίστας">List comprehension (Κατανόηση λίστας)</h2>
<p>Μερικές φορές θέλετε να δημιουργήσετε μια ακολουθία χρησιμοποιώντας δεδομένα από μια άλλη ακολουθία. Μπορείτε να το πετύχετε γράφοντας έναν βρόχο for και προσαρτώντας ένα στοιχείο κάθε φορά. Για παράδειγμα, αν θέλατε να μετατρέψετε μια λίστα συμβολοσειρών – κάθε συμβολοσειρά αποθηκεύει ψηφία – σε αριθμούς που μπορείτε να αθροίσετε, θα γράφατε:</p>
<pre class="python"><code>list_of_ints_in_strings = [&#39;42&#39;, &#39;65&#39;, &#39;12&#39;]
list_of_ints = []
for x in list_of_ints_in_strings:
    list_of_ints.append(int(x))

print(sum(list_of_ints))</code></pre>
<p>Με την list comprehension, ο παραπάνω κώδικας μπορεί να γραφτεί με πιο συμπαγή τρόπο:</p>
<pre class="python"><code>list_of_ints_in_strings = [&#39;42&#39;, &#39;65&#39;, &#39;12&#39;]
list_of_ints = [ int(x) for x in list_of_ints_in_strings ]
print(sum(list_of_ints))</code></pre>
<p></p>
<h2 id="εκσφαλμάτωση">Εκσφαλμάτωση</h2>
<p>    </p>
<p>Οι λίστες, τα λεξικά και οι πλειάδες είναι γνωστά γενικά ως <em>δομές δεδομένων</em>. Σε αυτό το κεφάλαιο αρχίζουμε να βλέπουμε σύνθετες δομές δεδομένων, όπως λίστες πλειάδων και λεξικά που περιέχουν πλειάδες ως κλειδιά και λίστες ως τιμές. Οι σύνθετες δομές δεδομένων είναι χρήσιμες, αλλά είναι επιρρεπείς σε αυτό που αποκαλώ <em>σφάλματα σχήματος</em>. Δηλαδή, σφάλματα που προκαλούνται όταν μια δομή δεδομένων έχει λάθος τύπο, μέγεθος ή σύνθεση ή ίσως γράψετε κάποιον κώδικα και ξεχάσετε το σχήμα των δεδομένων σας και προκαλέσετε ένα σφάλμα. Για παράδειγμα, αν περιμένετε μια λίστα με έναν ακέραιο και σας δώσω έναν απλό ακέραιο (όχι σε λίστα), δεν θα λειτουργήσει.</p>
<h2 id="γλωσσάριο">Γλωσσάριο</h2>
<dl>
<dt>DSU</dt>
<dd>Συντομογραφία του “decorate-sort-undecorate”, ένα μοτίβο που περιλαμβάνει τη δημιουργία μιας λίστας πλειάδων, την ταξινόμηση και την εξαγωγή μέρους του αποτελέσματος.
</dd>
<dt>gather</dt>
<dd>Η λειτουργία της συναρμολόγησης μιας πλειάδας ορίσματος μεταβλητού μήκους.
</dd>
<dt>scatter</dt>
<dd>Η λειτουργία της αντιμετώπισης μιας ακολουθίας ως λίστας ορισμάτων.
</dd>
<dt>singleton - μεμονωμένο</dt>
<dd>Μια λίστα (ή άλλη ακολουθία) με ένα μόνο στοιχείο.
</dd>
<dt>δομή δεδομένων</dt>
<dd>Μια συλλογή σχετικών τιμών, συχνά οργανωμένη σε λίστες, λεξικά, πλειάδες κ.λπ.
</dd>
<dt>κατακερματιζόμενος - hashable</dt>
<dd>Ένας τύπος που έχει συνάρτηση κατακερματισμού. Οι αμετάβλητοι τύποι όπως ακέραιοι, κινητής υποδιαστολής (float) και συμβολοσειρές μπορούν να κατακερματιστούν, μεταβλητοί τύποι όπως λίστες και λεξικά όχι.
</dd>
<dt>πλειάδα</dt>
<dd>Μια αμετάβλητη ακολουθία στοιχείων.
</dd>
<dt>πλειάδα σε ανάθεση</dt>
<dd>Μια εκχώρηση με μια ακολουθία στο δεξί μέλος και μια πλειάδα μεταβλητών στο αριστερό. Το δεξί μέλος αξιολογείται και στη συνέχεια τα στοιχεία του αντιστοιχίζονται στις μεταβλητές στα αριστερά.
</dd>
<dt>συγκρίσιμος</dt>
<dd>Ένας τύπος όπου μια τιμή μπορεί να ελεγχθεί για να διαπιστωθεί εάν είναι μεγαλύτερη από, μικρότερη από ή ίση με μια άλλη τιμή του ίδιου τύπου. Οι τύποι που είναι συγκρίσιμοι μπορούν να τοποθετηθούν σε μια λίστα και να ταξινομηθούν.
</dd>
<dt>σχήμα (μιας δομής δεδομένων) - shape</dt>
<dd>Σύνοψη του τύπου, του μεγέθους και της σύνθεσης μιας δομής δεδομένων.
</dd>
</dl>
<h2 id="ασκήσεις">Ασκήσεις</h2>
<p><strong>Άσκηση 1: Αναθεωρήστε ένα προηγούμενο πρόγραμμα ως εξής: Διαβάστε και αναλύστε τις γραμμές “From” και ανακτήστε τις διευθύνσεις από την κάθε γραμμή. Μετρήστε τον αριθμό των μηνυμάτων από κάθε άτομο χρησιμοποιώντας ένα λεξικό.</strong></p>
<p>** Αφού διαβάσετε όλα τα δεδομένα, δημιουργήστε μια λίστα με πλειάδες (πλήθος, email) από το λεξικό. Στη συνέχεια, ταξινομήστε τη λίστα με αντίστροφη σειρά και εκτυπώστε το άτομο με τα περισσότερα μηνύματα.**</p>
<pre class="{text}"><code>Δείγμα γραμμής:
From stephen.marquard@uct.ac.za Sat Jan  5 09:14:16 2008

Εισαγάγετε ένα όνομα αρχείου: mbox-short.txt
cwen@iupui.edu 5

Εισαγάγετε ένα όνομα αρχείου: mbox.txt
zqian@umich.edu 195</code></pre>
<p><strong>Άσκηση 2: Αυτό το πρόγραμμα μετράει την κατανομή της ώρας της ημέρας για κάθε ένα από τα μηνύματα. Μπορείτε να τραβήξετε την ώρα από τη γραμμή “From”, βρίσκοντας τη συμβολοσειρά χρόνου και, στη συνέχεια, χωρίζοντας τη συμβολοσειρά σε μέρη, χρησιμοποιώντας τον χαρακτήρα άνω και κάτω τελείας. Αφού υπολογίσετε τα πλήθη για κάθε ώρα, εκτυπώστε τα, ένα ανά γραμμή, ταξινομημένα ανά ώρα, όπως φαίνεται παρακάτω.</strong></p>
<pre class="{text}"><code>python timeofday.py
Εισαγάγετε ένα όνομα αρχείου: mbox-short.txt
04 3
06 1
07 1
09 2
10 3
11 6
14 1
15 2
16 4
17 2
18 1
19 1</code></pre>
<p><strong>Άσκηση 3: Γράψτε ένα πρόγραμμα που διαβάζει ένα αρχείο και τυπώνει τα <em>γράμματα</em> με φθίνουσα σειρά συχνότητας. Το πρόγραμμά σας θα πρέπει να μετατρέψει όλη την είσοδο σε πεζά και να μετράει μόνο τα γράμματα a-z. Το πρόγραμμά σας δεν πρέπει να μετράει κενά, ψηφία, σημεία στίξης ή οτιδήποτε άλλο εκτός από τα γράμματα a-z. Βρείτε δείγματα κειμένου από πολλές διαφορετικές γλώσσες και δείτε πώς η συχνότητα των γραμμάτων ποικίλλει μεταξύ των γλωσσών. Συγκρίνετε τα αποτελέσματά σας με τους πίνακες στο <a href="https://wikipedia.org/wiki/Letter_frequencies" class="uri">https://wikipedia.org/wiki/Letter_frequencies</a>.</strong></p>
<p> </p>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>Ενδιαφέρουσα πληροφορία: Η λέξη “tuple (πλειάδα)” προέρχεται από τα ονόματα που δίνονται σε ακολουθίες αριθμών διαφορετικού μήκους: μονή, διπλή, τριπλή, τετραπλή, πενταπλή (quintuple), εξάπλη (sextuple), επταπλή (septuple), κ.λπ.<a href="#fnref1" class="footnote-back">↩</a></p></li>
</ol>
</section>
</body>
</html>
<?php if ( file_exists("../bookfoot.php") ) {
  $HTML_FILE = basename(__FILE__);
  $HTML = ob_get_contents();
  ob_end_clean();
  require_once "../bookfoot.php";
}?>
