<?php if ( file_exists("../booktop.php") ) {
  require_once "../booktop.php";
  ob_start();
}?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>-</title>
  <style>
    html {
      line-height: 1.5;
      font-family: Georgia, serif;
      font-size: 20px;
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 1em;
      }
    }
    @media print {
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, 'Lucida Console', Consolas, monospace;
      font-size: 85%;
      margin: 0;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<h1 id="λίστες">Λίστες</h1>
<p>   </p>
<h2 id="μια-λίστα-είναι-μια-ακολουθία">Μια λίστα είναι μια ακολουθία</h2>
<p>Όπως και μια συμβολοσειρά, μια <em>list</em> είναι μια ακολουθία τιμών. Σε μια συμβολοσειρά, οι τιμές είναι χαρακτήρες ενώ σε μια λίστα, μπορούν να είναι οποιουδήποτε τύπου. Οι τιμές στη λίστα ονομάζονται <em>στοιχεία</em> (<em>elements</em> ή μερικές φορές <em>items</em>).</p>
<p>   </p>
<p>Υπάρχουν διάφοροι τρόποι για να δημιουργήσετε μια νέα λίστα. Ο πιο απλός είναι να περικλείσετε τα στοιχεία σε αγκύλες (“[” και ”]”):</p>
<pre class="python"><code>[10, 20, 30, 40]
[&#39;crunchy frog&#39;, &#39;ram bladder&#39;, &#39;lark vomit&#39;]</code></pre>
<p>Το πρώτο παράδειγμα είναι μια λίστα τεσσάρων ακεραίων αριθμών. Η δεύτερη είναι μια λίστα τριών συμβολοσειρών. Τα στοιχεία μιας λίστας δεν χρειάζεται να είναι του ίδιου τύπου. Η ακόλουθη λίστα περιέχει μια συμβολοσειρά, ένα δεκαδικό, έναν ακέραιο, και (ορίστε!) μια νέα λίστα:</p>
<pre class="python"><code>[&#39;spam&#39;, 2.0, 5, [10, 20]]</code></pre>
<p>Μια λίστα σε μια άλλη λίστα είναι <em>εμφωλευμένη</em>.</p>
<p> </p>
<p>Μια λίστα που δεν περιέχει στοιχεία ονομάζεται κενή λίστα. Μπορείτε να δημιουργήσετε μία με κενές αγκύλες, <code>[]</code>.</p>
<p> </p>
<p>Όπως θα περίμενε κανείς, μπορείτε να εκχωρήσετε τιμές λίστας σε μεταβλητές:</p>
<pre class="python trinket"><code>&gt;&gt;&gt; τυριά = [&#39;Cheddar&#39;, &#39;Edam&#39;, &#39;Gouda&#39;]
&gt;&gt;&gt; αριθμοί = [17, 123]
&gt;&gt;&gt; κενή = []
&gt;&gt;&gt; print(τυριά, αριθμοί, κενή)
[&#39;Cheddar&#39;, &#39;Edam&#39;, &#39;Gouda&#39;] [17, 123] []</code></pre>
<p></p>
<h2 id="οι-λίστες-είναι-μεταβαλόμενες">Οι λίστες είναι μεταβαλόμενες</h2>
<p>    </p>
<p>Η σύνταξη, για την πρόσβαση στα στοιχεία μιας λίστας, είναι η ίδια με αυτήν της πρόσβασης στους χαρακτήρες μιας συμβολοσειράς: ο τελεστής αγκύλης. Η έκφραση μέσα στις αγκύλες καθορίζει το δείκτη. Θυμηθείτε ότι οι δείκτες ξεκινούν από το 0:</p>
<pre class="python"><code>&gt;&gt;&gt; print(τυριά[0])
Cheddar</code></pre>
<p>Σε αντίθεση με τις συμβολοσειρές, οι λίστες είναι μεταβλητές, μπορείτε δηλαδή να αλλάξετε τη σειρά των στοιχείων μιας λίστας ή να εκχωρήσετε εκ νέου ένα στοιχείο σε μια λίστα. Όταν ο τελεστής αγκύλης εμφανίζεται στην αριστερή πλευρά μιας ανάθεσης, προσδιορίζει το στοιχείο της λίστας που θα τροποποιηθεί.</p>
<p> </p>
<pre class="python trinket"><code>&gt;&gt;&gt; numbers = [17, 123]
&gt;&gt;&gt; numbers[1] = 5
&gt;&gt;&gt; print(numbers)
[17, 5]</code></pre>
<p>Το στοιχείο στη θέση ένα της <code>numbers</code>, που ήταν 123, είναι τώρα 5.</p>
<p> </p>
<p>Μπορείτε να σκεφτείτε μια λίστα ως μια σχέση μεταξύ δεικτών και στοιχείων. Αυτή η σχέση ονομάζεται <em>χαρτογράφηση (mapping)</em>. Κάθε δείκτης “αντιστοιχίζεται” σε ένα από τα στοιχεία.</p>
<p> </p>
<p>Οι δείκτες λιστών λειτουργούν με τον ίδιο τρόπο όπως οι δείκτες συμβολοσειρών:</p>
<ul>
<li><p>Οποιαδήποτε ακέραια έκφραση μπορεί να χρησιμοποιηθεί ως ευρετήριο.</p></li>
<li><p>Εάν προσπαθήσετε να διαβάσετε ή να γράψετε ένα στοιχείο που δεν υπάρχει, λαμβάνετε ένα <code>IndexError</code>.</p></li>
</ul>
<p> </p>
<ul>
<li>Εάν ένας δείκτης έχει αρνητική τιμή, μετράει αντίστροφα από το τέλος της λίστας.</li>
</ul>
<p>    </p>
<p>Ο τελεστής <code>in</code> λειτουργεί και σε λίστες.</p>
<pre class="python trinket"><code>&gt;&gt;&gt; τυριά = [&#39;Cheddar&#39;, &#39;Edam&#39;, &#39;Gouda&#39;]
&gt;&gt;&gt; &#39;Edam&#39; in τυριά
True
&gt;&gt;&gt; &#39;Brie&#39; in τυριά
False</code></pre>
<h2 id="διάσχιση-λίστα">Διάσχιση λίστα</h2>
<p>    </p>
<p>Ο πιο συνηθισμένος τρόπος για να διασχίσετε τα στοιχεία μιας λίστας είναι με έναν βρόχο <code>for</code>. Η σύνταξη είναι η ίδια με τις συμβολοσειρές:</p>
<pre class="python"><code>for τυρί in τυριά:
    print(τυρί)</code></pre>
<p>Αυτή η μορφή λειτουργεί καλά εάν χρειάζεται μόνο να διαβάσετε τα στοιχεία της λίστας. Αλλά αν θέλετε να γράψετε ή να ενημερώσετε τα στοιχεία, χρειάζεστε τους δείκτες. Ένας συνηθισμένος τρόπος για να γίνει αυτό είναι ο συνδυασμός των συναρτήσεων <code>range</code> και <code>len</code>:</p>
<p> </p>
<pre class="python"><code>for i in range(len(αριθμοί)):
    αριθμοί[i] = αριθμοί[i] * 2</code></pre>
<p>Αυτός ο βρόχος διασχίζει τη λίστα και ενημερώνει κάθε στοιχείο. Το <code>len</code> επιστρέφει το πλήθος των στοιχείων της λίστας. Το <code>range</code> επιστρέφει μια λίστα δεικτών από 0 έως <span class="math inline"><em>n</em> − 1</span>, όπου το <span class="math inline"><em>n</em></span> είναι το μήκος της λίστας. Κάθε φορά μέσω του βρόχου, το <code>i</code> λαμβάνει τον δείκτη του επόμενου στοιχείου. Η δήλωση ανάθεσης στο σώμα χρησιμοποιεί το <code>i</code> για να διαβάσει την παλιά τιμή του στοιχείου και να εκχωρήσει τη νέα τιμή.</p>
<p> </p>
<p>Ένας βρόχος <code>for</code> σε μια κενή λίστα δεν εκτελεί ποτέ το σώμα:</p>
<pre class="python"><code>for x in κενή:
    print(&#39;Αυτό δεν εκτελείται ποτέ.&#39;)</code></pre>
<p>Αν και μια λίστα μπορεί να περιέχει μια άλλη λίστα, η ένθετη λίστα εξακολουθεί να υπολογίζεται ως ένα μεμονωμένο στοιχείο. Το μήκος της λίστας, στο παρακάτω παράδειγμα, είναι τέσσερα:</p>
<p> </p>
<pre class="python"><code>[&#39;spam&#39;, 1, [&#39;Brie&#39;, &#39;Roquefort&#39;, &#39;Pol le Veq&#39;], [1, 2, 3]]</code></pre>
<h2 id="λειτουργίες-λίστας">Λειτουργίες λίστας</h2>
<p></p>
<p>Ο τελεστής <code>+</code> συνενώνει λίστες:</p>
<p> </p>
<pre class="python trinket"><code>&gt;&gt;&gt; a = [1, 2, 3]
&gt;&gt;&gt; b = [4, 5, 6]
&gt;&gt;&gt; c = a + b
&gt;&gt;&gt; print(c)
[1, 2, 3, 4, 5, 6]</code></pre>
<p>Ομοίως, ο τελεστής <code>*</code> επαναλαμβάνει μια λίστα πολλές φορές:</p>
<p> </p>
<pre class="python trinket"><code>&gt;&gt;&gt; [0] * 4
[0, 0, 0, 0]
&gt;&gt;&gt; [1, 2, 3] * 3
[1, 2, 3, 1, 2, 3, 1, 2, 3]</code></pre>
<p>Το πρώτο παράδειγμα επαναλαμβάνεται την πρώτη λίστα τέσσερις φορές και το δεύτερο τρεις φορές.</p>
<h2 id="διαμέριση-λίστας">Διαμέριση λίστας</h2>
<p>    </p>
<p>Ο τελεστής διαμέρισης λειτουργεί και σε λίστες:</p>
<pre class="python trinket"><code>&gt;&gt;&gt; t = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;]
&gt;&gt;&gt; t[1:3]
[&#39;b&#39;, &#39;c&#39;]
&gt;&gt;&gt; t[:4]
[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;]
&gt;&gt;&gt; t[3:]
[&#39;d&#39;, &#39;e&#39;, &#39;f&#39;]</code></pre>
<p>Εάν παραλείψετε τον πρώτο δείκτη, το τμήμα ξεκινά από την αρχή της λίστας. Αν παραλείψετε τον δεύτερο, το τμήμα φτάνει μέχρι το τέλος της λίστας. Έτσι, εαν παραλείψετε και τους δύο, το τμήμα είναι αντίγραφο ολόκληρης της λίστας.</p>
<p>  </p>
<pre class="python"><code>&gt;&gt;&gt; t[:]
[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;]</code></pre>
<p>Δεδομένου ότι οι λίστες είναι μεταβαλλόμενες, είναι συχνά χρήσιμο να δημιουργείτε ένα αντίγραφο πριν εκτελέσετε λειτουργίες που “ανακατεύουν”, “σπάνε” ή τροποποιούν τις λίστες.</p>
<p></p>
<p>Ένας τελεστής διαμέρισης στο αριστερό μέλος μιας ανάθεσης μπορεί να ενημερώσει πολλά στοιχεία ταυτόχρονα:</p>
<p> </p>
<pre class="python trinket"><code>&gt;&gt;&gt; t = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;]
&gt;&gt;&gt; t[1:3] = [&#39;x&#39;, &#39;y&#39;]
&gt;&gt;&gt; print(t)
[&#39;a&#39;, &#39;x&#39;, &#39;y&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;]</code></pre>
<h2 id="μέθοδοι-λίστας">Μέθοδοι λίστας</h2>
<p> </p>
<p>Η Python παρέχει μεθόδους που λειτουργούν σε λίστες. Για παράδειγμα, η <code>append</code> προσθέτει ένα νέο στοιχείο στο τέλος μιας λίστας:</p>
<p> </p>
<pre class="python trinket"><code>&gt;&gt;&gt; t = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]
&gt;&gt;&gt; t.append(&#39;d&#39;)
&gt;&gt;&gt; print(t)
[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;]</code></pre>
<p>Η <code>extend</code> παίρνει μια λίστα ως όρισμα και προσθέτει όλα τα στοιχεία της στην λίστα στην οποία εφαρμόστηκε:</p>
<p> </p>
<pre class="python trinket"><code>&gt;&gt;&gt; t1 = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]
&gt;&gt;&gt; t2 = [&#39;d&#39;, &#39;e&#39;]
&gt;&gt;&gt; t1.extend(t2)
&gt;&gt;&gt; print(t1)
[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;]</code></pre>
<p>Αυτό το παράδειγμα δεν τροποποιεί το <code>t2</code>.</p>
<p>Η <code>sort</code> ταξινομεί τα στοιχεία της λίστας από το μικρότερο προς το μεγαλύτερο:</p>
<p> </p>
<pre class="python trinket"><code>&gt;&gt;&gt; t = [&#39;d&#39;, &#39;c&#39;, &#39;e&#39;, &#39;b&#39;, &#39;a&#39;]
&gt;&gt;&gt; t.sort()
&gt;&gt;&gt; print(t)
[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;]</code></pre>
<p>Οι περισσότερες μέθοδοι λίστας είναι κενές. Τροποποιούν τη λίστα και επιστρέφουν <code>None</code>. Αν κατά λάθος γράψετε <code>t = t.sort()</code>, θα απογοητευτείτε με το αποτέλεσμα.</p>
<p>   </p>
<h2 id="διαγραφή-στοιχείων">Διαγραφή στοιχείων</h2>
<p> </p>
<p>Υπάρχουν διάφοροι τρόποι για να διαγράψετε στοιχεία από μια λίστα. Εάν γνωρίζετε το ευρετήριο του στοιχείου που θέλετε ν διαγράψετε, μπορείτε να χρησιμοποιήσετε την <code>pop</code>:</p>
<p> </p>
<pre class="python trinket"><code>&gt;&gt;&gt; t = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]
&gt;&gt;&gt; x = t.pop(1)
&gt;&gt;&gt; print(t)
[&#39;a&#39;, &#39;c&#39;]
&gt;&gt;&gt; print(x)
b</code></pre>
<p>Η <code>pop</code> τροποποιεί τη λίστα και επιστρέφει το στοιχείο που αφαιρέθηκε. Εάν δεν δώσετε κάποιον δείκτη, διαγράφει και επιστρέφει το τελευταίο στοιχείο.</p>
<p>Εάν δεν χρειάζεστε την καταργημένη τιμή, μπορείτε να χρησιμοποιήσετε την εντολή <code>del</code>:</p>
<p> </p>
<pre class="python trinket"><code>&gt;&gt;&gt; t = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]
&gt;&gt;&gt; del t[1]
&gt;&gt;&gt; print(t)
[&#39;a&#39;, &#39;c&#39;]</code></pre>
<p>Εάν γνωρίζετε το στοιχείο που θέλετε να αφαιρέσετε (αλλά όχι το δείκτη του), μπορείτε να χρησιμοποιήσετε το <code>remove</code>:</p>
<p> </p>
<pre class="python trinket"><code>&gt;&gt;&gt; t = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]
&gt;&gt;&gt; t.remove(&#39;b&#39;)
&gt;&gt;&gt; print(t)
[&#39;a&#39;, &#39;c&#39;]</code></pre>
<p>Η επιστρεφόμενη τιμή του <code>remove</code> είναι <code>None</code>.</p>
<p> </p>
<p>Για να αφαιρέσετε περισσότερα από ένα στοιχεία, μπορείτε να χρησιμοποιήσετε το <code>del</code> με ένα δείκτη διαμέρισης:</p>
<pre class="python trinket"><code>&gt;&gt;&gt; t = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;]
&gt;&gt;&gt; del t[1:5]
&gt;&gt;&gt; print(t)
[&#39;a&#39;, &#39;f&#39;]</code></pre>
<p>Ως συνήθως, το τμήμα, που θα διαγραφεί περιλαμβάνει όλα τα στοιχεία μέχρικαι πριν το δεύτερο δείκτη.</p>
<h2 id="λίστες-και-συναρτήσεις">Λίστες και συναρτήσεις</h2>
<p>Υπάρχει ένα πλήθος ενσωματωμένων συναρτήσεων που μπορούν να χρησιμοποιηθούν σε λίστες και που σας επιτρέπουν να εξετάζεται γρήγορα μια λίστα, χωρίς να γράφετε τους δικούς σας βρόχους:</p>
<pre class="python trinket"><code>&gt;&gt;&gt; nums = [3, 41, 12, 9, 74, 15]
&gt;&gt;&gt; print(len(nums))
6
&gt;&gt;&gt; print(max(nums))
74
&gt;&gt;&gt; print(min(nums))
3
&gt;&gt;&gt; print(sum(nums))
154
&gt;&gt;&gt; print(sum(nums)/len(nums))
25</code></pre>
<p>Η συνάρτηση <code>sum()</code> λειτουργεί μόνο όταν τα στοιχεία της λίστας είναι αριθμοί. Οι άλλες δύο συναρτήσεις (<code>max()</code>, <code>len()</code>, etc.) λειτουργούν και με λίστες συμβολοσειρών και άλλους τύπους, που μπορούν να είναι συγκρίσιμοι.</p>
<p>Θα μπορούσαμε να ξαναγράψουμε ένα προηγούμενο πρόγραμμα, που υπολόγιζε τον μέσο όρο μιας λίστας αριθμών που εισήγαγε ο χρήστης, χρησιμοποιώντας μια λίστα.</p>
<p>Πρώτα, το πρόγραμμα για τον υπολογισμό ενός μέσου όρου χωρίς λίστα:</p>
<pre class="python"><code>σύνολο = 0
πλήθος = 0
while (True):
    είσοδος = input(&#39;Enter a number: &#39;)
    if είσοδος == &#39;τέλος&#39;: break
    τιμή = float(είσοδος)
    σύνολο = σύνολο + τιμή
    πλήθος = πλήθος + 1

μέσοςΌρος = σύνολο / πλήθος
print(&#39;Μέσος Όρος:&#39;, μέσοςΌρος)

# Code: http://www.gr.py4e.com/code3/avenum.py</code></pre>
<p>Σε αυτό το πρόγραμμα, έχουμε τις μεταβλητές <code>πλήθος</code> και <code>σύνολο</code> για να κρατήσουμε τον πλήθος και το τρέχον σύνολο των αριθμών που εισάγονται, καθώς ζητάμε επανειλημμένα από τον χρήστη την εισαγωγή ενόν αριθμού.</p>
<p>Θα μπορούσαμε απλά να αποθηκεύουμε κάθε αριθμό καθώς τον εισαγάγει ο χρήστης και να χρησιμοποιήσουμε ενσωματωμένες συναρτήσεις για να υπολογίσουμε το άθροισμα και το πλήθος, στο τέλος.</p>
<pre class="python"><code>numlist = list()
while (True):
    είσοδος = input(&#39;Enter a number: &#39;)
    if είσοδος == &#39;τέλος&#39;: break
    τιμή = float(είσοδος)
    numlist.append(τιμή)

μέσοςΌρος = sum(numlist) / len(numlist)
print(&#39;Μέσος Όρος:&#39;, μέσοςΌρος)

# Code: http://www.gr.py4e.com/code3/avelist.py</code></pre>
<p>Δημιουργούμε μια κενή λίστα πριν ξεκινήσει ο βρόχος και, στη συνέχεια, κάθε φορά που έχουμε έναν αριθμό, τον προσθέτουμε στη λίστα. Στο τέλος του προγράμματος, απλά υπολογίζουμε το άθροισμα των αριθμών στη λίστα και το διαιρούμε με το πλήθος των αριθμών στη λίστα για να καταλήξουμε στον μέσο όρο.</p>
<h2 id="λίστες-και-συμβολοσειρές">Λίστες και συμβολοσειρές</h2>
<p>  </p>
<p>Μια συμβολοσειρά είναι μια ακολουθία χαρακτήρων και μια λίστα είναι μια ακολουθία τιμών, αλλά μια λίστα χαρακτήρων δεν είναι ίδια με μια συμβολοσειρά. Για να μετατρέψετε μια συμβολοσειρά σε μια λίστα χαρακτήρων, μπορείτε να χρησιμοποιήσετε τη <code>list</code>:</p>
<p> </p>
<pre class="python trinket"><code>&gt;&gt;&gt; s = &#39;spam&#39;
&gt;&gt;&gt; t = list(s)
&gt;&gt;&gt; print(t)
[&#39;s&#39;, &#39;p&#39;, &#39;a&#39;, &#39;m&#39;]</code></pre>
<p>Επειδή το <code>list</code> είναι το όνομα μιας ενσωματωμένης συνάρτησης, θα πρέπει να αποφύγετε τη χρήση της ως όνομα μεταβλητής. Επίσης αποφεύγω το γράμμα “l’ γιατί μοιάζει πάρα πολύ με τον αριθμό”1”. Γι’ αυτό λοιπόν χρησιμοποιώ το “t”.</p>
<p>Η συνάρτηση <code>list</code> σπάει μια συμβολοσειρά σε μεμονωμένα γράμματα. Εάν θέλετε να χωρίσετε μια συμβολοσειρά σε λέξεις, μπορείτε να χρησιμοποιήσετε τη μέθοδο <code>split</code>:</p>
<p> </p>
<pre class="python trinket"><code>&gt;&gt;&gt; s = &#39;pining for the fjords&#39;
&gt;&gt;&gt; t = s.split()
&gt;&gt;&gt; print(t)
[&#39;pining&#39;, &#39;for&#39;, &#39;the&#39;, &#39;fjords&#39;]
&gt;&gt;&gt; print(t[2])
the</code></pre>
<p>Αφού χρησιμοποιήσετε το <code>split</code> για να σπάσετε τη συμβολοσειρά σε μια λίστα λέξεων, μπορείτε να χρησιμοποιήσετε τον τελεστή ευρετηρίου (τετράγωνη αγκύλη) για να δείτε μια συγκεκριμένη λέξη στη λίστα.</p>
<p>Μπορείτε να καλέσετε το <code>split</code> με ένα προαιρετικό όρισμα, που ονομάζεται <em>οριοθέτης (delimiter)</em> που καθορίζει ποιοι χαρακτήρες θα χρησιμοποιηθούν ως διαχωριστικά λέξεων. Το ακόλουθο παράδειγμα χρησιμοποιεί μια παύλα ως οριοθέτη:</p>
<p>  </p>
<pre class="python trinket"><code>&gt;&gt;&gt; s = &#39;spam-spam-spam&#39;
&gt;&gt;&gt; οριοθέτης = &#39;-&#39;
&gt;&gt;&gt; s.split(οριοθέτης)
[&#39;spam&#39;, &#39;spam&#39;, &#39;spam&#39;]</code></pre>
<p>Η <code>join</code> είναι το αντίστροφο του <code>split</code>. Παίρνει μια λίστα με συμβολοσειρές και συνενώνει τα στοιχεία της. Το <code>join</code> είναι μια μέθοδος συμβολοσειράς, επομένως πρέπει να την καλέσετε στον οριοθέτη και να μεταβιβάσετε τη λίστα ως παράμετρο:</p>
<p>  </p>
<pre class="python trinket"><code>&gt;&gt;&gt; t = [&#39;pining&#39;, &#39;for&#39;, &#39;the&#39;, &#39;fjords&#39;]
&gt;&gt;&gt; οριοθέτης = &#39; &#39;
&gt;&gt;&gt; οριοθέτης.join(t)
&#39;pining for the fjords&#39;</code></pre>
<p>Σε αυτήν την περίπτωση, ο οριοθέτης είναι ένας χαρακτήρας διαστήματος, επομένως η <code>join</code> βάζει ένα διάστημα μεταξύ των λέξεων. Για να συνδέσετε συμβολοσειρές χωρίς κενά, μπορείτε να χρησιμοποιήσετε την κενή συμβολοσειρά ““, ως οριοθέτη.</p>
<p> </p>
<h2 id="ανάλυση-γραμμών">Ανάλυση γραμμών</h2>
<p>Συνήθως όταν διαβάζουμε ένα αρχείο θέλουμε να κάνουμε κάτι στις γραμμέςτου, πέρα από την απλή εκτύπωση ολόκληρης της γραμμής. Συχνά θέλουμε να βρούμε τις “ενδιαφέρουσες γραμμές” και μετά <em>να αναλύσουμε</em> την κάθε μία από αυτές, για να βρούμε κάποιο ενδιαφέρον <em>μέρος</em> της γραμμής. Τι θα γινόταν αν θέλαμε να εκτυπώσουμε την ημέρα της εβδομάδας από αυτές τις γραμμές που ξεκινούν με “From”;</p>
<pre class="{text}"><code>From stephen.marquard@uct.ac.za Sat Jan  5 09:14:16 2008</code></pre>
<p>Η μέθοδος <code>split</code> είναι πολύ αποτελεσματική, όταν αντιμετωπίζετε τέτοιου είδους προβλήματα. Μπορούμε να γράψουμε ένα μικρό πρόγραμμα που αναζητά γραμμές, που ξεκινούν με “From”, να <code>διαχωρίσουμε (split)</code> αυτές τις γραμμές και, στη συνέχεια, να εκτυπώσουμε την τρίτη λέξη στη γραμμή:</p>
<pre class="python"><code>fhand = open(&#39;mbox-short.txt&#39;)
for γραμμή in fhand:
    γραμμή = γραμμή.rstrip()
    if not γραμμή.startswith(&#39;From &#39;): continue
    λέξεις = γραμμή.split()
    print(λέξεις[2])

# Code: http://www.gr.py4e.com/code3/search5.py</code></pre>
<p>Το πρόγραμμα παράγει την ακόλουθη έξοδο:</p>
<pre class="{text}"><code>    Sat
    Fri
    Fri
    Fri
    ...</code></pre>
<p>Αργότερα, θα μάθουμε όλο και πιο εξελιγμένες τεχνικές, για να επιλέγουμε τις γραμμές στις οποίες θα δουλέψουμε και πώς θα ξεχωρίσουμε αυτές τις γραμμές για να βρούμε το ακριβές κομμάτι των πληροφοριών που αναζητούμε.</p>
<h2 id="αντικείμενα-και-τιμές">Αντικείμενα και τιμές</h2>
<p> </p>
<p>Εάν εκτελέσουμε αυτές τις εντολές ανάθεσης:</p>
<pre class="python"><code>a = &#39;banana&#39;
b = &#39;banana&#39;</code></pre>
<p>Γνωρίζουμε ότι το <code>a</code> και το <code>b</code> αναφέρονται και τα δύο σε μια συμβολοσειρά, αλλά δεν ξέρουμε αν αναφέρονται στην <em>ίδια</em> συμβολοσειρά. Υπάρχουν δύο πιθανές καταστάσεις:</p>
<p></p>
<figure>
<img src="../images/list1.svg" alt="Μεταβλητές και Αντικείμενα" style="height: 0.5in;"/>
<figcaption>
Μεταβλητές και Αντικείμενα
</figcaption>
</figure>
<p>Στο πρώτο σχήμα, τα <code>a</code> και <code>b</code> αναφέρονται σε δύο διαφορετικά αντικείμενα, που έχουν την ίδια τιμή. Στο δεύτερο σχήμα αναφέρονται στο ίδιο αντικείμενο.</p>
<p> </p>
<p>Για να ελέγξετε αν δύο μεταβλητές αναφέρονται στο ίδιο αντικείμενο, μπορείτε να χρησιμοποιήσετε τον τελεστή <code>is</code>.</p>
<pre class="python trinket"><code>&gt;&gt;&gt; a = &#39;banana&#39;
&gt;&gt;&gt; b = &#39;banana&#39;
&gt;&gt;&gt; a is b
True</code></pre>
<p>Σε αυτό το παράδειγμα, η Python δημιούργησε μόνο ένα αντικείμενο συμβολοσειράς και το <code>a</code> και το <code>b</code> αναφέρονται σε αυτό.</p>
<p>Αλλά όταν δημιουργείτε δύο λίστες, δημιουργούνται δύο αντικείμενα:</p>
<pre class="python trinket"><code>&gt;&gt;&gt; a = [1, 2, 3]
&gt;&gt;&gt; b = [1, 2, 3]
&gt;&gt;&gt; a is b
False</code></pre>
<p>Σε αυτή την περίπτωση θα λέγαμε ότι οι δύο λίστες είναι <em>ισοδύναμες</em>, γιατί έχουν τα ίδια στοιχεία, αλλά όχι <em>ταυτόσημες</em>, μιας και είναι δύο διαφορετικά αντικείμενα. Αν δύο αντικείμενα είναι ταυτόσημα, είναι επίσης ισοδύναμα, αλλά αν είναι ισοδύναμα, δεν είναι απαραίτητα ταυτόσημα.</p>
<p> </p>
<p>Μέχρι τώρα, χρησιμοποιούσαμε το “αντικείμενο” και την “τιμή” εναλλακτικά, αλλά είναι πιο ακριβές να πούμε ότι ένα αντικείμενο έχει μια τιμή. Εάν <code>a = [1,2,3]</code>, το <code>a</code> αναφέρεται σε ένα αντικείμενο λίστας του οποίου η τιμή είναι μια συγκεκριμένη ακολουθία στοιχείων. Εάν μια άλλη λίστα έχει τα ίδια στοιχεία, θα λέγαμε ότι έχει την ίδια τιμή.</p>
<p> </p>
<h2 id="Ψευδωνυμία">Ψευδωνυμία</h2>
<p> </p>
<p>Εάν το <code>a</code> αναφέρεται σε ένα αντικείμενο και εκτελέσετε <code>b = a</code>, τότε και οι δύο μεταβλητές αναφέρονται στο ίδιο αντικείμενο:</p>
<pre class="python trinket"><code>&gt;&gt;&gt; a = [1, 2, 3]
&gt;&gt;&gt; b = a
&gt;&gt;&gt; b is a
True</code></pre>
<p>Ο συσχετισμός μιας μεταβλητής με ένα αντικείμενο ονομάζεται <em>αναφορά</em>. Σε αυτό το παράδειγμα, υπάρχουν δύο αναφορές στο ίδιο αντικείμενο.</p>
<p></p>
<p>Ένα αντικείμενο με περισσότερες από μία αναφορές, έχει περισσότερα από ένα ονόματα, οπότε λέμε ότι το αντικείμενο έχει <em>ψευδώνυμα</em>.</p>
<p></p>
<p>Εάν το αντικείμενο με ψευδώνυμα είναι μεταβαλλόμενο, οι αλλαγές που γίνονται με το ένα ψευδώνυμο επηρεάζουν το άλλο:</p>
<pre class="python"><code>&gt;&gt;&gt; b[0] = 17
&gt;&gt;&gt; print(a)
[17, 2, 3]</code></pre>
<p>Αν και αυτή η συμπεριφορά μπορεί να είναι χρήσιμη, είναι επιρρεπής σε σφάλματα. Γενικά, είναι ασφαλέστερο να αποφεύγετε τη ψευδωνυμία όταν εργάζεστε με μεταβαλλόμενα αντικείμενα.</p>
<p></p>
<p>Για αμετάβλητα αντικείμενα όπως οι συμβολοσειρές, η ψευδωνυμία δεν είναι τόσο σοβαρό πρόβλημα. Σε αυτό το παράδειγμα:</p>
<pre class="python"><code>a = &#39;banana&#39;
b = &#39;banana&#39;</code></pre>
<p>Σχεδόν ποτέ δεν έχει διαφορά εάν το <code>a</code> και το <code>b</code> αναφέρονται στην ίδια συμβολοσειρά ή όχι.</p>
<h2 id="ορίσματα-λίστας">Ορίσματα λίστας</h2>
<p>    </p>
<p>Όταν μεταβιβάζετε μια λίστα σε μια συνάρτηση, η συνάρτηση λαμβάνει μια αναφορά στη λίστα. Εάν η συνάρτηση τροποποιήσει μια παράμετρο λίστας, η αλλαγή πραγματοποιείται και στην λίστα που μεταβιβάστηκε ως όρισμα. Για παράδειγμα, το <code>delete_head</code> αφαιρεί το πρώτο στοιχείο από μια λίστα:</p>
<pre class="python"><code>def delete_head(t):
    del t[0]</code></pre>
<p>Δείτε πώς χρησιμοποιείται:</p>
<pre class="python trinket"><code>&gt;&gt;&gt; γράμματα = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]
&gt;&gt;&gt; delete_head(γράμματα)
&gt;&gt;&gt; print(γράμματα)
[&#39;b&#39;, &#39;c&#39;]</code></pre>
<p>Η παράμετρος <code>t</code> και η μεταβλητή <code>γράμματα</code> είναι ψευδώνυμα για το ίδιο αντικείμενο.</p>
<p>Είναι σημαντικό να γίνεται διάκριση μεταξύ λειτουργιών που τροποποιούν λίστες και λειτουργιών που δημιουργούν νέες λίστες. Για παράδειγμα, η μέθοδος <code>append</code> τροποποιεί μια λίστα, αλλά ο τελεστής <code>+</code> δημιουργεί μια νέα λίστα:</p>
<p>   </p>
<pre class="python trinket"><code>&gt;&gt;&gt; t1 = [1, 2]
&gt;&gt;&gt; t2 = t1.append(3)
&gt;&gt;&gt; print(t1)
[1, 2, 3]
&gt;&gt;&gt; print(t2)
None

&gt;&gt;&gt; t3 = t1 + [3]
&gt;&gt;&gt; print(t3)
[1, 2, 3]
&gt;&gt;&gt; t2 is t3
False</code></pre>
<p>Αυτή η διαφορά είναι σημαντική όταν γράφετε συναρτήσεις που υποτίθεται ότι τροποποιούν λίστες. Για παράδειγμα, αυτή η συνάρτηση <em>δεν</em> διαγράφει το πρώτο στοιχείο (θέση 0) μιας λίστας:</p>
<pre class="python"><code>def bad_delete_head(t):
    t = t[1:]              # WRONG!</code></pre>
<p>Ο τελεστής διαμέρισης δημιουργεί μια νέα λίστα και η ανάθεση κάνει το <code>t</code> να αναφέρεται σε αυτήν, αλλά τίποτα από αυτά δεν έχει καμία επίδραση στη λίστα που μεταβιβάστηκε ως όρισμα.</p>
<p> </p>
<p>Μια εναλλακτική είναι να γράψετε μια συνάρτηση που δημιουργεί και επιστρέφει μια νέα λίστα. Για παράδειγμα, η <code>tail</code> επιστρέφει όλα εκτός από το πρώτο στοιχείο μιας λίστας:</p>
<pre class="python"><code>def tail(t):
    return t[1:]</code></pre>
<p>Αυτή η συνάρτηση αφήνει την αρχική λίστα χωρίς αμετάβλητη. Δείτε πώς χρησιμοποιείται:</p>
<pre class="python trinket"><code>&gt;&gt;&gt; γράμματα = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]
&gt;&gt;&gt; υπόλοιπο = tail(γράμματα)
&gt;&gt;&gt; print(υπόλοιπο)
[&#39;b&#39;, &#39;c&#39;]</code></pre>
<p><strong>Άσκηση 1: Γράψτε μια συνάρτηση με όνομα <code>chop</code>, που δέχεται μια λίστα και την τροποποιεί, αφαιρώντας το πρώτο και το τελευταίο στοιχείο και επιστρέφει <code>None</code>. Στη συνέχεια, γράψτε μια συνάρτηση που ονομάζεται <code>middle</code>, που δέχεται μια λίστα και επιστρέφει μια νέα λίστα που περιέχει όλα τα στοιχεία της αρχική, εκτός από το πρώτο και το τελευταίο.</strong></p>
<h2 id="εκσφαλμάτωση">Εκσφαλμάτωση</h2>
<p></p>
<p>Η απρόσεκτη χρήση λιστών (και άλλων μεταβαλλόμενων αντικειμένων) μπορεί να οδηγήσει σε πολύωρη εκσφαλμάτωση. Ακολουθούν μερικές συνήθεις παγίδες και τρόποι για να τις αποφύγετε:</p>
<ol type="1">
<li><p>Μην ξεχνάτε ότι οι περισσότερες μέθοδοι λίστας τροποποιούν το όρισμα και επιστρέφουν <code>None</code>, αντίθετα από τις μεθόδους συμβολοσειράς, οι οποίες επιστρέφουν μια νέα συμβολοσειρά και αφήνουν το πρωτότυπο αναλλοίωτο.</p>
<p>Εάν έχετε συνηθίσει να γράφετε κώδικα για συμβολοσειρές ως εξής:</p>
<pre class="python"><code>word = word.strip()</code></pre>
<p>Είναι, συχνά, δελεαστικό να γράψετε αντίστοιχο κώδικα και για λίστες:</p>
<pre class="python"><code>t = t.sort()           # ΛΑΘΟΣ!</code></pre>
<p> </p>
<p>Επειδή η <code>sort</code> επιστρέφει <code>None</code>, η επόμενη λειτουργία που θα εκτελέσετε με το <code>t</code> είναι πιθανό να αποτύχει. Πριν χρησιμοποιήσετε μεθόδους λίστας και τελεστές, θα πρέπει να διαβάσετε προσεκτικά την τεκμηρίωση και στη συνέχεια να κάνετε δοκιμές σε διαδραστική λειτουργία. Οι μέθοδοι και οι τελεστές που είναι κοινές σε λίστες με άλλες ακολουθίες (όπως συμβολοσειρές) τεκμηριώνονται στη διεύθυνση:</p>
<p><a href="https://docs.python.org/library/stdtypes.html#common-sequence-operations">docs.python.org/library/stdtypes.html#common-sequence-operations</a></p>
<p>Οι μέθοδοι και οι τελεστές που ισχύουν μόνο για μεταβαλλόμενες ακολουθίες τεκμηριώνονται στη διεύθυνση:</p>
<p><a href="https://docs.python.org/library/stdtypes.html#mutable-sequence-types">docs.python.org/library/stdtypes.html#mutable-sequence-types</a></p></li>
<li><p>Διάλεξε ένα ιδίωμα και μείνε με αυτό.</p>
<p> </p>
<p>Μέρος του προβλήματος με τις λίστες είναι ότι υπάρχουν πάρα πολλοί τρόποι για να κάνετε πράγματα. Για παράδειγμα, για να αφαιρέσετε ένα στοιχείο από μια λίστα, μπορείτε να χρησιμοποιήσετε τις <code>pop</code>, <code>remove</code>, <code>del</code> ή ακόμα και μια εκχώρηση με τον τελεστή διαμέρισης.</p>
<p>Για να προσθέσετε ένα στοιχείο, μπορείτε να χρησιμοποιήσετε τη μέθοδο <code>append</code> ή τον τελεστή <code>+</code>. Αλλά μην ξεχνάτε ότι αυτό είναι το σωστά:</p>
<pre class="python"><code>t.append(x)
t = t + [x]</code></pre>
<p>Και αυτό είναι λάθος:</p>
<pre class="python"><code>t.append([x])          # ΛΑΘΟΣ!
t = t.append(x)        # ΛΑΘΟΣ!
t + [x]                # ΛΑΘΟΣ!
t = t + x              # ΛΑΘΟΣ!</code></pre>
<p>Δοκιμάστε καθένα από αυτά τα παραδείγματα σε διαδραστική λειτουργία για να βεβαιωθείτε ότι καταλαβαίνετε τι κάνουν. Σημειώστε ότι μόνο το τελευταίο προκαλεί σφάλμα χρόνου εκτέλεσης, τα άλλα τρία είναι συντακτικά σωστά, αλλά δεν έχουν το επιθυμητό αποτέλεσμα.</p></li>
<li><p>Δημιουργήστε αντίγραφα για να αποφύγετε τη ψευδωνυμία</p>
<p> </p>
<p>Εάν θέλετε να χρησιμοποιήσετε μια μέθοδο όπως η <code>sort</code>, που τροποποιεί το όρισμα, αλλά πρέπει να διατηρήσετε και την αρχική λίστα, μπορείτε να δημιουργήσετε ένα αντίγραφο.</p>
<pre class="python"><code>orig = t[:]
t.sort()</code></pre>
<p>Σε αυτό το παράδειγμα, θα μπορούσατε επίσης να χρησιμοποιήσετε την ενσωματωμένη συνάρτηση <code>sorted</code>, η οποία επιστρέφει μια νέα, ταξινομημένη λίστα και αφήνει το πρωτότυπο αναλλοίωτο. Σε αυτήν όμως την περίπτωση, θα πρέπει να αποφύγετε τη χρήση του <code>sorted</code> ως όνομα μεταβλητής!</p></li>
<li><p>Λίστες, <code>split</code> και αρχεία</p>
<p>Όταν διαβάζουμε και αναλύουμε αρχεία, υπάρχουν πολλές πιθανότητες να συναντήσουμε είσοδο που ενδέχεται να διακόψει το πρόγραμμά μας, επομένως είναι καλή ιδέα να επανεξετάσουμε το μοτίβο <em>guardian (κηδεμονίας)</em> όταν πρόκειται να γράψουμε προγράμματα που διαβάζουν από ένα αρχείο και να αναζητήσουμε μια “βελόνα στο άχυρα”.</p>
<p>Ας δούμε ξανά το πρόγραμμά μας, που αναζητά την ημέρα της εβδομάδας στις γραμμές του αρχείου μας:</p>
<pre class="{text}"><code>From stephen.marquard@uct.ac.za Sat Jan  5 09:14:16 2008</code></pre>
<p>Εφόσον χωρίζουμε αυτή τη γραμμή σε λέξεις, θα μπορούσαμε να παραιτηθούμε από τη χρήση του <code>startswith</code> και απλώς να δούμε την πρώτη λέξη της γραμμής για να προσδιορίσουμε αν μας ενδιαφέρει αυτή η γραμμή ή όχι. Μπορούμε να χρησιμοποιήσουμε το <code>continue</code> για να παραλείψουμε τις γραμμές που δεν έχουν το “From” ως πρώτη λέξη ως εξής:</p>
<pre class="python"><code>fhand = open(&#39;mbox-short.txt&#39;)
for γραμμή in fhand:
    λέξεις = γραμμή.split()
    if λέξεις[0] != &#39;From&#39; : continue
    print(λέξεις[2])</code></pre>
<p>Αυτό φαίνεται πολύ πιο απλό και δεν χρειάζεται καν να χρησιμοποιήσουμε το <code>rstrip</code> για να αφαιρέσουμε το χαρακτήρα νέας γραμμής από το τέλος του αρχείου. Είναι όμως καλύτερο;</p>
<pre class="{text}"><code>python search8.py
Sat
Traceback (most recent call last):
  File &quot;search8.py&quot;, line 5, in &lt;module&gt;
    if λέξεις[0] != &#39;From&#39; : continue
IndexError: list index out of range</code></pre>
<p>Λειτουργεί αρχικά και βλέπουμε την ημέρα από την πρώτη γραμμή (Sat), αλλά μετά το πρόγραμμα αποτυγχάνει με ένα σφάλμα traceback. Τι πήγε στραβά; Ποια μπερδεμένα δεδομένα προκάλεσαν την αποτυχία του κομψό, έξυπνου και πολύ Pythonic προγράμματός μας;</p>
<p>Θα μπορούσατε να το ελέγχετε για πολλή ώρα και να μπερδευτείτε ή να ζητήσετε βοήθεια από κάποιον, αλλά η πιο γρήγορη και έξυπνη προσέγγιση είναι να προσθέσετε μια εντολή <code>print</code>. Το καλύτερο μέρος για να προσθέσετε την εντολή εκτύπωσης είναι ακριβώς πριν από τη γραμμή όπου το πρόγραμμα απέτυχε και να εκτυπώσετε τα δεδομένα που φαίνεται να προκαλούν την αποτυχία.</p>
<p>Τώρα αυτή η προσέγγιση μπορεί να παράξει πολλές γραμμές εξόδου, αλλά τουλάχιστον θα έχετε αμέσως κάποιες ενδείξεις για το πρόβλημα που αντιμετωπίζετε. Έτσι, προσθέτουμε μια εκτύπωση της μεταβλητής <code>words</code>, ακριβώς πριν από τη γραμμή πέντε. Προσθέτουμε ακόμη και ένα πρόθεμα “Εντοπισμός σφαλμάτων:” στη γραμμή, ώστε να μπορούμε να διατηρήσουμε την κανονική μας έξοδο ξεχωριστά από την έξοδο εντοπισμού σφαλμάτων.</p>
<pre class="python"><code>for γραμμή in fhand:
    λέξεις = γραμμή.split()
    print(&#39;Εντοπισμός σφαλμάτων:&#39;, λέξεις)
    if λέξεις[0] != &#39;From&#39; : continue
    print(λέξεις[2])</code></pre>
<p>Όταν εκτελούμε το πρόγραμμα, πολλές εξόδοι κυλούν στο πάνω μέρος της οθόνης, αλλά στο τέλος, βλέπουμε την έξοδο εντοπισμού σφαλμάτων και την σφάλμα traceback, ώστε να γνωρίζουμε τι συνέβη λίγο πριν από το σφάλμα.</p>
<pre class="{text}"><code>Debug: [&#39;X-DSPAM-Confidence:&#39;, &#39;0.8475&#39;]
Debug: [&#39;X-DSPAM-Probability:&#39;, &#39;0.0000&#39;]
Debug: []
Traceback (most recent call last):
  File &quot;search9.py&quot;, line 6, in &lt;module&gt;
    if λέξεις[0] != &#39;From&#39; : continue
IndexError: list index out of range</code></pre>
<p>Κάθε γραμμή εντοπισμού σφαλμάτων εκτυπώνει τη λίστα των λέξεων που λαμβάνουμε από τη <code>split</code>, όταν διαχωρίζουμε τη γραμμή σε λέξεις. Το πρόγραμμα αποτυγχάνει, όταν η λίστα των λέξεων είναι κενή <code>[]</code>. Αν ανοίξουμε το αρχείο σε ένα πρόγραμμα επεξεργασίας κειμένου και το ελέγξουμε, σε εκείνο το σημείο φαίνεται ως εξής:</p>
<pre class="{text}"><code>X-DSPAM-Result: Innocent
X-DSPAM-Processed: Sat Jan  5 09:14:16 2008
X-DSPAM-Confidence: 0.8475
X-DSPAM-Probability: 0.0000

Details: http://source.sakaiproject.org/viewsvn/?view=rev&amp;rev=39772</code></pre>
<p>Το σφάλμα παρουσιάζεται όταν το πρόγραμμά μας συναντήσει μια κενή γραμμή! Φυσικά, υπάρχουν <code>μηδέν λέξεις</code> σε μια κενή γραμμή. Γιατί δεν το σκεφτήκαμε όταν γράφαμε τον κώδικα; Όταν ο κώδικας αναζητά την πρώτη λέξη (<code>λέξη[0]</code>) για να ελέγξει αν ταιριάζει με το “From”, λαμβάνουμε το σφάλμα “index out of range”.</p>
<p>Αυτό φυσικά είναι το τέλειο μέρος για να προσθέσετε κάποιον κώδικα <em>κηδεμόνα</em>, για να αποφύγετε τον έλεγχο της πρώτης λέξης εάν δεν υπάρχει πρώτη λέξη. Υπάρχουν πολλοί τρόποι προστασίας αυτού του κώδικα. θα επιλέξουμε να ελέγξουμε τον αριθμό των λέξεων που έχουμε πριν επιχειρήσουμε να προσπελάσουμε την πρώτη λέξη:</p>
<pre class="python"><code>fhand = open(&#39;mbox-short.txt&#39;)
for γραμμή in fhand:
    λέξεις = γραμμή.split()
    # print(&#39;Εντοπισμός σφαλμάτων:&#39;, λέξεις)
    if len(λέξεις) == 0 : continue
    if λέξεις[0] != &#39;From&#39; : continue
    print(λέξεις[2])</code></pre>
<p>Πρώτα μετατρέψαμε σε σχόλιο την εντολή εκτύπωσης εντοπισμού σφαλμάτων, αντί να την αφαιρέσουμε, σε περίπτωση που η τροποποίησή μας αποτύχει και χρειαστεί εκσφαλμάτωση ξανά. Στη συνέχεια, προσθέσαμε μια δήλωση κηδεμόνα, που ελέγχει αν έχουμε μηδενικές λέξεις και, αν ναι, χρησιμοποιούμε το <code>continue</code> για να μεταβούμε στην επόμενη γραμμή του αρχείου.</p>
<p>Οι δύο δηλώσεις <code>continue</code> μας βοηθούν να φιλτράρουμε το σύνολο των γραμμών που μας “ενδιαφέρουν” και τις οποίες θέλουμε να επεξεργαστούμε λίγο περισσότερο. Μια γραμμή που δεν έχει λέξεις μας είναι “αδιάφορη”, οπότε την αγνοούμε και μεταβαίνουμε στην επόμενη γραμμή. Μια γραμμή που δεν έχει ως πρώτη λέξη το “From” δεν μας ενδιαφέρει, οπότε την παρακάμπτουμε κι αυτήν.</p>
<p>Το πρόγραμμα όπως τροποποιήθηκε εκτελείται με επιτυχία, οπότε ίσως είναι σωστό. Η δήλωση του κηδεμόνα μας διασφαλίζει ότι το <code>λέξεις[0]</code> δεν θα αποτύχει ποτέ, αλλά ίσως δεν είναι αρκετό. Όταν προγραμματίζουμε, πρέπει πάντα να σκεφτόμαστε, “Τι μπορεί να πάει στραβά;”</p></li>
</ol>
<p><strong>Άσκηση 2: Εντοπίστε ποια γραμμή, του παραπάνω προγράμματος, εξακολουθεί να μην προστατεύεται σωστά. Δείτε εάν μπορείτε να δημιουργήσετε ένα αρχείο κειμένου που προκαλεί την αποτυχία προγράμματός μας και, στη συνέχεια, τροποποιήστε το πρόγραμμα έτσι ώστε η γραμμή να προστατεύεται σωστά και δοκιμάστε το για να βεβαιωθείτε ότι χειρίζεται χωρίς σφάλματα το νέο αρχείο κειμένου σας.</strong></p>
<p><strong>Άσκηση 3: Ξαναγράψτε τον κώδικα κηδεμόνα του παραπάνω παραδείγματος, χωρίς τις δύο εντολές <code>if</code>. Αντ’ αυτών, χρησιμοποιήστε μια σύνθετη λογική έκφραση, χρησιμοποιώντας τον λογικό τελεστή <code>or</code> με μία μόνο εντολή <code>if</code>.</strong></p>
<h2 id="γλωσσάριο">Γλωσσάριο</h2>
<dl>
<dt>αναφορά</dt>
<dd>Η συσχέτιση μεταξύ μιας μεταβλητής και της τιμής της.
</dd>
<dt>αντικείμενο</dt>
<dd>Κάτι στο οποίο μπορεί να αναφέρεται μια μεταβλητή. Ένα αντικείμενο έχει έναν τύπο και μια τιμή.
</dd>
<dt>δείκτης</dt>
<dd>Μια ακέραια τιμή που υποδεικνύει ένα στοιχείο σε μια λίστα.
</dd>
<dt>διάσχιση λίστας (list traversal)</dt>
<dd>Η διαδοχική πρόσβαση σε κάθε στοιχείο μιας λίστας.
</dd>
<dt>εμφωλευμένη λίστα</dt>
<dd>Μια λίστα που είναι στοιχείο μιας άλλης λίστας.
</dd>
<dt>ισοδύναμο</dt>
<dd>Έχει την ίδια τιμή.
</dd>
<dt>λίστα</dt>
<dd>Μία ακολουθία τιμών.
</dd>
<dt>οριοθέτης</dt>
<dd>Ένας χαρακτήρας ή συμβολοσειρά που χρησιμοποιείται για να υποδείξει πού πρέπει να χωριστεί μια συμβολοσειρά.
</dd>
<dt>στοιχείο</dt>
<dd>Μία από τις τιμές σε μια λίστα (ή άλλη ακολουθία).
</dd>
<dt>ταυτόσημο</dt>
<dd>Είναι το ίδιο αντικείμενο (που συνεπάγεται ισοδύναμο).
</dd>
<dt>ψευδωνυμία</dt>
<dd>Μια περίσταση όπου δύο ή περισσότερες μεταβλητές αναφέρονται στο ίδιο αντικείμενο.
</dd>
</dl>
<h2 id="ασκήσεις">Ασκήσεις</h2>
<p></p>
<p><strong>Άσκηση 4: Βρείτε όλες τις μοναδικές λέξεις σε ένα αρχείο</strong></p>
<p><strong>Ο Σαίξπηρ χρησιμοποίησε πάνω από 20.000 λέξεις στα έργα του. Πώς όμως θα το υπολόγιζες αυτό; Πώς θα δημιουργήσατε τη λίστα με όλες τις λέξεις που χρησιμοποίησε ο Σαίξπηρ; Θα κατεβάζατε όλο το έργο του, θα το διαβάσατε και θα εντοπίζατε όλες τις μοναδικές λέξεις με το χέρι;</strong></p>
<p><strong>Ας χρησιμοποιήσουμε την Python για να το πετύχουμε αυτό. Καταγράψτε όλες τις μοναδικές λέξεις, ταξινομημένες με αλφαβητική σειρά, που είναι αποθηκευμένες στο αρχείο <code>romeo.txt</code>, που περιέχει ένα υποσύνολο του έργου του Σαίξπηρ.</strong></p>
<p><strong>Για να ξεκινήσετε, κατεβάστε ένα αντίγραφο του αρχείου</strong> <a href="http://www.gr.py4e.com/code3/romeo.txt"><strong>www.gr.py4e.com/code3/romeo.txt</strong></a><strong>. Δημιουργήστε μια λίστα,στην οποία να εμφανίζεται κάθε λέξη μία μόνο φορά, η οποία θα περιέχει το τελικό αποτέλεσμα. Γράψτε ένα πρόγραμμα για να ανοίξετε το αρχείο <code>romeo.txt</code> και να το διαβάσετε γραμμή προς γραμμή. Για κάθε γραμμή, χωρίστε την σε μια λίστα λέξεων χρησιμοποιώντας τη συνάρτηση <code>split</code>. Για κάθε λέξη, ελέγξτε αν η λέξη περιέχεται ήδη στη λίστα με τις μοναδικές λέξεις. Εάν η λέξη δεν περιέχεται στη λίστα με τις μοναδικές λέξεις, προσθέστε τη στη λίστα. Όταν ολοκληρωθεί το πρόγραμμα, ταξινομήστε και εκτυπώστε τη λίστα με τις μοναδικές λέξεις, σε αλφαβητική σειρά.</strong></p>
<pre class="{text}"><code>Enter file: romeo.txt
[&#39;Arise&#39;, &#39;But&#39;, &#39;It&#39;, &#39;Juliet&#39;, &#39;Who&#39;, &#39;already&#39;,
&#39;and&#39;, &#39;breaks&#39;, &#39;east&#39;, &#39;envious&#39;, &#39;fair&#39;, &#39;grief&#39;,
&#39;is&#39;, &#39;kill&#39;, &#39;light&#39;, &#39;moon&#39;, &#39;pale&#39;, &#39;sick&#39;, &#39;soft&#39;,
&#39;sun&#39;, &#39;the&#39;, &#39;through&#39;, &#39;what&#39;, &#39;window&#39;,
&#39;with&#39;, &#39;yonder&#39;]</code></pre>
<p><strong>Άσκηση 5: Μινιμαλιστικός Εξυπηρετητής Email (Email Client).</strong></p>
<p><strong>Το MBOX (mail box) είναι μια δημοφιλής μορφή αρχείου για αποθήκευση και κοινή χρήση μιας συλλογής email. Αυτό χρησιμοποιήθηκε από πρώιμους διακομιστές email και εφαρμογές επιτραπέζιου υπολογιστή. Χωρίς να μπαίνουμε σε πάρα πολλές λεπτομέρειες, το MBOX είναι ένα αρχείο κειμένου, στο οποίο αποθηκεύονται διαδοχικά email. Τα email διαχωρίζονται από μια ειδική γραμμή που ξεκινά με <code>From</code> (προσέξτε το διάστημα). Είναι σημαντικό ότι οι γραμμές που ξεκινούν με <code>From:</code> (προσέξτε την άνω και κάτω τελεία) περιγράφουν το ίδιο το email και δεν λειτουργούν ως διαχωριστικά. Φανταστείτε ότι έχετε γράψει μια μινιμαλιστική εφαρμογή email, η οποία αναφέρει τα email των αποστολέων στα Εισερχόμενα του χρήστη και μετράει τον αριθμό των email.</strong></p>
<p><strong>Γράψτε ένα πρόγραμμα που διαβάζει τα δεδομένα του γραμματοκιβωτίου και όταν εντοπίσει γραμμή που ξεκινά με “From”, χωρίζει τη γραμμή σε λέξεις, χρησιμοποιώντας τη συνάρτηση <code>split</code>. Μας ενδιαφέρει ποιος έστειλε το μήνυμα, που είναι η δεύτερη λέξη στη γραμμή From”</strong>.</p>
<pre class="{text}"><code>From stephen.marquard@uct.ac.za Sat Jan 5 09:14:16 2008</code></pre>
<p><strong>Θα αναλύει τη γραμμή From και θα εκτυπώνει τη δεύτερη λέξη κάθε γραμμής From, στη συνέχεια θα μετράει τον αριθμό των γραμμών From (όχι From:) και θα εκτυπώνει, στο τέλος, το πλήθος τους. Αυτό είναι ένα καλό δείγμα εξόδου με μερικές γραμμές που έχουν αφαιρεθεί:</strong></p>
<pre class="{text}"><code>python fromcount.py
Εισαγάγετε ένα όνομα αρχείου: mbox-short.txt
stephen.marquard@uct.ac.za
louis@media.berkeley.edu
zqian@umich.edu

[...κάποια έξοδος αφαιρέθηκε...]

ray@media.berkeley.edu
cwen@iupui.edu
cwen@iupui.edu
cwen@iupui.edu
Βρέθηκαν 27 γραμμές στο αρχείο με πρώτη λέξη το From</code></pre>
<p><strong>Άσκηση 6: Ξαναγράψτε το πρόγραμμα που ζητά από τον χρήστη μια λίστα με αριθμούς και εκτυπώνει το μέγιστο και το ελάχιστο των αριθμών, στο τέλος, όταν ο χρήστης εισάγει “τέλος”. Τροποποιήστε το πρόγραμμα ώστε να αποθηκεύει τους αριθμούς, που εισάγει ο χρήστης, σε μια λίστα και χρησιμοποιήστε τις συναρτήσεις <code>max()</code> και <code>min()</code> για να υπολογίσετε τον μέγιστο και τον ελάχιστο αριθμή μετά την ολοκλήρωση του βρόχου.</strong></p>
<pre class="{text}"><code>Εισαγάγετε έναν αριθμό: 6
Εισαγάγετε έναν αριθμό: 2
Εισαγάγετε έναν αριθμό: 9
Εισαγάγετε έναν αριθμό: 3
Εισαγάγετε έναν αριθμό: 5
Εισαγάγετε έναν αριθμό: τέλος
Μέγιστο: 9.0
Ελάχιστο: 2.0</code></pre>
</body>
</html>
<?php if ( file_exists("../bookfoot.php") ) {
  $HTML_FILE = basename(__FILE__);
  $HTML = ob_get_contents();
  ob_end_clean();
  require_once "../bookfoot.php";
}?>
