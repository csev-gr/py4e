<?php if ( file_exists("../booktop.php") ) {
  require_once "../booktop.php";
  ob_start();
}?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>-</title>
  <style>
    html {
      line-height: 1.5;
      font-family: Georgia, serif;
      font-size: 20px;
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 1em;
      }
    }
    @media print {
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, 'Lucida Console', Consolas, monospace;
      font-size: 85%;
      margin: 0;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<h1 id="συναρτήσεις">Συναρτήσεις</h1>
<h2 id="κλήση-συναρτήσεων">Κλήση συναρτήσεων</h2>
<p></p>
<p>Στο πλαίσιο του προγραμματισμού, μια <em>συνάρτηση</em> είναι μια ομάδα εντολών, που τους έχει αποδοθεί ένα όνομα και εκτελούν έναν υπολογισμό. Όταν ορίζετε μια συνάρτηση, καθορίζετε το όνομα και τη ακολουθία των εντολών. Αργότερα, μπορείτε να “καλέσετε” τη συνάρτηση με το όνομά της. Έχουμε ήδη δει ένα παράδειγμα κλήσης <em>συνάρτησης</em>:</p>
<pre class="python"><code>&gt;&gt;&gt; type(32)
&lt;class &#39;int&#39;&gt;</code></pre>
<p>Το όνομα της συνάρτησης είναι <code>type</code>. Η έκφραση στην παρένθεση καλείται <em>όρισμα</em> της συνάρτησης. Το όρισμα είναι μια τιμή ή μεταβλητή που μεταβιβάζουμε στη συνάρτηση ως είσοδό της. Το αποτέλεσμα, της συνάρτησης <code>type</code>, είναι ο τύπος του ορίσματος.</p>
<p></p>
<p>Συνηθίζουμε να λέμε ότι μια συνάρτηση “δέχεται” ένα όρισμα και “επιστρέφει” ένα αποτέλεσμα. Το αποτέλεσμα ονομάζεται <em>τιμή επιστροφής</em>.</p>
<p> </p>
<h2 id="ενσωματωμένες-συναρτήσεις">Ενσωματωμένες συναρτήσεις</h2>
<p>Η Python παρέχει μια σειρά σημαντικών ενσωματωμένων συναρτήσεων που μπορούμε να χρησιμοποιήσουμε χωρίς να χρειαστεί να τις ορίσουμε. Οι δημιουργοί της Python έγραψαν ένα σύνολο λειτουργιών για την επίλυση κοινών προβλημάτων και τις συμπεριέλαβαν σε αυτήν για να τις χρησιμοποιήσουμε.</p>
<p>Οι συναρτήσεις <code>max</code> και <code>min</code> μας δίνουν την μεγαλύτερη και την μικρότερη τιμή μιας λίστας, αντίστοιχα:</p>
<pre class="python"><code>&gt;&gt;&gt; max(&#39;Γειά σου κόσμε&#39;)
&#39;ό&#39;
&gt;&gt;&gt; min(&#39;Γειά σου κόσμε&#39;)
&#39; &#39;
&gt;&gt;&gt;</code></pre>
<p>Η συνάρτηση <code>max</code> μας λέει τον “μεγαλύτερο χαρακτήρα” της συμβολοσειράς (που αποδεικνύεται ότι είναι το γράμμα “ό”) και η συνάρτηση <code>min</code> μας δείχνει τον μικρότερο χαρακτήρα (που αποδεικνύεται ότι είναι το κενό).</p>
<p>Μια άλλη πολύ συνηθισμένη ενσωματωμένη συνάρτηση είναι η συνάρτηση <code>len</code>, που μας λέει πόσα στοιχεία υπάρχουν στο όρισμα της. Εάν το όρισμα στη <code>len</code> είναι μια συμβολοσειρά, επιστρέφει τον αριθμό των χαρακτήρων στη συμβολοσειρά.</p>
<pre class="python"><code>&gt;&gt;&gt; len(&#39;Γειά σου κόσμε&#39;)
14
&gt;&gt;&gt;</code></pre>
<p>Αυτές οι συναρτήσεις δεν περιορίζονται στην εξέταση συμβολοσειρών. Μπορούν να λειτουργήσουν σε οποιοδήποτε σύνολο τιμών, όπως θα δούμε σε επόμενα κεφάλαια.</p>
<p>Θα πρέπει να αντιμετωπίζετε τα ονόματα των ενσωματωμένων συναρτήσεων ως δεσμευμένες λέξεις (δηλαδή, αποφύγετε τη χρήση του “max” ως όνομα μεταβλητής).</p>
<h2 id="συναρτήσεις-μετατροπής-τύπου">Συναρτήσεις μετατροπής τύπου</h2>
<p></p>
<p>Η Python παρέχει επίσης ενσωματωμένες συναρτήσεις που μετατρέπουν τιμές από τον ένα τύπο στον άλλο. Η συνάρτηση <code>int</code> παίρνει οποιαδήποτε τιμή και τη μετατρέπει σε ακέραιο, αν μπορεί, ή διαφορετικά παραπονιέται:</p>
<p> </p>
<pre class="python"><code>&gt;&gt;&gt; int(&#39;32&#39;)
32
&gt;&gt;&gt; int(&#39;Γειά&#39;)
ValueError: invalid literal for int() with base 10: &#39;Γειά&#39;</code></pre>
<p>Η <code>int</code> μπορεί να μετατρέψει τιμές κινητής υποδιαστολής (floating-point) σε ακεραίους, αλλά δεν τις στρογγυλοποιεί, απλά αποκόπτει το δεκαδικό μέρος:</p>
<pre class="python"><code>&gt;&gt;&gt; int(3.99999)
3
&gt;&gt;&gt; int(-2.3)
-2</code></pre>
<p>Η <code>float</code> μετατρέπει ακεραίους και συμβολοσειρές σε αριθμούς κινητής υποδιαστολής:</p>
<p> </p>
<pre class="python"><code>&gt;&gt;&gt; float(32)
32.0
&gt;&gt;&gt; float(&#39;3.14159&#39;)
3.14159</code></pre>
<p>Τέλος, η <code>str</code> μετατρέπει το όρισμά της σε μια συμβολοσειρά:</p>
<p> </p>
<pre class="python"><code>&gt;&gt;&gt; str(32)
&#39;32&#39;
&gt;&gt;&gt; str(3.14159)
&#39;3.14159&#39;</code></pre>
<h2 id="μαθηματικές-συναρτήσεις---math">Μαθηματικές συναρτήσεις - Math</h2>
<p>   </p>
<p>Η Python διαθέτει το άρθρωμα (module) <code>math</code> που περιέχει τις περισσότερες από τις γνωστές μαθηματικές συναρτήσεις. Πριν μπορέσουμε να χρησιμοποιήσουμε τo άρθρωμα, πρέπει να το εισαγάγουμε:</p>
<pre class="python"><code>&gt;&gt;&gt; import math</code></pre>
<p>Αυτή η εντολή δημιουργεί ένα <em>αντικείμενο αρθρώματος - module object</em>, που ονομάζεται math. Εάν εκτυπώσετε το αντικείμενο αρθρώματος, θα λάβετε μερικές πληροφορίες σχετικά με αυτό:</p>
<pre class="python"><code>&gt;&gt;&gt; print(math)
&lt;module &#39;math&#39; (built-in)&gt;</code></pre>
<p>Το αντικείμενο του αρθρώματος περιέχει τις συναρτήσεις και τις μεταβλητές που ορίζονται στο module. Για να αποκτήσετε πρόσβαση σε μία από τις συναρτήσεις, πρέπει να καθορίσετε το όνομα του modume και το όνομα της συνάρτησης, χωρισμένα με μια τελεία.</p>
<p></p>
<pre class="python"><code>&gt;&gt;&gt; λόγος = ισχύς_σήματος / ισχύς_θορύβου
&gt;&gt;&gt; decibels = 10 * math.log10(λόγος)

&gt;&gt;&gt; ακτίνια = 0.7
&gt;&gt;&gt; ύψος = math.sin(ακτίνια)</code></pre>
<p>Το πρώτο παράδειγμα υπολογίζει τον λογάριθμο με βάση 10 του λόγου σήματος-θορύβου. Το module math παρέχει επίσης μια συνάρτηση που ονομάζεται <code>log</code> και υπολογίζει το νεπέριο λογάριθμο, λογάριθμο δηλαδή με βάση το e.</p>
<p>     </p>
<p>Το δεύτερο παράδειγμα βρίσκει το ημίτονο των <code>ακτινίων</code>. Το όνομα της μεταβλητής είναι μια υπόδειξη ότι το <code>sin</code> και οι άλλες τριγωνομετρικές συναρτήσεις (<code>cos</code>, <code>tan</code> κ.λπ.) δέχονται ορίσματα σε ακτίνια. Για να μετατρέψετε από μοίρες σε ακτίνια, διαιρέστε με 360 και πολλαπλασιάστε με 2π:</p>
<pre class="python"><code>&gt;&gt;&gt; μοίρες = 45
&gt;&gt;&gt; ακτίνια = μοίρες / 360.0 * 2 * math.pi
&gt;&gt;&gt; math.sin(ακτίνια)
0.7071067811865476</code></pre>
<p>Η έκφραση <code>math.pi</code> λαμβάνει τη μεταβλητή <code>π</code> από την ενότητα μαθηματικών. Η τιμή αυτής της μεταβλητής είναι μια προσέγγιση του π, με ακρίβεια περίπου 15 ψηφίων.</p>
<p> </p>
<p>Εάν γνωρίζετε τριγωνομετρία, μπορείτε να ελέγξετε το προηγούμενο αποτέλεσμα συγκρίνοντάς το με την τετραγωνική ρίζα του δύο, δια του δύο:</p>
<p> </p>
<pre class="python"><code>&gt;&gt;&gt; math.sqrt(2) / 2.0
0.7071067811865476</code></pre>
<h2 id="τυχαίος-αριθμός">Τυχαίος αριθμός</h2>
<p>   </p>
<p>Με τις ίδιες εισόδους, τα περισσότερα προγράμματα υπολογιστών παράγουν τις ίδιες εξόδους κάθε φορά, επομένως λέμε ότι είναι <em>αιτιοκρατικά</em>. Η αιτιοκρατία (ντετερμινισμός) είναι συνήθως καλό πράγμα, αφού περιμένουμε ότι ο ίδιος υπολογισμός θα δώσει το ίδιο αποτέλεσμα. Για ορισμένες εφαρμογές, ωστόσο, θέλουμε ο υπολογιστής να είναι απρόβλεπτος. Τα παιχνίδια είναι ένα προφανές παράδειγμα, αλλά υπάρχουν περισσότερα.</p>
<p>Το να κάνετε ένα πρόγραμμα πραγματικά μη ντετερμινιστικό αποδεικνύεται ότι δεν είναι τόσο εύκολο, αλλά υπάρχουν τρόποι να το κάνετε τουλάχιστον να φαίνεται μη ντετερμινιστικό. Ένας από αυτούς είναι η χρήση <em>αλγορίθμων</em> που δημιουργούν <em>ψευδοτυχαίους</em> αριθμούς. Οι ψευδοτυχαίοι αριθμοί δεν είναι πραγματικά τυχαίοι επειδή παράγονται από έναν ντετερμινιστικό υπολογισμό, αλλά κοιτάζοντας απλά τους αριθμούς αυτούς είναι αδύνατο να διακριθούν από τους τυχαίους.</p>
<p> </p>
<p>Το άρθρωμα (module) <code>random</code> παρέχει συναρτήσεις που δημιουργούν ψευδοτυχαίους αριθμούς (τους οποίους θα αποκαλώ απλώς “τυχαίους” από εδώ και πέρα).</p>
<p> </p>
<p>Η συνάρτηση <code>random</code> επιστρέφει έναν τυχαίο αριθμό κινητής υποδιαστολής μεταξύ των 0,0 και 1,0 (συμπεριλαμβανομένου του 0.0 αλλά όχι του 1.0). Κάθε φορά που καλείται την <code>random</code>, πέρνεται τον επόμενο σε σειρά αριθμό μιας μεγάλης ακολουθίας. Για να δείτε ένα παράδειγμα εκτελέστε τον παρακάτω βρόχο:</p>
<pre class="python"><code>import random

for i in range(10):
    x = random.random()
    print(x)</code></pre>
<p>Αυτό το πρόγραμμα παράγει την ακόλουθη λίστα 10 τυχαίων αριθμών μεταξύ 0,0 και 1,0, αλλά χωρίς να περιλαμβάνεται το 1,0.</p>
<pre class="text"><code>0.11132867921152356
0.5950949227890241
0.04820265884996877
0.841003109276478
0.997914947094958
0.04842330803368111
0.7416295948208405
0.510535245390327
0.27447040171978143
0.028511805472785867</code></pre>
<p><strong>Άσκηση 1: Εκτελέστε το πρόγραμμα στο σύστημά σας και δείτε ποιοι αριθμοί παράγονται. Εκτελέστε το πρόγραμμα περισσότερες από μία φορές και δείτε ποιοι αριθμοί παράγονται.</strong></p>
<p>Η συνάρτηση <code>random</code> είναι μόνο μία από τις πολλές συναρτήσεις που χειρίζονται τυχαίους αριθμούς. Η συνάρτηση <code>randint</code> δέχεται τις παραμέτρους <code>low</code> και <code>high</code> και επιστέφει έναν ακέραιο μεταξύ των <code>low</code> και <code>high</code> (συμπεριλαμβανομένων και αυτών).</p>
<p> </p>
<pre class="python"><code>&gt;&gt;&gt; random.randint(5, 10)
5
&gt;&gt;&gt; random.randint(5, 10)
9</code></pre>
<p>Για να επιλέξετε τυχαία ένα στοιχείο μιας σειράς μπορείτε να χρησιμοποιήσετε την <code>choice</code>:</p>
<p> </p>
<pre class="python"><code>&gt;&gt;&gt; t = [1, 2, 3]
&gt;&gt;&gt; random.choice(t)
2
&gt;&gt;&gt; random.choice(t)
3</code></pre>
<p>Το άρθρωμα <code>random</code> μας παρέχει και συναρτήσεις για τη δημιουργία τυχαίων τιμών από συνεχείς κατανομές, όπως ή κανονική κατανομή, η εκθετική, η γάμμα και μερικές ακόμη.</p>
<h2 id="προσθήκη-νέων-συναρτήσεων">Προσθήκη νέων συναρτήσεων</h2>
<p>Μέχρι στιγμής, χρησιμοποιούσαμε μόνο συναρτήσεις ενσωματωμένες στην Python, αλλά είναι επίσης δυνατή η προσθήκη και νέων συναρτήσεων. Ο <em>ορισμός συνάρτησης</em> καθορίζει το όνομα της νέας συνάρτησης και την ακολουθία των εντολών που εκτελούνται όταν κλιθεί ή συνάρτηση. Μόλις ορίσουμε μια συνάρτηση, μπορούμε να την επαναχρησιμοποιήσουμε, ξανά και ξανά, σε όλο το πρόγραμμά μας.</p>
<p>  </p>
<p>Ιδού και ένα παράδειγμα:</p>
<pre class="python"><code>def print_lyrics():
    print(&quot;I&#39;m a lumberjack, and I&#39;m okay.&quot;)
    print(&#39;I sleep all night and I work all day.&#39;)</code></pre>
<p><code>def</code> είναι η δεσμευμένη λέση που υποδηλώνει τον ορισμό μιας συνάρτησης. Το όνομα της συνάρτησης είναι <code>print_lyrics</code>. Οι κανόνες ονοματολογίας των συναρτήσεων είναι οι ίδιοι με αυτούς για τα ονόματα μταβλητών: γράμματα, ψηφία και κάποια σημεία στίξης επιτρέπονται, αλλά ο πρώτος χαρακτήρας δεν μπορεί να είναι ψηφίο. Δεν μπορείτε να χρησιμοποιήσετε δεσμευμένη λέξη ως όνομα συνάρτησης και πρέπει να αποφεύγετε τη χρήση μεταβλητής και συνάρτησης με το ίδιο όνομα.</p>
<p>  </p>
<p>Οι κενές παρενθέσεις μετά το όνομα σημαίνουν ότι η συγκεκριμένη συνάρτηση δεν δέχεται κάποιο όρισμα. Αργότερα, θα κατασκευάσουμε συναρτήσεις που δέχονται ορίσματα ως είσοδο.</p>
<p>    </p>
<p>Η πρώτη γραμμή της συνάρτησης, κατά τον ορισμό της, καλείται <em>επικεφαλίδα</em>, οι υπόλοιπες αποτελούν το <em>σώμα</em>. Η επικεφαλίδα πρέπει να καταλήγει σε άνω κάτω τελεία και το σώμα πρέπει να τοποθετείται σε εσοχή. Κατά σύμβαση, η εσοχη είναι πάντοτε τέσσετα κενά. Το σώμα μπορεί να περιέχει οποιοδήποτε πλήθος δηλώσεων.</p>
<p> </p>
<p>Αν ορίσετε μια συνάρτηση σε interactive mode, ο διερμηνευτής εκτυπώνει ellipses (<em>…</em>) στην επόμενη γραμμή για να σας ενημερώσει ότι ο ορισμός δεν έχει ολοκληρωθεί:</p>
<pre class="python"><code>&gt;&gt;&gt; def print_lyrics():
...     print(&quot;I&#39;m a lumberjack, and I&#39;m okay.&quot;)
...     print(&#39;I sleep all night and I work all day.&#39;)
...</code></pre>
<p>Για να ολοκληρώσετε τη συνάρτηση πρέπει να εισάγετε μια κενή γραμμή (αυτό δεν είναι απαραίτητο σε ένα σενάριο).</p>
<p>Ο ορισμός μιας συνάρτησης δημιουργεί μια μεταβλητή με το ίδιο όνομα.</p>
<pre class="python"><code>&gt;&gt;&gt; print(print_lyrics)
&lt;function print_lyrics at 0xb7e99e9c&gt;
&gt;&gt;&gt; print(type(print_lyrics))
&lt;class &#39;function&#39;&gt;</code></pre>
<p>Η τιμή του <code>print_lyrics</code> είναι ένα <em>αντικείμενο function (συνάρητηση)</em>, το οποίο είναι του τύπου “function”.</p>
<p>  </p>
<p>Η σύνταξη κλήσης της νέας συνάρτησης είναι ίδια όπως και των ενσωματομένων συναρτήσεων:</p>
<pre class="python"><code>&gt;&gt;&gt; print_lyrics()
I&#39;m a lumberjack, and I&#39;m okay.
I sleep all night and I work all day.</code></pre>
<p>Αφού ορίσετε μια συνάρτηση, μπορείτε να τη χρησιμοποιήσετε μέσα σε μια άλλη συνάρτηση. Για παράδειγμα, για να επαναλάβουμε το προηγούμενο ρεφρέν, θα μπορούσαμε να γράψουμε μια συνάρτηση που ονομάζεται <code>repeat_lyrics</code>:</p>
<pre class="python"><code>def repeat_lyrics():
    print_lyrics()
    print_lyrics()</code></pre>
<p>Και στη συνέχεια να καλέσουμε την <code>repeat_lyrics</code>:</p>
<pre class="python"><code>&gt;&gt;&gt; repeat_lyrics()
I&#39;m a lumberjack, and I&#39;m okay.
I sleep all night and I work all day.
I&#39;m a lumberjack, and I&#39;m okay.
I sleep all night and I work all day.</code></pre>
<p>Αλλά στην πραγματικότητα δεν πάει έτσι το τραγούδι.</p>
<h2 id="ορισμός-και-χρήση">Ορισμός και χρήση</h2>
<p></p>
<p>Συνδυάζοντας τα τμήματα κώδικα από την προηγούμενη ενότητα, ολoκληρωμένο το πρόγραμμα μοιάζει κάπως έτσι:</p>
<pre class="python"><code>def print_lyrics():
    print(&quot;I&#39;m a lumberjack, and I&#39;m okay.&quot;)
    print(&#39;I sleep all night and I work all day.&#39;)


def repeat_lyrics():
    print_lyrics()
    print_lyrics()

repeat_lyrics()

# Code: http://www.gr.py4e.com/code3/lyrics.py</code></pre>
<p>Αυτό το πρόγραμμα περιέχει δύο ορισμούς συναρτήσεων: <code>print_lyrics</code> και <code>repeat_lyrics</code>. Οι ορισμοί των συναρτήσεων εκτελούνται όπως και κάθε άλλη εντολή, αλλά το αποτέλεσμά τους είναι η δημιουργία αντικειμένων συνάρτησης. Οι εντολές που περιέχονται σε μία συνάρτηση δεν εκτελούνται έως ότου κληθεί η συνάρτηση και ο ορισμός της συνάρτησης δεν παράγει έξοδο.</p>
<p></p>
<p>Όπως θα περίμενε κανείς, πρέπει να δημιουργήσετε μια συνάρτηση πριν την εκτελέσετε. Με άλλα λόγια, ο ορισμός της συνάρτησης πρέπει να εκτελεστεί πριν από την πρώτη φορά που θα κληθεί.</p>
<p><strong>Άσκηση 2: Μετακινήστε την τελευταία γραμμή αυτού του προγράμματος στην αρχή του, έτσι ώστε η κλήση της συνάρτησης να εμφανίζεται πριν από τον ορισμό της. Εκτελέστε το πρόγραμμα και δείτε ποιο μήνυμα λάθους λαμβάνετε.</strong></p>
<p><strong>Άσκηση 3: Μετακινήστε την κλήση συνάρτησης και πάλι στο κάτω μέρος καθώς και τον ορισμό του <code>print_lyrics</code> μετά τον ορισμό του <code>repeat_lyrics</code>. Τι συμβαίνει όταν εκτελείτε αυτό το πρόγραμμα;</strong></p>
<h2 id="ροή-εκτέλεσης">Ροή εκτέλεσης</h2>
<p></p>
<p>Για να διασφαλίσετε ότι μια συνάρτηση ορίζεται πριν από την πρώτη της χρήση, πρέπει να γνωρίζετε τη σειρά με την οποία εκτελούνται οι εντολές, η σειρά αυτή ονομάζεται <em>ροή εκτέλεσης</em>.</p>
<p>Η εκτέλεση αρχίζει πάντα με την πρώτη εντολή του προγράμματος. Οι εντολές εκτελούνται μία κάθε φορά, με σειρά από πάνω προς τα κάτω.</p>
<p>Οι <em>ορισμοί</em> συναρτήσεων δεν αλλάζουν τη ροή εκτέλεσης του προγράμματος, αλλά να θυμάστε ότι οι εντολές που περιλαμβάνονται στη συνάρτηση δεν εκτελούνται μέχρι να κληθεί η συνάρτηση.</p>
<p>Μια κλήση συνάρτησης είναι σαν μια παράκαμψη στη ροή της εκτέλεσης. Αντί να μεταβεί στην επόμενη πρόταση, η ροή μεταβαίνει στο σώμα της συνάρτησης, εκτελεί όλες τις εντολές εκεί και μετά επιστρέφει για να συνεχίσει από εκεί που σταμάτησε.</p>
<p>Αυτό ακούγεται αρκετά απλό, έως ότου θυμηθείτε ότι μια συνάρτηση μπορεί να καλέσει μια άλλη. Ενώ βρίσκεται στη μέση μιας συνάρτησης, το πρόγραμμα μπορεί να χρειαστεί να εκτελέσει τις εντολές μιας άλλης συνάρτησης. Αλλά και κατά την εκτέλεση αυτής της νέας συνάρτησης, το πρόγραμμα μπορεί να χρειαστεί να εκτελέσει ακόμη μια συνάρτηση!</p>
<p>Ευτυχώς, η Python είναι καλή στο να παρακολουθεί πού βρίσκεται η ροή εκτέλεσης του προγράμματος, επομένως κάθε φορά που ολοκληρώνεται μια συνάρτηση, το πρόγραμμα συνεχίζει από εκεί που σταμάτησε στη συνάρτηση όπου πραγματοποιήθηκε η κλήση. Όταν η ροή εκτέλεσης φτάσει στο τέλος του προγράμματος, αυτό τερματίζει.</p>
<p>Ποιο είναι το ηθικό δίδαγμα αυτής της ατυχής ιστορίας; Όταν διαβάζετε ένα πρόγραμμα, δεν είναι πάντα καλό το να διαβάζετε από πάνω προς τα κάτω. Μερικές φορές είναι προτιμότερο να ακολουθείτε τη ροή της εκτέλεσης.</p>
<h2 id="παράμετροι-και-ορίσματα">Παράμετροι και ορίσματα</h2>
<p>   </p>
<p>Ορισμένες από τις ενσωματωμένες συναρτήσεις που έχουμε δει απαιτούν ορίσματα. Για παράδειγμα, όταν καλείτε την <code>math.sin</code> περνάτε έναν αριθμό ως όρισμα. Ορισμένες συναρτήσεις λαμβάνουν περισσότερα από ένα όρισμα: η <code>math.pow</code> δέχεται δύο, τη βάση και τον εκθέτη.</p>
<p>Μέσα στη συνάρτηση, τα ορίσματα εκχωρούνται σε μεταβλητές που ονομάζονται <em>παράμετροι</em>. Ακολουθεί ένα παράδειγμα συνάρτησης που ορίζεται από το χρήστη που δέχεται ένα όρισμα:</p>
<p></p>
<pre class="python"><code>def print_twice(bruce):
    print(bruce)
    print(bruce)</code></pre>
<p>Αυτή η συνάρτηση εκχωρεί το όρισμα σε μια παράμετρο που ονομάζεται <code>bruce</code>. Όταν καλείται η συνάρτηση, εκτυπώνει την τιμή της παραμέτρου (όποια και αν είναι) δύο φορές.</p>
<p>Η συνάρτηση αυτή λειτουργεί με οποιαδήποτε τιμή μπορεί να εκτυπωθεί.</p>
<pre class="python"><code>&gt;&gt;&gt; print_twice(&#39;Spam&#39;)
Spam
Spam
&gt;&gt;&gt; print_twice(17)
17
17
&gt;&gt;&gt; import math
&gt;&gt;&gt; print_twice(math.pi)
3.141592653589793
3.141592653589793</code></pre>
<p>Οι ίδιοι κανόνες σύνταξης που ισχύουν για τις ενσωματωμένες συναρτήσεις ισχύουν και για τις συναρτήσεις που ορίζονται από το χρήστη, επομένως μπορούμε να χρησιμοποιήσουμε οποιοδήποτε είδος έκφρασης ως όρισμα για το <code>print_twice</code>:</p>
<p></p>
<pre class="python"><code>&gt;&gt;&gt; print_twice(&#39;Spam &#39;*4)
Spam Spam Spam Spam
Spam Spam Spam Spam
&gt;&gt;&gt; print_twice(math.cos(math.pi))
-1.0
-1.0</code></pre>
<p>Το όρισμα αξιολογείται πριν από την κλήση της συνάρτησης, επομένως στα παραδείγματα οι εκφράσεις <code>'Spam' *4</code> και <code>math.cos(math.pi)</code> αξιολογούνται μόνο μία φορά.</p>
<p></p>
<p>Μπορείτε επίσης να χρησιμοποιήσετε ως όρισμα μια μεταβλητή:</p>
<pre class="python"><code>&gt;&gt;&gt; michael = &#39;Eric, the half a bee.&#39;
&gt;&gt;&gt; print_twice(michael)
Eric, the half a bee.
Eric, the half a bee.</code></pre>
<p>Το όνομα της μεταβλητής, που δίνουμε ως όρισμα (<code>michael</code>) δεν έχει καμία σχέση με το όνομα της παραμέτρου (<code>bruce</code>). Δεν έχει σημασία τι όνομα είχε τη τιμή στο προηγούμενο πρόγραμμα (σε αυτό από το οποίο έγινε η κλήση), εδώ στην <code>print_twice</code> αποκαλείται <code>bruce</code>.</p>
<h2 id="γόνιμες-και-κενές-συναρτήσεις">Γόνιμες και κενές συναρτήσεις</h2>
<p>   </p>
<p>Κάποιες από τις συναρτήσεις που χρησιμοποιούμε, όπως οι μαθηματικές συναρτήσεις (math) επιστρέφουν αποτελέσματα. Λόγω έλλειψης κάποιου καλύτερου ονόματος, τις αποκαλώ <em>γόνιμες συναρτήσεις</em> (fruitful functions). Άλλες συναρτήσεις, όπως η <code>print_twice</code>, εκτελούν μια λειτουργία αλλά δεν επιστρέφουν κάποια τιμή. Αυτές τις αποκαλώ <em>κενές συναρτήσεις</em> (void functions).</p>
<p>Όταν καλείτε μία γόνιμη συνάρτηση, σχεδόν πάντα θέλετε να κάνετε κάτι με το αποτέλεσμα της. Για παράδειγμα, ίσως θα το εκχωρήσετε σε μία μεταβλητή ή θα το χρησιμοποιήσετε ως μέρος μιας έκφρασης:</p>
<pre class="python"><code>x = math.cos(radians)
golden = (math.sqrt(5) + 1) / 2</code></pre>
<p>Όταν καλείτε μια συνάρτηση σε interactive mode, η Python εμφανίζει το αποτέλεσμα:</p>
<pre class="python"><code>&gt;&gt;&gt; math.sqrt(5)
2.23606797749979</code></pre>
<p>Αλλά σε ένα σενάριο, αν καλέσετε μια γόνιμη συνάρτηση χωρίς να την εκχωρήσετε σε μια μεταβλητή, η επιστρεφόμενη τιμή εξαφανίζεται στην ομίχλη!</p>
<pre class="python"><code>math.sqrt(5)</code></pre>
<p>Αυτό το σενάριο υπολογίζει την τετραγωνική ρίζα του 5, αλλά μιας και δεν αποθηκεύει το αποτέλεσμα σε κάποια μεταβλητή, ούτε εμφανίζει το αποτέλεσμα, δεν είναι πολύ χρήσιμο.</p>
<p> </p>
<p>Οι κενές (void) συναρτήσεις μπορεί να εμφανίζουν κάτι στην οθόνη ή να έχουν κάποιο άλλο αποτέλεσμα, αλλά δεν έχουν επιστρεφόμενη τιμή. Αν προσπαθήσετε να εκχωρήσετε το αποτέλεσμα σε μία μεταβλητή, θα πάρετε μια ειδική τιμή την ονομαζόμενη <code>None</code>.</p>
<p>index{None ειδική τιμή} </p>
<pre class="python"><code>&gt;&gt;&gt; result = print_twice(&#39;Bing&#39;)
Bing
Bing
&gt;&gt;&gt; print(result)
None</code></pre>
<p>Η τιμή <code>None</code> δεν είναι ίδια με τη συμβολοσειρά “None”. Είναι μια ειδική τιμή η οποία έχει τον δικό της τύπο:</p>
<pre class="python"><code>&gt;&gt;&gt; print(type(None))
&lt;class &#39;NoneType&#39;&gt;</code></pre>
<p>Για να επιστρέψουμε ένα αποτέλεσμα από τη συνάρτηση, χρησιμοποιούμε την εντολή <code>return</code> στο σώμα της συνάρτησης. Για παράδειγμα, θα μπορούσαμε να κατασκευάσουμε μια πολύ απλή συνάρτηση με όνομα <code>addtwo</code>, η οποία προσθέτει δύο αριθμούς και επιστρέφει το αποτέλεσμα.</p>
<pre class="python"><code>def addtwo(a, b):
    added = a + b
    return added

x = addtwo(3, 5)
print(x)

# Code: http://www.gr.py4e.com/code3/addtwo.py</code></pre>
<p>Όταν το παραπάνω σενάριο εκτελείτε, η εντολή <code>print</code> θα εκτυπώσει το “8” γιατί η συνάρτηση <code>addtwo</code> κλήθηκε με ορίσματα το 3 και το 5. Μέσα στη συνάρτηση, οι παράμετροι <code>a</code> και <code>b</code> ήταν 3 και 5 αντίστοιχα. Η συνάρτηση υπολογίζει το άθροισμα των δύο αριθμών και το τοποθετεί στην τοπική μεταβλητή της συνάρτησης με όνομα <code>added</code>. Έπειτα χρησιμοποιεί την εντολή <code>return</code> για να στείλει την υπολογισμένη τιμή πίσω στον καλούντα κώδικα, ως αποτέλεσμα της συνάρτησης, όπου είχε εκχωρηθεί στην μεταβλητή <code>x</code> και την εκτυπώνει.</p>
<h2 id="γιατί-συναρτήσεις">Γιατί συναρτήσεις;</h2>
<p></p>
<p>Ίσως να μην έγινε σαφής ο λόγος για τον οποίο αξίζει να χωρίζουμε ένα πρόγραμμα σε συναρτήσεις. Υπάρχουν αρκετοί λόγοι:</p>
<ul>
<li><p>Η δημιουργία μιας νέας συνάρτησης σας δίνει την δυνατότητα να ονομάσετε ένα σύνολο δηλώσεων, γεγονός το οποίο κάνει το πρόγραμμα ευκολότερο στην ανάγνωση και στην εκσφαλμάτωση.</p></li>
<li><p>Οι συναρτήσεις μπορούν να ελαττώσουν το μέγεθος ενός προγράμματος καταργώντας τον επαναλαμβανόμενο κώδικα. Αργότερα, αν κάνετε κάποια αλλαγή, αρκεί να την κάνετε μόνο σε ένα σημείο.</p></li>
<li><p>Η διαίρεση ενός μεγάλου προγράμματος σε συναρτήσεις σας επιτρέπει να εκσφαλματώσετε τα τμήματά του ένα ένα και στη συνέχεια να τα ενσωματώσετε όλα σε ένα ολοκληρωμένο λειτουργικό πρόγραμμα.</p></li>
<li><p>Οι καλοσχεδιασμένες συναρτήσεις είναι συχνά χρήσιμες για πολλά προγράμματα. Μόλις γράψετε και εκσφαλματώσετε μία, μπορείτε να την χρησιμοποιήσετε.</p></li>
</ul>
<p>Σε όλο το υπόλοιπο βιβλίο, συχνά θα ορίζουμε μια συνάρτηση για να εξηγήσουμε μια έννοια. Μέρος της ικανότητας δημιουργίας και χρήσης συναρτήσεων είναι να δημιουργείτε μια συνάρτηση που να αποτυπώνει σωστά μια ιδέα όπως “βρείτε τη μικρότερη τιμή σε μια λίστα τιμών”. Αργότερα θα σας δείξουμε κώδικα που βρίσκει τη μικρότερη από μια λίστα τιμών και θα σας τον παρουσιάσουμε ως μια συνάρτηση με το όνομα <code>min</code>, η οποία παίρνει μια λίστα τιμών ως όρισμα και επιστρέφει τη μικρότερη τιμή στη λίστα.</p>
<h2 id="εκσφαλμάτωση">Εκσφαλμάτωση</h2>
<p></p>
<p>Αν χρησιμοποιείτε έναν επεξεργαστή κειμένου για να γράψετε τα σενάριά σας, ίσως αντιμετωπίσετε προβλήματα με τα κενά διαστήματα και τους στηλοθέτες (tabs). Ο καλύτερος τρόπος για να αποφύγετε αυτού του είδους προβλήματα είναι να χρησιμοποιείτε αποκλειστικά κενά διαστήματα (όχι στηλοθέτες). Οι περισσότεροι επεξεργαστές κειμένου που είναι συμβατοί με την Python το κάνουν αυτό εξ ορισμού, αλλά κάποιοι άλλοι όχι.</p>
<p> </p>
<p>Οι στηλοθέτες και τα κενά διαστήματα είναι συνήθως μη ορατά, κάτι το οποίο κάνει δύσκολη την εκσφαλμάτωση, οπότε προσπαθήστε να βρείτε έναν επεξεργαστή που να μπορεί να διαχειριστεί την ενδοπαραγραφοποίηση.</p>
<p>Επίσης, μην ξεχνάτε να αποθηκεύετε το πρόγραμμά σας πριν το εκτελέσετε. Κάποια προγραμματιστικά περιβάλλοντα το κάνουν αυτόματα, αλλά κάποια άλλα όχι. Σε αυτήν την περίπτωση, το πρόγραμμα που βλέπετε στον επεξεργαστή κειμένου δεν είναι το ίδιο με το πρόγραμμα που εκτελείτε.</p>
<p>Η εκσφαλμάτωση μπορεί να γίνει χρονοβόρα αν εκτελείτε το ίδιο εσφαλμένο πρόγραμμα ξανά και ξανά!</p>
<p>Σιγουρευτείτε πως ο κώδικας που κοιτάτε είναι ο κώδικας που εκτελείτε. Αν δεν είστε σίγουροι, γράψτε κάτι όπως το <code>print("hello")</code> στην αρχή του προγράμματος και εκτελέστε το ξανά. Αν δεν δείτε <code>hello</code>, δεν εκτελείτε το σωστό πρόγραμμα!</p>
<h2 id="γλωσσάριο">Γλωσσάριο</h2>
<dl>
<dt>dot notation (χωρισμός με τελεία)</dt>
<dd>Η σύνταξη για την κλήση μιας συνάρτησης, που περιέχεται σε ένα άρθρωμα, καθορίζοντας το όνομα του αρθρώματος ακολουθούμενο από μια τελεία και το όνομα της συνάρτησης.
</dd>
<dt>αιτιοκρατισμός (deterministic)</dt>
<dd>Αφορά ένα πρόγραμμα που κάνει το ίδιο πράγμα κάθε φορά που εκτελείται, με τις ίδιες εισόδους.
</dd>
<dt>αλγόριθμος</dt>
<dd>Μια γενική μέθοδος για την επίλυση μιας κατηγορίας προβλημάτων.
</dd>
<dt>αντικείμενο αρθρώματος (module)</dt>
<dd>Μια τιμή που δημιουργείται από μια εντολή <code>import</code> και παρέχει πρόσβαση στα δεδομένα και τον κώδικα που ορίζονται σε ένα άρθρωμα (module).
</dd>
<dt>αντικείμενο συνάρτηση</dt>
<dd>Μια τιμή που δημιουργείται από τον ορισμό μιας συνάρτησης. Το όνομα της συνάρτησης είναι μια μεταβλητή που αναφέρεται σε ένα αντικείμενο συνάρτησης.
</dd>
<dt>γόνιμη συνάρτηση (fruitful function)</dt>
<dd>Μια συνάρτηση που επιστρέφει μια τιμή.
</dd>
<dt>εντολή import</dt>
<dd>Μια εντολή που διαβάζει ένα αρχείο αρθρώματος και δημιουργεί ένα αντικείμενο αρθρώματος.
</dd>
<dt>επικεφαλίδα</dt>
<dd>Η πρώτη γραμμή του ορισμού μιας συνάρτησης.
</dd>
<dt>κενή συνάρτηση (void function)</dt>
<dd>Μια συνάρτηση που δεν επιστρέφει τιμή.
</dd>
<dt>κλήση συνάρτησης</dt>
<dd>Μια δήλωση που εκτελεί μια συνάρτηση. Αποτελείται από το όνομα της συνάρτησης που ακολουθείται από μια λίστα ορισμάτων.
</dd>
<dt>ορισμός συνάρτησης</dt>
<dd>Μια δήλωση που δημιουργεί μια νέα συνάρτηση, προσδιορίζοντας το όνομά της, τις παραμέτρους και τις εντολές που εκτελεί.
</dd>
<dt>όρισμα</dt>
<dd>Μια τιμή που παρέχεται σε μια συνάρτηση όταν η συνάρτηση καλείται. Αυτή η τιμή αποδίδεται στην αντίστοιχη παράμετρο στη συνάρτηση.
</dd>
<dt>παράμετρος</dt>
<dd>Ένα όνομα (μεταβλητής) που χρησιμοποιείται μέσα σε μια συνάρτηση για να αναφερθούμε στην τιμή που δόθηκε ως όρισμα κατά την κλήση της.
</dd>
<dt>ροή εκτέλεσης</dt>
<dd>Η σειρά με την οποία εκτελούνται οι εντολές κατά την εκτέλεση ενός προγράμματος.
</dd>
<dt>συνάρτηση</dt>
<dd>Μια επώνυμη ακολουθία εντολών που εκτελεί κάποια χρήσιμη λειτουργία. Οι συναρτήσεις μπορεί να δέχονται, ή και όχι, ορίσματα και μπορεί να παράγουν ή να μην παράγουν αποτέλεσμα.
</dd>
<dt>σύνθεση (composition)</dt>
<dd>Η χρήση μιας έκφρασης ως μέρος μιας μεγαλύτερης έκφρασης, ή μιας δήλωσης ως μέρος μιας μεγαλύτερης δήλωσης.
</dd>
<dt>σώμα</dt>
<dd>Η ακολουθία των εντολών μέσα σε έναν ορισμό συνάρτησης.
</dd>
<dt>τιμή επιστροφής</dt>
<dd>Το αποτέλεσμα μιας συνάρτησης. Αν η κλήση της συνάρτησης χρησιμοποιηθεί ως έκφραση, η τιμή επιστροφής είναι η τιμή της έκφρασης.
</dd>
<dt>ψευδοτυχαίο</dt>
<dd>Αφορά μια ακολουθία αριθμών που φαίνεται να είναι τυχαίοι, αλλά παράγονται από ένα ντετερμινιστικό (αιτιοκρατικό) πρόγραμμα.
</dd>
</dl>
<h2 id="ασκήσεις">Ασκήσεις</h2>
<p><strong>Άσκηση 4: Ποιος είναι ο σκοπός της δεσμευμένης λέξης “def” στην Python;</strong></p>
<p>a) Είναι αργκό που σημαίνει “ο παρακάτω κώδικας είναι πολύ ωραίος”<br />
b) Υποδεικνύει την αρχή μιας συνάρτησης<br />
c) Υποδεικνύει ότι η ενότητα κώδικα που ακολουθεί σε εσοχή πρόκειται να αποθηκευτεί για αργότερα<br />
d) Ισχύουν το b και το c<br />
e) Κανένα από τα παραπάνω</p>
<p><strong>Άσκηση 5: Τι θα εκτυπώσει το παρακάτω πρόγραμμα Python;</strong></p>
<pre class="python"><code>def fred():
   print(&quot;Zap&quot;)

def jane():
   print(&quot;ABC&quot;)

jane()
fred()
jane()</code></pre>
<p>a) Zap ABC jane fred jane<br />
b) Zap ABC Zap<br />
c) ABC Zap jane<br />
d) ABC Zap ABC<br />
e) Zap Zap Zap</p>
<p><strong>Άσκηση 6: Ξαναγράψτε τον υπολογισμό του ακαθάριστου μισθού (Άσκηση 1 του 3ου Κεφαλαίου) και δημιουργήστε μια συνάρτηση με όνομα <code>computepay</code> η οποία δέχεται δύο παραμέτρους (<code>hours</code> και <code>rate</code>).</strong></p>
<pre class="text"><code>Δώστε Ώρες: 45
Δώστε Ποσό/Ώρα: 10
Μισθός: 475.0</code></pre>
<p><strong>Άσκηση 7: Ξαναγράψτε το πρόγραμμα βαθμολόγησης του προηγούμενου κεφαλαίου, χρησιμοποιώντας τώρα μια συνάρτηση με όνομα <code>computegrade</code> η οποία δέχεται έναν βαθμό ως παράμετρο και επιστρέφει την αντίστοιχη αξιολόγηση ως string.</strong></p>
<pre class="text"><code>Βαθμός  Αξιολόγηση
&gt;= 0.9     A
&gt;= 0.8     B
&gt;= 0.7     C
&gt;= 0.6     D
 &lt; 0.6     F</code></pre>
<pre class="text"><code>Εισάγετε βαθμολογία: 0.95
A</code></pre>
<pre class="text"><code>Εισάγετε βαθμολογία: τέλεια
Άκυρη βαθμολογία</code></pre>
<pre class="text"><code>Εισάγετε βαθμολογία: 10.0
Άκυρη βαθμολογία</code></pre>
<pre class="text"><code>Εισάγετε βαθμολογία: 0.75
C</code></pre>
<pre class="text"><code>Εισάγετε βαθμολογία: 0.5
F</code></pre>
<p>Εκτελέστε το πρόγραμμα επανειλημμένα όπως φαίνεται παραπάνω για να το δοκιμάσετε για τις διαφορετικές τιμές εισόδου.</p>
</body>
</html>
<?php if ( file_exists("../bookfoot.php") ) {
  $HTML_FILE = basename(__FILE__);
  $HTML = ob_get_contents();
  ob_end_clean();
  require_once "../bookfoot.php";
}?>
